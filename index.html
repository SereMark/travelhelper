<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 16px; /* Base for mobile */
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.6rem 0.8rem; /* Slightly reduced padding */
    font-weight: 600; font-size: 1rem; /* Slightly reduced font size */
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .title { flex-grow: 1; text-align: center; margin-left: 45px; /* Adjust for button */ }
header button#toggleLogBtn {
    font-size: 0.8rem; padding: 0.3rem 0.7rem; min-width: 45px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover:not(:disabled) { background: var(--trk); }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area {
    padding: 0.7rem 1rem; display: flex; flex-direction: column; gap: 0.7rem;
    background: var(--bg); border-bottom: 1px solid var(--trk);
    flex-shrink: 0; max-height: 38vh; /* Max height for controls */
    overflow-y: auto; -webkit-overflow-scrolling: touch;
}
.control-group { display: flex; flex-direction: column; gap: 0.25rem; }
.control-row { display: flex; gap: 0.5rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 75px; padding: 0.6rem 0.4rem; font-size: 0.85rem; }
#apiKeyDisplay { font-size: 0.85rem; color: var(--fg); background: var(--trk); padding: 0.6rem; border-radius: 7px; flex-grow: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

input[type="password"], select, button, textarea {
    padding: 0.7rem; border-radius: 7px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.9rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.8rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.05rem; }
output { font-weight: 500; margin-left: 0.25rem; font-feature-settings: "tnum"; }

.range { appearance: none; width: 100%; height: 7px; border-radius: 3.5px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:24px; height:24px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3.5px var(--shadow-color); cursor:grab; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:24px; height:24px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3.5px var(--shadow-color); cursor:grab; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area {
    flex-grow: 1; /* Takes up remaining vertical space */
    display: flex; justify-content: center; align-items: center;
    padding: 0.3rem; background: #0a0a0a; overflow: hidden; position: relative;
    min-height: 200px; /* Minimum height to ensure visibility */
}
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 7px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 8px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }

/* Spinner overlay on video - only spinner, no text */
.video-spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.3); /* Lighter overlay for just spinner */
    z-index: 5; opacity:0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s; pointer-events: none;
}
.video-spinner-overlay.visible { opacity:1; visibility: visible; }
.spinner { border: 3px solid rgba(255,255,255,0.2); border-top: 3px solid var(--hi); border-radius: 50%; width: 30px; height: 30px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

/* Critical full-screen messages (API key, permissions) */
.critical-message-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.75); backdrop-filter: blur(3px); color: white;
    font-size: 1rem; text-align:center; padding:1.5rem; z-index: 15; /* Higher z-index */
    opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
}
.critical-message-overlay.visible { opacity:1; visibility: visible; }

/* Status Bar - Below video, above action buttons */
.status-bar {
    padding: 0.4rem 1rem; text-align: center; font-size: 0.85rem;
    background-color: var(--bg); border-top: 1px solid var(--trk); border-bottom: 1px solid var(--trk);
    color: var(--fg); flex-shrink: 0; min-height: 1.5em; /* Ensure space even if empty */
    line-height: 1.3;
}
.status-bar.error { color: var(--err); font-weight: 500; }
.status-bar.success { color: var(--succ); font-weight: 500; }

.actions-bar { padding: 0.6rem 1rem; display: flex; gap: 0.6rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.75rem; font-size: 0.95rem; font-weight: 600; }

/* Log Panel - Collapsible */
.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column;
    height: 40vh; max-height: 280px; background-color: color-mix(in srgb, var(--bg) 97%, black);
    border-top: 1px solid var(--hi); box-shadow: 0 -3px 12px rgba(0,0,0,0.35);
    transform: translateY(100%); transition: transform 0.3s ease-in-out;
    z-index: 100;
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.7rem; line-height: 1.3; padding: 0.3rem 0.6rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.3rem 0.6rem; gap: 0.6rem; flex-shrink: 0; }
.log-bar button { padding: 0.3rem 0.6rem; font-size: 0.75rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.8rem; height: 0.8rem; accent-color: var(--hi); }

.toast { /* ... (same style) ... */
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.9rem 1.3rem; border-radius: 25px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.95rem; box-shadow: 0 3px 12px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none;
}
.toast.show { opacity: 1; top: 30px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: 0px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>
            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>
            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>
            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="videoSpinnerOverlay" class="video-spinner-overlay"> {/* Only for spinner */}
                    <div id="spinnerIcon" class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="criticalMessageOverlay" class="critical-message-overlay"> {/* For API key prompt, permission errors */}
             <p id="criticalMessageText"></p>
        </div>
    </div>

    <div id="statusBar" class="status-bar">Initializing...</div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages will appear here..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy Log</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
};

const logger = { /* ... (same logic, ensure it writes to logTextarea correctly) ... */
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) =>
                    typeof value === 'bigint' ? value.toString() : value, 2);
                logTextarea.value += detailStr + "\n";
            } catch (e) { logTextarea.value += "[Details: Unserializable Object]\n"; }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => { console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); },
    error: (message, errorObj) => {
        const errMsg = errorObj instanceof Error ? errorObj.message : (errorObj ? String(errorObj) : '');
        const fullMsg = `${message}${errMsg ? ': ' + errMsg : ''}`; console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMsg}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message } : errorObj);
        showToast(message.length > 40 ? message.substring(0,37)+'...' : message, 'error', 5000);
    },
    success: (message, details) => { console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); showToast(message, 'success');}
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') { /* ... (same) ... */
    let timer;
    const timeoutPromise = new Promise((_, reject) => { timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms); });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3000) => { /* ... (same) ... */
    const el = $('toast'); clearTimeout(AppState.toastTimeout); el.textContent = message;
    el.className = 'toast'; if (type === 'error') el.classList.add('error'); else if (type === 'success') el.classList.add('success');
    el.classList.add('show'); AppState.toastTimeout = setTimeout(() => { el.classList.remove('show'); }, duration);
};

// --- New Status Update Logic ---
const updateStatus = (message, type = 'info', showSpinnerOnVideo = false) => {
    const statusBar = $('statusBar');
    const videoSpinnerOverlay = $('videoSpinnerOverlay');
    const criticalOverlay = $('criticalMessageOverlay');
    const criticalMessageText = $('criticalMessageText');

    statusBar.textContent = message;
    statusBar.className = 'status-bar'; // Reset classes
    if (type === 'error') statusBar.classList.add('error');
    else if (type === 'success') statusBar.classList.add('success');

    videoSpinnerOverlay.classList.toggle('visible', showSpinnerOnVideo);
    
    // Hide critical overlay by default, only show if message type is 'critical'
    criticalOverlay.classList.remove('visible');
    if (type === 'critical') {
        criticalMessageText.innerHTML = message; // Allow HTML for critical messages
        criticalOverlay.classList.add('visible');
        videoSpinnerOverlay.classList.remove('visible'); // Don't show both
        statusBar.textContent = ''; // Clear status bar if critical message is shown
    }
};


const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    // API Key section
    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) { $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`; }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;

    // Camera Controls
    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;
    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;
    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    // Action Buttons
    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Log';

    // Status Update Logic (driven by AppState)
    // Critical overlay is managed directly by functions that need it.
    if (AppState.isInitializingCamera) {
        updateStatus("Initializing camera...", 'info', true); // Show spinner on video
    } else if (!keyPresent) {
        updateStatus("Welcome!<br>Please enter OpenAI API Key.", 'critical'); // Use critical overlay
    } else if (!AppState.videoTrack) { // Key present, but no video track
        // Error message for no camera/permissions already shown by listCameras/initCamera using 'critical' or 'error' status.
        // If status bar is empty, provide a default.
        if ($('statusBar').textContent.trim() === '' || $('statusBar').textContent === 'Initializing...') {
             updateStatus("Camera not available. Check permissions.", 'error');
        }
    } else if (AppState.isProcessing) {
        // Status like "Capturing...", "Analyzing..." handled by processFrame using updateStatus
    } else if (cameraIsActuallyReady) {
        updateStatus("Ready! Aim at problem.", 'success', false); // No spinner when ready
    }
};

const setupCameraControls = () => { /* ... (same logic, ensure updateUI is called) ... */
    if (!AppState.videoTrack) { AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null; updateUI(); return; }
    const cap = AppState.videoTrack.getCapabilities(); const set = AppState.videoTrack.getSettings(); AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null;
    if(cap.zoom){AppState.cameraCapabilities.zoom={...cap.zoom};$('zoomSlider').min=cap.zoom.min||1;$('zoomSlider').max=cap.zoom.max||10;$('zoomSlider').step=cap.zoom.step||0.1;const curZ=set.zoom||cap.zoom.min||1;$('zoomSlider').value=curZ;$('zoomOutput').textContent=parseFloat(curZ).toFixed(1);AppState.currentZoom=parseFloat(curZ);updateZoomTypeIndicator();}
    if(cap.focusMode?.includes("manual")&&cap.focusDistance){AppState.cameraCapabilities.focus={...cap.focusDistance};$('focusSlider').min=cap.focusDistance.min||0;$('focusSlider').max=cap.focusDistance.max||1;$('focusSlider').step=cap.focusDistance.step||0.01;$('focusSlider').value=set.focusDistance||cap.focusDistance.min||0;$('focusOutput').textContent=parseFloat($('focusSlider').value).toFixed(2);}
    updateUI();
};

const releaseCamera = () => { /* ... (same logic) ... */
    if(AppState.mediaStream){AppState.mediaStream.getTracks().forEach(t=>t.stop());logger.log("Camera stream released.");}
    $('videoPreview').srcObject=null;AppState.mediaStream=null;AppState.videoTrack=null;setupCameraControls();
};

const _initCameraWork = async (deviceId) => { /* ... (same logic, use new updateStatus) ... */
    releaseCamera();
    const constraints = { video: { width: { ideal: 1920, max: 2560 }, height: { ideal: 1080, max: 1440 }, frameRate: { ideal: 24, max: 30 }, facingMode: "environment", audio: false } };
    if(deviceId){constraints.video.deviceId={exact:deviceId};delete constraints.video.facingMode;}
    logger.log(`Attempting camera: ${deviceId||'default'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia(constraints),10000,"Cam access timed out. Respond to prompts.");
    const tracks = AppState.mediaStream.getVideoTracks(); if(tracks.length===0)throw new Error("No video tracks in stream."); AppState.videoTrack=tracks[0];
    logger.log(`Track acquired: ${AppState.videoTrack.label}`);
    const vidEl=$('videoPreview'); vidEl.srcObject=AppState.mediaStream;
    await promiseWithTimeout(new Promise((res,rej)=>{const ol=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;res();};const oe=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;rej(new Error("Vid el load error."));};vidEl.onloadedmetadata=ol;vidEl.onerror=oe;}),5000,"Vid metadata load timed out.");
    logger.success(`Camera active: ${AppState.videoTrack.label||'N/A'}`); setupCameraControls();
};

const listCameras = async () => { /* ... (use new updateStatus for errors/prompts) ... */
    if(AppState.isInitializingCamera){logger.log("listCameras skipped: init in progress.");return;}
    AppState.isInitializingCamera=true;updateUI(); // Shows "Initializing camera..." via updateStatus
    try{
        logger.log("Verifying permissions...");
        try{const ps=await promiseWithTimeout(navigator.mediaDevices.getUserMedia({video:true,audio:false}),8000,"Perm check timed out.");ps.getTracks().forEach(t=>t.stop());logger.log("Perm check OK.");}
        catch(pErr){logger.error("Perm check failed.",pErr);let m=`Perm error: ${pErr.name||pErr.message}.`;if(pErr.name==="NotAllowedError"||pErr.name==="PermissionDeniedError")m="Cam access denied.<br>Allow in browser & refresh.";else if(pErr.message.includes("timed out"))m="Perm check timed out.<br>Respond to prompts & refresh.";updateStatus(m,'critical');throw pErr;}
        logger.log("Enumerating devices...");
        const devs=await navigator.mediaDevices.enumerateDevices(); const vidDevs=devs.filter(d=>d.kind==='videoinput');
        const camSel=$('cameraSelect');camSel.innerHTML='';
        if(vidDevs.length===0){logger.error("No video devices.");updateStatus("No cameras found on this device.",'critical');AppState.cameraCapabilities.hasMultipleCameras=false;throw new Error("No video devices.");}
        logger.log(`Found ${vidDevs.length} video devices.`);AppState.cameraCapabilities.hasMultipleCameras=vidDevs.length>1;
        vidDevs.forEach(d=>{const o=document.createElement('option');o.value=d.deviceId;o.text=d.label||`Cam ${camSel.options.length+1}`;camSel.appendChild(o);});
        let selDevId=vidDevs[0].deviceId; try{const lId=localStorage.getItem("TV_LAST_CAM");if(lId&&vidDevs.some(d=>d.deviceId===lId))selDevId=lId;else{const eC=vidDevs.find(d=>d.label.toLowerCase().includes('back')||d.label.toLowerCase().includes('environment'));if(eC)selDevId=eC.deviceId;}}catch(e){logger.error("localStorage err (last cam).",e);}
        camSel.value=selDevId;
        camSel.onchange=()=>{if(AppState.isInitializingCamera)return;try{localStorage.setItem("TV_LAST_CAM",camSel.value);}catch(e){logger.error("localStorage err (save cam).",e);}listCameras();};
        await _initCameraWork(selDevId); // This will call setupCameraControls and then updateUI will clear spinner if successful
    }catch(err){
        logger.error(`listCameras main error: ${err.message}`,err);
        if(!AppState.videoTrack){ // If camera didn't actually start
            let uMsg=`Cam init failed.`;
            if(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")uMsg="Cam access denied.<br>Grant access & refresh.";
            else if(err.name==="NotFoundError"||err.name==="DevicesNotFoundError"||err.message.includes("No video devices"))uMsg="No suitable cam found.";
            else if(err.name==="OverconstrainedError"||err.name==="ConstraintNotSatisfiedError")uMsg="Cam doesn't support settings.";
            else if(err.message.includes("timed out"))uMsg=err.message; // Already a user-friendly message
            else if(err.message)uMsg=`Cam error: ${err.message.substring(0,60)}`;
            updateStatus(uMsg, err.name === "NotAllowedError" || err.name === "PermissionDeniedError" ? 'critical' : 'error'); // Use critical for permission issues
        }
        releaseCamera(); // ensure cleanup
    }finally{AppState.isInitializingCamera=false;updateUI();}
};

const captureImage = () => { /* ... (Implement image downscaling as discussed) ... */
    const video = $('videoPreview');
    if (!video.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) {
        logger.error("Video not ready for capture."); return null;
    }
    const sourceCanvas = document.createElement('canvas');
    sourceCanvas.width = video.videoWidth; sourceCanvas.height = video.videoHeight;
    const ctxS = sourceCanvas.getContext('2d');
    let effDigZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) effDigZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) effDigZoom = AppState.currentZoom;
    const cw = video.videoWidth/effDigZoom, ch = video.videoHeight/effDigZoom, cx = (video.videoWidth-cw)/2, cy = (video.videoHeight-ch)/2;
    ctxS.drawImage(video, cx, cy, cw, ch, 0, 0, sourceCanvas.width, sourceCanvas.height);

    const MAX_DIMENSION = 1024; // Max dimension for OpenAI
    let tW = sourceCanvas.width, tH = sourceCanvas.height;
    if (tW > MAX_DIMENSION || tH > MAX_DIMENSION) {
        if (tW > tH) { tH = Math.round(tH * (MAX_DIMENSION / tW)); tW = MAX_DIMENSION; }
        else { tW = Math.round(tW * (MAX_DIMENSION / tH)); tH = MAX_DIMENSION; }
    }
    const finalCanvas = document.createElement('canvas'); finalCanvas.width = tW; finalCanvas.height = tH;
    const ctxF = finalCanvas.getContext('2d');
    ctxF.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, tW, tH);
    const imageDataUrl = finalCanvas.toDataURL('image/jpeg', 0.85);
    logger.log(`Image captured (orig: ${video.videoWidth}x${video.videoHeight}, sent: ${tW}x${tH}, size: ${Math.round(imageDataUrl.length/1024)}KB).`);
    return imageDataUrl;
};

const solveMathProblem = async (imageDataUrl) => { /* ... (Use toLowerCase() for AI message checks) ... */
    if(!AppState.apiKey)throw new Error("API Key needed."); logger.log("To OpenAI...",{imgKB:Math.round(imageDataUrl.length/1024)});
    const payload={model:"gpt-4o-mini",max_tokens:800,messages:[{role:"user",content:[
        {type:"text",text:"You are a precise math problem solver. Analyze the image. Provide a step-by-step thinking process to solve the math problem. On the VERY LAST line, provide ONLY the final numeric answer, prefixed with 'Final Answer:'. For example: 'Final Answer: 42'. If no clear math problem is found, state 'No clear math problem detected.' If the image is unreadable or too blurry, state 'Image is unreadable.' Do not add any other pleasantries or extra text on the final answer line."},
        {type:"image_url",image_url:{url:imageDataUrl,detail:"high"}}]}]};
    const response=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${AppState.apiKey}`},body:JSON.stringify(payload)});
    if(!response.ok){const d=await response.json().catch(()=>({error:{message:`HTTP ${response.status}`}}));const m=d.error?.message||`HTTP ${response.status}`;
        if(response.status===401)throw new Error("Invalid OpenAI API Key (401).");
        if(response.status===429){logger.error("OpenAI rate limit. Retrying...",d);await new Promise(rs=>setTimeout(rs,7000));if(!AppState.isProcessing)throw new Error("Stopped during retry.");return solveMathProblem(imageDataUrl);}
        throw new Error(`OpenAI API Error: ${m}`);}
    const result=await response.json(); logger.log("OpenAI response.",result.usage);
    const content=result.choices?.[0]?.message?.content?.trim().replace(/\.$/, "") || "No AI content."; // Remove trailing period for better matching
    const lines=content.split('\n'); const lastLine=lines[lines.length-1];
    const answerMatch=lastLine.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/); const numericAnswer=answerMatch?answerMatch[1]:null;
    
    // Robust check for specific AI feedback
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes("no clear math problem detected")) {
        return { fullText: content, numericAnswer: null, statusMessage: "AI: No clear math problem detected." };
    }
    if (lowerContent.includes("image is unreadable")) {
        return { fullText: content, numericAnswer: null, statusMessage: "AI: Image is unreadable." };
    }
    return { fullText: content, numericAnswer, statusMessage: numericAnswer ? `Solved: ${numericAnswer}` : "Could not extract answer from AI response." };
};

const processFrame = async () => { /* ... (Use updated statusMessage from solveMathProblem) ... */
    if(!AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack){if(AppState.isProcessing)logger.log("Process frame skipped.");updateUI();return;}
    updateStatus("Capturing...", 'info', true); const imgData=captureImage();
    if(!imgData){logger.error("Capture failed.");if(AppState.isProcessing)AppState.captureTimeout=setTimeout(processFrame,3500);updateUI();return;}
    try{
        updateStatus("Analyzing with AI...", 'info', true);
        const{fullText,numericAnswer,statusMessage}=await solveMathProblem(imgData);
        logger.log("AI Response (full text in verbose log if enabled)", { fullAIResponse: $('verboseLogCheck').checked ? fullText : statusMessage });
        if(numericAnswer){
            logger.success(`Solution: ${numericAnswer}`); updateStatus(`Answer: ${numericAnswer}`,'success'); // Update status bar too
            showToast(`Answer: ${numericAnswer}`,'success',5000);
            try{speechSynthesis.speak(new SpeechSynthesisUtterance(numericAnswer));}catch(e){logger.error("Speech failed.",e);}
        }else{
            logger.log(statusMessage||"No numeric answer from AI."); updateStatus(statusMessage,'info');
            showToast(statusMessage||"No numeric answer.",'info',4000);
        }
    }catch(err){
        logger.error(`Processing error: ${err.message}`,err);
        const isAPIKeyError = err.message.includes("API Key");
        if(isAPIKeyError){if(AppState.isProcessing)$('stopBtn').click(); updateStatus(`API Key Error. Verify key.`, 'critical');}
        else{updateStatus(`Error: ${err.message.substring(0,60)}...`,'error');}
    }finally{
        if(AppState.isProcessing){
             // Don't immediately overwrite a success/error message from processFrame with "Ready"
            if (!AppState.videoTrack || AppState.isInitializingCamera) { /* no op, other states will cover */ }
            else { updateStatus("Ready for next. Aim.", 'info', false); } // Or clear if preferred
            AppState.captureTimeout=setTimeout(processFrame,3500);
        }else{ updateUI(); /* Ensures status is "Stopped" or similar if processing ended */ }
    }
};

const updateZoomTypeIndicator = () => { /* ... (same) ... */
    const ind=$('zoomType');if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max){ind.textContent='(Digital)';ind.style.color='var(--hi)';}
    else if(AppState.cameraCapabilities.zoom){ind.textContent='(Optical)';ind.style.color='var(--succ)';}else{ind.textContent='';}
};

const toggleLogPanel = () => { AppState.isLogVisible=!AppState.isLogVisible; $('logPanel').classList.toggle('visible',AppState.isLogVisible); updateUI(); };

// --- Event Listeners ---
$('saveKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;const kI=$('apiKey').value.trim();if(kI.startsWith("sk-")){AppState.apiKey=kI;try{localStorage.setItem("TV_API_KEY",kI);}catch(e){logger.error("localStorage (save key).",e);}logger.success("API Key Saved!");if(!AppState.videoTrack)listCameras();updateUI();}else{logger.error("Invalid API Key. Must start with 'sk-'.");}};
$('changeKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;$('apiKeyEntryRow').classList.remove('hidden-control');$('apiKeyDisplayRow').classList.add('hidden-control');$('apiKey').value=AppState.apiKey;$('apiKey').focus();updateUI();};
$('clearKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;logger.log("Clearing API Key.");AppState.apiKey="";try{localStorage.removeItem("TV_API_KEY");}catch(e){logger.error("localStorage (clear key).",e);}$('apiKey').value="";if(AppState.isProcessing)$('stopBtn').click();releaseCamera();logger.success("API Key Cleared.");updateUI();};
$('zoomSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;const z=parseFloat(e.target.value);$('zoomOutput').textContent=z.toFixed(1);AppState.currentZoom=z;updateZoomTypeIndicator();if(AppState.videoTrack&&AppState.cameraCapabilities.zoom&&z<=AppState.cameraCapabilities.zoom.max)AppState.videoTrack.applyConstraints({advanced:[{zoom:z}]}).catch(err=>logger.error(`HW zoom err`,err));};
$('focusSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;if(AppState.videoTrack&&AppState.cameraCapabilities.focus){const f=parseFloat(e.target.value);$('focusOutput').textContent=f.toFixed(2);AppState.videoTrack.applyConstraints({advanced:[{focusMode:'manual',focusDistance:f}]}).catch(err=>logger.error(`Focus err`,err));}};
$('startBtn').onclick=()=>{if(AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack||!AppState.apiKey)return;AppState.isProcessing=true;logger.log("Processing started.");updateStatus("Starting...",'info',true);updateUI();processFrame();};
$('stopBtn').onclick=()=>{if(!AppState.isProcessing)return;AppState.isProcessing=false;clearTimeout(AppState.captureTimeout);logger.log("Processing stopped.");updateStatus("Stopped.",'info');updateUI();};
$('copyLogBtn').onclick=async()=>{const logTxt=$('logTextarea').value;if(!logTxt.trim()){showToast("Log empty.",'info');return;}try{await navigator.clipboard.writeText(logTxt);logger.success("Log copied.");}catch(err){logger.error("Copy failed. Select manually.",err);$('logTextarea').select();$('logTextarea').setSelectionRange(0,999999);showToast("Log selected.",'info');}updateUI();};
$('verboseLogCheck').onchange=()=>{logger.log(`Verbose logging ${$('verboseLogCheck').checked?'on':'off'}.`);try{localStorage.setItem("TV_VERBOSE_LOG",$('verboseLogCheck').checked?'true':'false');}catch(e){logger.error("localStorage (verbose).",e);}};
$('toggleLogBtn').onclick = toggleLogPanel;

document.addEventListener('DOMContentLoaded',()=>{try{AppState.apiKey=localStorage.getItem("TV_API_KEY")||"";}catch(e){logger.error("localStorage (load key).",e);AppState.apiKey="";}try{$('verboseLogCheck').checked=localStorage.getItem("TV_VERBOSE_LOG")==='true';}catch(e){logger.error("localStorage (load verbose).",e);}if(AppState.apiKey){listCameras();}else{updateStatus("Welcome!<br>Please enter OpenAI API Key.",'critical');}updateUI();});
document.addEventListener("visibilitychange",()=>{if(document.visibilityState==='hidden'){if(AppState.isProcessing){$('stopBtn').click();logger.log("App hidden, processing stopped.");}if(AppState.videoTrack)releaseCamera();updateUI();}else if(document.visibilityState==='visible'){if(AppState.apiKey&&!AppState.videoTrack&&!AppState.isInitializingCamera){logger.log("App visible, re-init camera.");listCameras();}}});
window.addEventListener('beforeunload',()=>{releaseCamera();});

</script>
</body>
</html>