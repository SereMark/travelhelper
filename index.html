<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 16px;
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.7rem 1rem; text-align: center; font-weight: 600; font-size: 1.05rem;
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .title { flex-grow: 1; text-align: center; margin-left: 50px; /* Offset for button space */}
header button#toggleLogBtn {
    font-size: 0.85rem; padding: 0.4rem 0.8rem; min-width: 50px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover { background: var(--trk); }


.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; /* For log panel positioning */ }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area { padding: 0.8rem 1rem; display: flex; flex-direction: column; gap: 0.8rem; background: var(--bg); border-bottom: 1px solid var(--trk); flex-shrink: 0; max-height: 35vh; /* Reduced max-height */ overflow-y: auto; -webkit-overflow-scrolling: touch; }
.control-group { display: flex; flex-direction: column; gap: 0.3rem; }
.control-row { display: flex; gap: 0.6rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 80px; padding: 0.7rem 0.5rem; font-size: 0.9rem; }
#apiKeyDisplay { font-size: 0.9rem; color: var(--fg); background: var(--trk); padding: 0.7rem; border-radius: 8px; flex-grow: 1; text-align: center; }

input[type="password"], select, button, textarea {
    padding: 0.75rem; border-radius: 8px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.9rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2.5px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.85rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.1rem; }
output { font-weight: 500; margin-left: 0.3rem; font-feature-settings: "tnum"; }

.range { appearance: none; width: 100%; height: 8px; border-radius: 4px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:26px; height:26px; border-radius:50%; background:var(--hi); border: 3.5px solid var(--bg); box-shadow: 0 1.5px 4px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:26px; height:26px; border-radius:50%; background:var(--hi); border: 3.5px solid var(--bg); box-shadow: 0 1.5px 4px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area { flex: 1; display: flex; justify-content: center; align-items: center; padding: 0.4rem; background: #0a0a0a; overflow: hidden; position: relative; min-height: 150px; }
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 8px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 10px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }
.status-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center; background: rgba(0,0,0,0.65); backdrop-filter: blur(2.5px); color: white; font-size: 1rem; text-align:center; padding:1.2rem; z-index: 10; opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
.status-overlay.visible { opacity:1; visibility: visible; }
.status-overlay p { margin-bottom: 0.7rem; }
.spinner { border: 3.5px solid rgba(255,255,255,0.2); border-top: 3.5px solid var(--hi); border-radius: 50%; width: 32px; height: 32px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.actions-bar { padding: 0.7rem 1rem; display: flex; gap: 0.7rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.8rem; font-size: 1rem; font-weight: 600; }

/* Log Area - Collapsible Panel */
.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: flex; flex-direction: column;
    height: 45vh; /* Adjust as needed */
    max-height: 300px; /* Max height for very tall screens */
    background-color: color-mix(in srgb, var(--bg) 95%, black);
    border-top: 1px solid var(--trk);
    box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
    transform: translateY(100%);
    transition: transform 0.3s ease-in-out;
    z-index: 100; /* Above preview, below toasts */
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.75rem; line-height: 1.35; padding: 0.4rem 0.7rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.4rem 0.7rem; gap: 0.7rem; flex-shrink: 0; }
.log-bar button { padding: 0.4rem 0.7rem; font-size: 0.8rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.9rem; height: 0.9rem; accent-color: var(--hi); }

.toast { /* ... (same as V4_Perfection_Sweep) ... */
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.9rem 1.3rem; border-radius: 25px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.95rem; box-shadow: 0 3px 12px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none;
}
.toast.show { opacity: 1; top: 30px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: 0px; transform: translateX(-50%) scale(0.9); } /* Optional hide animation */
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>

            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>

            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>

            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="statusOverlay" class="status-overlay">
                    <p id="statusText">Initializing...</p>
                    <div id="spinnerIcon" class="spinner" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages will appear here..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy Log</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
};

const logger = { /* ... (same as previous, ensure it writes to logTextarea) ... */
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) =>
                    typeof value === 'bigint' ? value.toString() : value, 2); // Handle BigInt
                logTextarea.value += detailStr + "\n";
            } catch (e) {
                logTextarea.value += "[Details: Unserializable Object]\n";
            }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => {
        console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || '');
        logger._logToTextarea(message, details);
    },
    error: (message, errorObj) => {
        const errorMessage = errorObj instanceof Error ? errorObj.message : String(errorObj);
        const fullMessage = `${message}${errorMessage ? ': ' + errorMessage : ''}`;
        console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMessage}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message } : errorObj); // Avoid logging full stack to textarea by default
        showToast(message.length > 50 ? message.substring(0,47)+'...' : message, 'error', 6000);
    },
    success: (message, details) => {
        console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || '');
        logger._logToTextarea(message, details);
        showToast(message, 'success');
    }
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') { /* ... (same) ... */
    let timer;
    const timeoutPromise = new Promise((_, reject) => {
        timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms);
    });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3500) => { /* ... (same) ... */
    const toastEl = $('toast'); clearTimeout(AppState.toastTimeout); toastEl.textContent = message;
    toastEl.className = 'toast'; if (type === 'error') toastEl.classList.add('error'); else if (type === 'success') toastEl.classList.add('success');
    toastEl.classList.add('show');
    AppState.toastTimeout = setTimeout(() => { toastEl.classList.remove('show'); }, duration);
};

const updateStatusOverlay = (text, showSpinner = false, isError = false) => { /* ... (same) ... */
    const overlayEl = $('statusOverlay'); const textEl = $('statusText'); const spinnerEl = $('spinnerIcon');
    if (text) {
        textEl.innerHTML = text; spinnerEl.style.display = showSpinner ? 'block' : 'none';
        overlayEl.style.color = isError ? 'var(--err)' : 'white'; overlayEl.classList.add('visible');
    } else { overlayEl.classList.remove('visible'); }
};

const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    // API Key section
    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) {
        $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`;
    }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;


    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;

    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;

    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Show Log';


    if (AppState.isInitializingCamera) {
        updateStatusOverlay("Initializing camera...", true);
    } else if (!keyPresent) {
        updateStatusOverlay("Welcome!<br>Please enter OpenAI API Key.");
    } else if (!AppState.videoTrack) {
        updateStatusOverlay("Camera not available.<br>Check permissions or connect camera.", false, true);
    } else if (AppState.isProcessing) {
        // Status handled by processFrame
    } else if (cameraIsActuallyReady) {
        updateStatusOverlay("Ready! Aim at problem.", false);
    }
};

const setupCameraControls = () => { /* ... (same, uses logger) ... */
    if (!AppState.videoTrack) {
        AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;
        // No logger message here as releaseCamera already logs
        updateUI(); return;
    }
    const capabilities = AppState.videoTrack.getCapabilities(); const settings = AppState.videoTrack.getSettings();
    AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;
    if (capabilities.zoom) {
        AppState.cameraCapabilities.zoom = { ...capabilities.zoom };
        $('zoomSlider').min = capabilities.zoom.min || 1; $('zoomSlider').max = capabilities.zoom.max || 10;
        $('zoomSlider').step = capabilities.zoom.step || 0.1;
        const currentVideoZoom = settings.zoom || capabilities.zoom.min || 1;
        $('zoomSlider').value = currentVideoZoom; $('zoomOutput').textContent = parseFloat(currentVideoZoom).toFixed(1);
        AppState.currentZoom = parseFloat(currentVideoZoom); updateZoomTypeIndicator();
    }
    if (capabilities.focusMode?.includes("manual") && capabilities.focusDistance) {
        AppState.cameraCapabilities.focus = { ...capabilities.focusDistance };
        $('focusSlider').min = capabilities.focusDistance.min || 0; $('focusSlider').max = capabilities.focusDistance.max || 1;
        $('focusSlider').step = capabilities.focusDistance.step || 0.01;
        $('focusSlider').value = settings.focusDistance || capabilities.focusDistance.min || 0;
        $('focusOutput').textContent = parseFloat($('focusSlider').value).toFixed(2);
    }
    updateUI();
};

const releaseCamera = () => { /* ... (same, uses logger) ... */
    if (AppState.mediaStream) { AppState.mediaStream.getTracks().forEach(track => track.stop()); logger.log("Camera stream released."); }
    $('videoPreview').srcObject = null; AppState.mediaStream = null; AppState.videoTrack = null;
    setupCameraControls(); // Clears/disables controls reflecting no track
};

const _initCameraWork = async (deviceId) => { /* ... (same, uses logger) ... */
    releaseCamera();
    const constraints = { video: { width: { ideal: 1920, max: 2560 }, height: { ideal: 1080, max: 1440 }, frameRate: { ideal: 24, max: 30 }, facingMode: "environment", audio: false } };
    if (deviceId) { constraints.video.deviceId = { exact: deviceId }; delete constraints.video.facingMode; }
    logger.log(`Attempting camera: ${deviceId || 'default'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout( navigator.mediaDevices.getUserMedia(constraints), 10000, "Camera access timed out. Respond to prompts." );
    const videoTracks = AppState.mediaStream.getVideoTracks();
    if (videoTracks.length === 0) throw new Error("No video tracks in stream.");
    AppState.videoTrack = videoTracks[0]; logger.log(`Track acquired: ${AppState.videoTrack.label}`);
    const videoEl = $('videoPreview'); videoEl.srcObject = AppState.mediaStream;
    await promiseWithTimeout( new Promise((resolve, reject) => {
            const onLoaded = () => { videoEl.onloadedmetadata = null; videoEl.onerror = null; resolve(); };
            const onError = () => { videoEl.onloadedmetadata = null; videoEl.onerror = null; reject(new Error("Video element load error.")); };
            videoEl.onloadedmetadata = onLoaded; videoEl.onerror = onError;
        }), 5000, "Video metadata load timed out." );
    logger.success(`Camera active: ${AppState.videoTrack.label || 'N/A'}`);
    setupCameraControls();
};

const listCameras = async () => { /* ... (same, uses logger) ... */
    if (AppState.isInitializingCamera) { logger.log("listCameras skipped: init in progress."); return; }
    AppState.isInitializingCamera = true; updateUI();
    try {
        logger.log("Verifying permissions...");
        try {
            const ps = await promiseWithTimeout(navigator.mediaDevices.getUserMedia({video:true,audio:false}),8000,"Perm check timed out.");
            ps.getTracks().forEach(t=>t.stop()); logger.log("Perm check OK.");
        } catch (permErr) {
            logger.error("Perm check failed.", permErr);
            let m = `Perm error: ${permErr.name||permErr.message}.`;
            if(permErr.name==="NotAllowedError"||permErr.name==="PermissionDeniedError") m="Cam access denied.<br>Allow in browser & refresh.";
            else if(permErr.message.includes("timed out")) m="Perm check timed out.<br>Respond to prompts & refresh.";
            updateStatusOverlay(m,false,true); throw permErr;
        }
        logger.log("Enumerating devices...");
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        const camSel = $('cameraSelect'); camSel.innerHTML = '';
        if (videoDevices.length === 0) {
            logger.error("No video devices found."); updateStatusOverlay("No cameras found.", false, true);
            AppState.cameraCapabilities.hasMultipleCameras=false; throw new Error("No video devices.");
        }
        logger.log(`Found ${videoDevices.length} video devices.`); AppState.cameraCapabilities.hasMultipleCameras = videoDevices.length > 1;
        videoDevices.forEach(d=>{const o=document.createElement('option');o.value=d.deviceId;o.text=d.label||`Cam ${camSel.options.length+1}`;camSel.appendChild(o);});
        let selDevId = videoDevices[0].deviceId;
        try { const lastId=localStorage.getItem("TV_LAST_CAM"); if(lastId&&videoDevices.some(d=>d.deviceId===lastId))selDevId=lastId; else {const envC=videoDevices.find(d=>d.label.toLowerCase().includes('back')||d.label.toLowerCase().includes('environment')); if(envC)selDevId=envC.deviceId;}}catch(e){logger.error("localStorage err (last cam).",e);}
        camSel.value = selDevId;
        camSel.onchange = () => { if(AppState.isInitializingCamera)return; try{localStorage.setItem("TV_LAST_CAM",camSel.value);}catch(e){logger.error("localStorage err (save cam).",e);} listCameras(); };
        await _initCameraWork(selDevId);
    } catch (err) {
        logger.error(`listCameras main error: ${err.message}`, err);
        if(!AppState.videoTrack){
            let uMsg=`Cam init failed.`;
            if(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")uMsg="Cam access denied.<br>Grant access & refresh.";
            else if(err.name==="NotFoundError"||err.name==="DevicesNotFoundError"||err.message.includes("No video devices"))uMsg="No suitable cam found.";
            else if(err.name==="OverconstrainedError"||err.name==="ConstraintNotSatisfiedError")uMsg="Cam doesn't support settings.";
            else if(err.message.includes("timed out"))uMsg=err.message;
            else if(err.message)uMsg=`Cam error: ${err.message.substring(0,60)}`;
            updateStatusOverlay(uMsg,false,true);
        }
        releaseCamera();
    } finally { AppState.isInitializingCamera = false; updateUI(); }
};

const captureImage = () => { /* ... (same) ... */
    const v=$('videoPreview'); if(!v.videoWidth||!AppState.videoTrack||AppState.isInitializingCamera){logger.error("Vid not ready for capture.");return null;}
    const c=document.createElement('canvas');c.width=v.videoWidth;c.height=v.videoHeight;const x=c.getContext('2d');let z=1;
    if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max)z=AppState.currentZoom/AppState.cameraCapabilities.zoom.max;
    else if(!AppState.cameraCapabilities.zoom&&AppState.currentZoom>1)z=AppState.currentZoom;
    const w=v.videoWidth/z,h=v.videoHeight/z,dx=(v.videoWidth-w)/2,dy=(v.videoHeight-h)/2;
    x.drawImage(v,dx,dy,w,h,0,0,c.width,c.height);return c.toDataURL('image/jpeg',0.9);
};

const solveMathProblem = async (imageDataUrl) => { /* ... (same, uses logger) ... */
    if(!AppState.apiKey)throw new Error("API Key needed."); logger.log("To OpenAI...",{imgSize:imageDataUrl.length});
    const p={model:"gpt-4o-mini",max_tokens:800,messages:[{role:"user",content:[
        {type:"text",text:"Solve math in image. Step-by-step thinking. VERY LAST line: ONLY numeric answer, prefixed 'Final Answer:'. Ex: 'Final Answer: 42'. If no problem or unreadable, state that clearly."},
        {type:"image_url",image_url:{url:imageDataUrl,detail:"high"}}]}]};
    const r=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${AppState.apiKey}`},body:JSON.stringify(p)});
    if(!r.ok){const d=await r.json().catch(()=>({error:{message:`HTTP ${r.status}`}}));const m=d.error?.message||`HTTP ${r.status}`;
        if(r.status===401)throw new Error("Invalid OpenAI API Key (401).");
        if(r.status===429){logger.error("OpenAI rate limit. Retrying...",d);await new Promise(rs=>setTimeout(rs,7000));if(!AppState.isProcessing)throw new Error("Stopped during retry.");return solveMathProblem(imageDataUrl);}
        throw new Error(`OpenAI API Error: ${m}`);}
    const j=await r.json();logger.log("OpenAI response.",j.usage);const content=j.choices?.[0]?.message?.content?.trim()||"No AI content.";
    const lines=content.split('\n');const lastLine=lines[lines.length-1];
    const answerMatch=lastLine.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/);const numAns=answerMatch?answerMatch[1]:null;
    if(content.includes("No clear math problem detected.")||content.includes("Image is unreadable."))return{fullText:content,numericAnswer:null,statusMessage:content};
    return{fullText:content,numericAnswer:numAns,statusMessage:numAns?`Solved: ${numAns}`:"Could not extract answer."};
};

const processFrame = async () => { /* ... (same, uses logger) ... */
    if(!AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack){if(AppState.isProcessing)logger.log("Process frame skipped.");updateUI();return;}
    updateStatusOverlay("Capturing...",true);const imgData=captureImage();
    if(!imgData){logger.error("Capture failed.");if(AppState.isProcessing)AppState.captureTimeout=setTimeout(processFrame,3500);updateUI();return;}
    try{updateStatusOverlay("Analyzing...",true);const{fullText,numericAnswer,statusMessage}=await solveMathProblem(imgData);
        logger.log("AI Response (verbose for details):"+( $('verboseLogCheck').checked ? "\n"+fullText : statusMessage ), {isFullResponse:true} ); // Simpler log
        if(numericAnswer){logger.success(`Solution: ${numericAnswer}`);showToast(`Answer: ${numericAnswer}`, 'success',5000);try{speechSynthesis.speak(new SpeechSynthesisUtterance(numericAnswer));}catch(e){logger.error("Speech failed.",e);}}
        else{logger.log(statusMessage||"No numeric answer from AI.");showToast(statusMessage||"No answer.",'info',4000);}}
    catch(err){logger.error(`Processing error: ${err.message}`,err);
        if(err.message.includes("API Key")){if(AppState.isProcessing)$('stopBtn').click();updateStatusOverlay(`API Key Error.<br>Verify key.`,false,true);}
        else{updateStatusOverlay(`Error: ${err.message.substring(0,100)}...`,false,true);}}
    finally{if(AppState.isProcessing){updateStatusOverlay("Ready. Aim.",false);AppState.captureTimeout=setTimeout(processFrame,3500);}else{updateUI();}}
};

const updateZoomTypeIndicator = () => { /* ... (same) ... */
    const ind=$('zoomType');if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max){ind.textContent='(Digital)';ind.style.color='var(--hi)';}
    else if(AppState.cameraCapabilities.zoom){ind.textContent='(Optical)';ind.style.color='var(--succ)';}else{ind.textContent='';}
};

const toggleLogPanel = () => {
    AppState.isLogVisible = !AppState.isLogVisible;
    $('logPanel').classList.toggle('visible', AppState.isLogVisible);
    updateUI(); // Updates button text
};

// --- Event Listeners ---
$('saveKeyBtn').onclick = () => {
    if (AppState.isInitializingCamera || AppState.isProcessing) return;
    const keyInput = $('apiKey').value.trim();
    if (keyInput.startsWith("sk-")) {
        AppState.apiKey = keyInput;
        try { localStorage.setItem("TV_API_KEY", keyInput); } catch (e) { logger.error("localStorage err (save key).", e); }
        logger.success("API Key Saved!");
        if (!AppState.videoTrack) { listCameras(); } // Attempt to init camera
        updateUI(); // Update to show saved key display
    } else { logger.error("Invalid API Key. Must start with 'sk-'."); }
};

$('changeKeyBtn').onclick = () => {
    if (AppState.isInitializingCamera || AppState.isProcessing) return;
    $('apiKeyEntryRow').classList.remove('hidden-control');
    $('apiKeyDisplayRow').classList.add('hidden-control');
    $('apiKey').value = AppState.apiKey; // Pre-fill with current key
    $('apiKey').focus();
    updateUI();
};

$('clearKeyBtn').onclick = () => {
    if (AppState.isInitializingCamera || AppState.isProcessing) return;
    logger.log("Clearing API Key."); AppState.apiKey = "";
    try { localStorage.removeItem("TV_API_KEY"); } catch (e) { logger.error("localStorage err (clear key).", e); }
    $('apiKey').value = "";
    if (AppState.isProcessing) $('stopBtn').click();
    releaseCamera(); logger.success("API Key Cleared."); updateUI();
};

$('zoomSlider').oninput=(e)=>{/* ... (same) ... */ if(AppState.isInitializingCamera||!AppState.videoTrack)return;const z=parseFloat(e.target.value);$('zoomOutput').textContent=z.toFixed(1);AppState.currentZoom=z;updateZoomTypeIndicator();if(AppState.videoTrack&&AppState.cameraCapabilities.zoom&&z<=AppState.cameraCapabilities.zoom.max)AppState.videoTrack.applyConstraints({advanced:[{zoom:z}]}).catch(err=>logger.error(`HW zoom err`,err));};
$('focusSlider').oninput=(e)=>{/* ... (same) ... */ if(AppState.isInitializingCamera||!AppState.videoTrack)return;if(AppState.videoTrack&&AppState.cameraCapabilities.focus){const f=parseFloat(e.target.value);$('focusOutput').textContent=f.toFixed(2);AppState.videoTrack.applyConstraints({advanced:[{focusMode:'manual',focusDistance:f}]}).catch(err=>logger.error(`Focus err`,err));}};
$('startBtn').onclick=()=>{/* ... (same) ... */ if(AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack||!AppState.apiKey)return;AppState.isProcessing=true;logger.log("Processing started.");showToast("Solver Started",'info');updateUI();processFrame();};
$('stopBtn').onclick=()=>{/* ... (same) ... */ if(!AppState.isProcessing)return;AppState.isProcessing=false;clearTimeout(AppState.captureTimeout);logger.log("Processing stopped.");showToast("Solver Stopped",'info');updateStatusOverlay("Stopped.",false);updateUI();};
$('copyLogBtn').onclick=async()=>{/* ... (same) ... */ const logTxt=$('logTextarea').value;if(!logTxt.trim()){showToast("Log empty.",'info');return;}try{await navigator.clipboard.writeText(logTxt);logger.success("Log copied.");}catch(err){logger.error("Copy failed. Select manually.",err);$('logTextarea').select();$('logTextarea').setSelectionRange(0,999999);showToast("Log selected.",'info');}updateUI();};
$('verboseLogCheck').onchange=()=>{ logger.log(`Verbose logging ${$('verboseLogCheck').checked?'on':'off'}.`); try{localStorage.setItem("TV_VERBOSE_LOG",$('verboseLogCheck').checked?'true':'false');}catch(e){logger.error("localStorage err (verbose).",e);}};
$('toggleLogBtn').onclick = toggleLogPanel;

document.addEventListener('DOMContentLoaded',()=>{/* ... (same) ... */ try{AppState.apiKey=localStorage.getItem("TV_API_KEY")||"";}catch(e){logger.error("localStorage err (load key).",e);AppState.apiKey="";}try{$('verboseLogCheck').checked=localStorage.getItem("TV_VERBOSE_LOG")==='true';}catch(e){logger.error("localStorage err (load verbose).",e);}if(AppState.apiKey){listCameras();}updateUI();});
document.addEventListener("visibilitychange",()=>{/* ... (same) ... */ if(document.visibilityState==='hidden'){if(AppState.isProcessing){$('stopBtn').click();logger.log("App hidden, processing stopped.");}if(AppState.videoTrack)releaseCamera();updateUI();}else if(document.visibilityState==='visible'){if(AppState.apiKey&&!AppState.videoTrack&&!AppState.isInitializingCamera){logger.log("App visible, re-init camera.");listCameras();}}});
window.addEventListener('beforeunload',()=>{releaseCamera();});

</script>
</body>
</html>