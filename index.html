<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 15px; /* Adjusted base for mobile */
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.45; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.5rem 0.7rem; /* Compact header */
    font-weight: 600; font-size: 0.95rem;
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .title { flex-grow: 1; text-align: center; margin-left: 40px; /* Approx width of button */ }
header button#toggleLogBtn {
    font-size: 0.75rem; padding: 0.25rem 0.6rem; min-width: 40px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover:not(:disabled) { background: var(--trk); }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area {
    padding: 0.6rem 0.9rem; display: flex; flex-direction: column; gap: 0.6rem;
    background: var(--bg); border-bottom: 1px solid var(--trk);
    flex-shrink: 0; max-height: 40vh; /* Allow more space if needed, scroll kicks in */
    overflow-y: auto; -webkit-overflow-scrolling: touch;
}
.control-group { display: flex; flex-direction: column; gap: 0.2rem; }
.control-row { display: flex; gap: 0.4rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 70px; padding: 0.55rem 0.35rem; font-size: 0.8rem; }
#apiKeyDisplay { font-size: 0.8rem; color: var(--fg); background: var(--trk); padding: 0.55rem; border-radius: 6px; flex-grow: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

input[type="password"], select, button, textarea {
    padding: 0.65rem; border-radius: 6px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.85rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.78rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.05rem; }
output { font-weight: 500; margin-left: 0.2rem; font-feature-settings: "tnum"; font-size: 0.78rem; }
#zoomType { font-size: 0.7rem; opacity: 0.8; }

.range { appearance: none; width: 100%; height: 6px; border-radius: 3px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:22px; height:22px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area {
    flex-grow: 1; display: flex; justify-content: center; align-items: center;
    padding: 0.2rem; background: #0a0a0a; overflow: hidden; position: relative;
    min-height: 150px;
}
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 6px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 6px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }

.video-spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.25); /* Very subtle overlay for spinner */
    z-index: 5; opacity:0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s; pointer-events: none;
}
.video-spinner-overlay.visible { opacity:1; visibility: visible; }
.spinner { border: 3px solid rgba(255,255,255,0.2); border-top: 3px solid var(--hi); border-radius: 50%; width: 28px; height: 28px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.critical-message-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.7); backdrop-filter: blur(2.5px); color: white;
    font-size: 0.95rem; text-align:center; padding:1.2rem; z-index: 15;
    opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
}
.critical-message-overlay.visible { opacity:1; visibility: visible; }

.status-bar {
    padding: 0.3rem 0.8rem; text-align: center; font-size: 0.8rem;
    background-color: var(--bg); border-top: 1px solid var(--trk); border-bottom: 1px solid var(--trk);
    color: var(--fg); flex-shrink: 0; min-height: 2.2em; /* Ensure space for two lines potentially */
    line-height: 1.3; display: flex; align-items: center; justify-content: center;
}
.status-bar.error { color: var(--err); font-weight: 500; }
.status-bar.success { color: var(--succ); font-weight: 500; }

.actions-bar { padding: 0.5rem 0.8rem; display: flex; gap: 0.5rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.7rem; font-size: 0.9rem; font-weight: 600; }

.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column;
    height: 35vh; max-height: 250px; background-color: color-mix(in srgb, var(--bg) 97%, black);
    border-top: 1px solid var(--hi); box-shadow: 0 -2.5px 10px rgba(0,0,0,0.3);
    transform: translateY(100%); transition: transform 0.3s ease-in-out;
    z-index: 100;
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.65rem; line-height: 1.25; padding: 0.25rem 0.5rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.25rem 0.5rem; gap: 0.5rem; flex-shrink: 0; }
.log-bar button { padding: 0.25rem 0.5rem; font-size: 0.7rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.2rem; font-size: 0.7rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.75rem; height: 0.75rem; accent-color: var(--hi); }

.toast {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.8rem 1.2rem; border-radius: 20px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.9rem; box-shadow: 0 2.5px 10px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none;
}
.toast.show { opacity: 1; top: 25px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: -10px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>
            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>
            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>
            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="videoSpinnerOverlay" class="video-spinner-overlay">
                    <div id="spinnerIcon" class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="criticalMessageOverlay" class="critical-message-overlay">
             <p id="criticalMessageText"></p>
        </div>
    </div>

    <div id="statusBar" class="status-bar">Initializing app...</div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
};

const logger = {
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) =>
                    typeof value === 'bigint' ? value.toString() : value, 2);
                logTextarea.value += detailStr + "\n";
            } catch (e) { logTextarea.value += "[Details: Unserializable Object]\n"; }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => { console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); },
    error: (message, errorObj) => {
        const errMsg = errorObj instanceof Error ? errorObj.message : (errorObj ? String(errorObj) : '');
        const fullMsg = `${message}${errMsg ? (': ' + errMsg) : ''}`; console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMsg}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message } : errorObj);
        showToast(message.length > 40 ? message.substring(0,37)+'...' : message, 'error', 5000);
    },
    success: (message, details) => { console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); showToast(message, 'success');}
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
    let timer;
    const timeoutPromise = new Promise((_, reject) => { timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms); });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3000) => {
    const el = $('toast'); clearTimeout(AppState.toastTimeout); el.textContent = message;
    el.className = 'toast'; if (type === 'error') el.classList.add('error'); else if (type === 'success') el.classList.add('success');
    el.classList.add('show'); AppState.toastTimeout = setTimeout(() => { el.classList.remove('show'); }, duration);
};

const updateStatus = (message, type = 'info', showSpinnerOnVideo = false) => {
    const statusBar = $('statusBar');
    const videoSpinnerOverlay = $('videoSpinnerOverlay');
    const criticalOverlay = $('criticalMessageOverlay');
    const criticalMessageText = $('criticalMessageText');

    // Clear critical overlay unless this call is making it critical
    if (type !== 'critical') {
        criticalOverlay.classList.remove('visible');
    }

    if (message) { // Only update status bar if message is provided
        statusBar.innerHTML = message; // Allow HTML for line breaks
        statusBar.className = 'status-bar'; 
        if (type === 'error') statusBar.classList.add('error');
        else if (type === 'success') statusBar.classList.add('success');
    }

    videoSpinnerOverlay.classList.toggle('visible', showSpinnerOnVideo);
    
    if (type === 'critical') {
        criticalMessageText.innerHTML = message;
        criticalOverlay.classList.add('visible');
        videoSpinnerOverlay.classList.remove('visible'); // Don't show spinner if critical message is up
        if(statusBar) statusBar.innerHTML = ''; // Clear status bar text if critical overlay is shown
    }
};


const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) { $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`; }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;

    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;
    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;
    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Log';

    // Status Update Logic - driven by AppState and specific function calls
    // This function mainly handles button states and conditional visibility of control groups.
    // Specific status messages are now set by the functions that change the app's state.
    if (AppState.isInitializingCamera) {
        // updateStatus is called by listCameras/initCamera
    } else if (!keyPresent) {
        // updateStatus is called by DOMContentLoaded if no key
        // This ensures API key input is visible.
        $('apiKeyEntryRow').classList.remove('hidden-control');
        $('apiKeyDisplayRow').classList.add('hidden-control');
    } else if (!AppState.videoTrack) {
        // Status like "Camera not available" set by listCameras/initCamera if they fail
    } else if (AppState.isProcessing) {
        // "Capturing", "Analyzing" set by processFrame
    } else if (cameraIsActuallyReady) {
        // If no other status is active, and camera is ready, show "Ready!"
        if ($('statusBar').textContent === 'Initializing app...' || $('statusBar').textContent === '' || $('statusBar').textContent.includes("Initializing camera")) {
            updateStatus("Ready! Aim at problem.", 'success', false);
        }
    }
};

const setupCameraControls = () => {
    if (!AppState.videoTrack) { AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null; updateUI(); return; }
    const cap=AppState.videoTrack.getCapabilities(); const set=AppState.videoTrack.getSettings(); AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null;
    if(cap.zoom){AppState.cameraCapabilities.zoom={...cap.zoom};$('zoomSlider').min=cap.zoom.min||1;$('zoomSlider').max=cap.zoom.max||10;$('zoomSlider').step=cap.zoom.step||0.1;const curZ=set.zoom||cap.zoom.min||1;$('zoomSlider').value=curZ;$('zoomOutput').textContent=parseFloat(curZ).toFixed(1);AppState.currentZoom=parseFloat(curZ);updateZoomTypeIndicator();}
    if(cap.focusMode?.includes("manual")&&cap.focusDistance){AppState.cameraCapabilities.focus={...cap.focusDistance};$('focusSlider').min=cap.focusDistance.min||0;$('focusSlider').max=cap.focusDistance.max||1;$('focusSlider').step=cap.focusDistance.step||0.01;$('focusSlider').value=set.focusDistance||cap.focusDistance.min||0;$('focusOutput').textContent=parseFloat($('focusSlider').value).toFixed(2);}
    updateUI();
};

const releaseCamera = () => {
    if(AppState.mediaStream){AppState.mediaStream.getTracks().forEach(t=>t.stop());logger.log("Camera stream released.");}
    $('videoPreview').srcObject=null;AppState.mediaStream=null;AppState.videoTrack=null;setupCameraControls();
};

const _initCameraWork = async (deviceId) => {
    releaseCamera();
    const constraints = { video: { width: { ideal: 1920, max: 2560 }, height: { ideal: 1080, max: 1440 }, frameRate: { ideal: 24, max: 30 }, facingMode: "environment", audio: false } };
    if(deviceId){constraints.video.deviceId={exact:deviceId};delete constraints.video.facingMode;}
    logger.log(`Attempting camera: ${deviceId||'default'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia(constraints),10000,"Camera access request timed out. Please respond to any permission prompts.");
    const tracks = AppState.mediaStream.getVideoTracks(); if(tracks.length===0)throw new Error("No video tracks found in stream."); AppState.videoTrack=tracks[0];
    logger.log(`Video track acquired: ${AppState.videoTrack.label}`);
    const vidEl=$('videoPreview'); vidEl.srcObject=AppState.mediaStream;
    await promiseWithTimeout(new Promise((res,rej)=>{const ol=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;res();};const oe=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;rej(new Error("Video element failed to load stream."));};vidEl.onloadedmetadata=ol;vidEl.onerror=oe;}),5000,"Video stream metadata loading timed out.");
    logger.success(`Camera active: ${AppState.videoTrack.label||'N/A'}`); setupCameraControls(); // This will call updateUI
};

const listCameras = async () => {
    if(AppState.isInitializingCamera){logger.log("listCameras skipped: initialization already in progress.");return;}
    AppState.isInitializingCamera=true; updateStatus("Initializing camera...", 'info', true); // Show spinner on video
    try{
        logger.log("Verifying camera permissions...");
        try{const ps=await promiseWithTimeout(navigator.mediaDevices.getUserMedia({video:true,audio:false}),8000,"Camera permission check timed out.");ps.getTracks().forEach(t=>t.stop());logger.log("Preliminary camera permission check passed.");}
        catch(pErr){
            logger.error("Preliminary camera permission check failed.", pErr);
            let m=`Could not verify camera permissions.`;
            if(pErr.name==="NotAllowedError"||pErr.name==="PermissionDeniedError")m="Camera access denied.<br>Please allow camera access in your browser settings and refresh the page.";
            else if(pErr.message.includes("timed out"))m="Camera permission check timed out.<br>Please respond to any browser prompts, then refresh.";
            else m = `Camera permission error: ${pErr.name || pErr.message}`;
            updateStatus(m,'critical'); throw pErr; // Use critical overlay
        }
        logger.log("Enumerating video devices...");
        const devs=await navigator.mediaDevices.enumerateDevices(); const vidDevs=devs.filter(d=>d.kind==='videoinput');
        const camSel=$('cameraSelect');camSel.innerHTML='';
        if(vidDevs.length===0){logger.error("No video input devices found after enumeration.");updateStatus("No cameras found on this device.",'critical');AppState.cameraCapabilities.hasMultipleCameras=false;throw new Error("No video devices found.");}
        logger.log(`Found ${vidDevs.length} video devices.`);AppState.cameraCapabilities.hasMultipleCameras=vidDevs.length>1;
        vidDevs.forEach(d=>{const o=document.createElement('option');o.value=d.deviceId;o.text=d.label||`Camera ${camSel.options.length+1}`;camSel.appendChild(o);});
        let selDevId=vidDevs[0].deviceId; try{const lId=localStorage.getItem("TV_LAST_CAM");if(lId&&vidDevs.some(d=>d.deviceId===lId))selDevId=lId;else{const eC=vidDevs.find(d=>d.label.toLowerCase().includes('back')||d.label.toLowerCase().includes('environment'));if(eC)selDevId=eC.deviceId;}}catch(e){logger.error("localStorage error (last cam).",e);}
        camSel.value=selDevId;
        camSel.onchange=()=>{if(AppState.isInitializingCamera)return;try{localStorage.setItem("TV_LAST_CAM",camSel.value);}catch(e){logger.error("localStorage error (save cam).",e);}listCameras();};
        await _initCameraWork(selDevId);
    }catch(err){
        logger.error(`listCameras main process error: ${err.message}`,err);
        if(!AppState.videoTrack){ // If camera didn't actually start and error wasn't 'critical' already
             if (!document.querySelector('.critical-message-overlay.visible')) { // Avoid overwriting specific critical messages
                let uMsg=`Failed to initialize camera system.`;
                if(err.name==="NotFoundError"||err.name==="DevicesNotFoundError"||err.message.includes("No video devices"))uMsg="No suitable camera found on device.";
                else if(err.name==="OverconstrainedError"||err.name==="ConstraintNotSatisfiedError")uMsg="Camera does not support requested settings.";
                else if(err.message.includes("timed out"))uMsg=err.message; // Already user-friendly
                else if(err.message && !(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg=`Camera error: ${err.message.substring(0,60)}`; // Don't show generic if it was perm error
                else if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg = "An unknown error occurred with the camera."; // Catch-all if no specific message and not perm error
                
                // Only update status if it's not a permission error already handled by critical overlay
                if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError" || err.message.includes("timed out") && document.querySelector('.critical-message-overlay.visible'))) {
                    updateStatus(uMsg,'error');
                }
            }
        }
        releaseCamera();
    }finally{AppState.isInitializingCamera=false;updateUI();}
};

const captureImage = () => {
    const video = $('videoPreview');
    if (!video.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) { logger.error("Video not ready for capture."); return null; }
    const sourceCanvas = document.createElement('canvas'); sourceCanvas.width = video.videoWidth; sourceCanvas.height = video.videoHeight;
    const ctxS = sourceCanvas.getContext('2d'); let effDigZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) effDigZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) effDigZoom = AppState.currentZoom;
    const cw = video.videoWidth/effDigZoom, ch = video.videoHeight/effDigZoom, cx = (video.videoWidth-cw)/2, cy = (video.videoHeight-ch)/2;
    ctxS.drawImage(video, cx, cy, cw, ch, 0, 0, sourceCanvas.width, sourceCanvas.height);
    const MAX_DIMENSION = 1024; let tW = sourceCanvas.width, tH = sourceCanvas.height;
    if (tW > MAX_DIMENSION || tH > MAX_DIMENSION) { if (tW > tH) { tH = Math.round(tH * (MAX_DIMENSION / tW)); tW = MAX_DIMENSION; } else { tW = Math.round(tW * (MAX_DIMENSION / tH)); tH = MAX_DIMENSION; } }
    const finalCanvas = document.createElement('canvas'); finalCanvas.width = tW; finalCanvas.height = tH;
    const ctxF = finalCanvas.getContext('2d'); ctxF.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, tW, tH);
    const imageDataUrl = finalCanvas.toDataURL('image/jpeg', 0.85);
    logger.log(`Image captured (sent: ${tW}x${tH}, size: ${Math.round(imageDataUrl.length/1024)}KB).`, {originalRes: `${video.videoWidth}x${video.videoHeight}`});
    return imageDataUrl;
};

const solveMathProblem = async (imageDataUrl) => {
    if(!AppState.apiKey)throw new Error("API Key needed."); logger.log("Sending to OpenAI...",{imgKB:Math.round(imageDataUrl.length/1024)});
    const payload={model:"gpt-4o-mini",max_tokens:800,messages:[{role:"user",content:[
        {type:"text",text:"You are a precise math problem solver. Analyze the image. Provide step-by-step thinking to solve the math problem. On the VERY LAST line, provide ONLY the final numeric answer, prefixed with 'Final Answer:'. For example: 'Final Answer: 42'. If no clear math problem is found, state 'No clear math problem detected.' If the image is unreadable or too blurry, state 'Image is unreadable.' Do not add any other pleasantries or extra text on the final answer line."},
        {type:"image_url",image_url:{url:imageDataUrl,detail:"high"}}]}]};
    const response=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${AppState.apiKey}`},body:JSON.stringify(payload)});
    if(!response.ok){const d=await response.json().catch(()=>({error:{message:`HTTP ${response.status}`}}));const m=d.error?.message||`HTTP ${response.status}`;
        if(response.status===401)throw new Error("Invalid OpenAI API Key (401).");
        if(response.status===429){logger.error("OpenAI rate limit. Retrying...",d);await new Promise(rs=>setTimeout(rs,7000));if(!AppState.isProcessing)throw new Error("Stopped during retry.");return solveMathProblem(imageDataUrl);}
        throw new Error(`OpenAI API Error: ${m}`);}
    const result=await response.json(); logger.log("OpenAI response received.",result.usage);
    const content=result.choices?.[0]?.message?.content?.trim().replace(/\.$/, "") || "No AI content.";
    const lines=content.split('\n'); const lastLine=lines[lines.length-1];
    const answerMatch=lastLine.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/); const numericAnswer=answerMatch?answerMatch[1]:null;
    const lowerContent = content.toLowerCase();
    if (lowerContent.includes("no clear math problem detected")) return { fullText: content, numericAnswer: null, statusMessage: "AI: No clear math problem detected." };
    if (lowerContent.includes("image is unreadable")) return { fullText: content, numericAnswer: null, statusMessage: "AI: Image is unreadable." };
    return { fullText: content, numericAnswer, statusMessage: numericAnswer ? `Solved: ${numericAnswer}` : "Could not extract numeric answer from AI response." };
};

const processFrame = async () => {
    if(!AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack){if(AppState.isProcessing)logger.log("Process frame skipped (conditions not met).");updateUI();return;}
    updateStatus("Capturing...", 'info', true); const imgData=captureImage();
    if(!imgData){logger.error("Image capture failed for processing.");if(AppState.isProcessing)AppState.captureTimeout=setTimeout(processFrame,3500);updateStatus("Capture failed.",'error');updateUI();return;}
    try{
        updateStatus("Analyzing with AI...", 'info', true);
        const{fullText,numericAnswer,statusMessage}=await solveMathProblem(imgData);
        logger.log(`AI Response: ${statusMessage}`, { fullAIResponseForVerbose: $('verboseLogCheck').checked ? fullText : "Verbose off" });
        if(numericAnswer){
            logger.success(`Solution: ${numericAnswer}`); updateStatus(`Answer: ${numericAnswer}`,'success');
            showToast(`Answer: ${numericAnswer}`,'success',5000);
            try{speechSynthesis.speak(new SpeechSynthesisUtterance(numericAnswer));}catch(e){logger.error("Speech synthesis failed.",e);}
        }else{
            logger.log(statusMessage||"AI provided no numeric answer."); updateStatus(statusMessage,'info'); // Show specific AI feedback if available
            showToast(statusMessage||"No numeric answer found.",'info',4000);
        }
    }catch(err){
        logger.error(`Processing error: ${err.message}`,err);
        const isAPIKeyError = err.message.includes("API Key");
        if(isAPIKeyError){if(AppState.isProcessing)$('stopBtn').click(); updateStatus(`API Key Error. Please verify your key.`, 'critical');}
        else{updateStatus(`Error: ${err.message.substring(0,60)}...`,'error');}
    }finally{
        if(AppState.isProcessing){
            if (AppState.videoTrack && !AppState.isInitializingCamera) { // Only set to ready if camera is good
                 updateStatus("Ready for next. Aim.", 'info', false);
            } // Otherwise, an error status or init status might already be there
            AppState.captureTimeout=setTimeout(processFrame,3500);
        }else{ updateUI(); }
    }
};

const updateZoomTypeIndicator = () => {
    const ind=$('zoomType');if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max){ind.textContent='(Digital)';ind.style.color='var(--hi)';}
    else if(AppState.cameraCapabilities.zoom){ind.textContent='(Optical)';ind.style.color='var(--succ)';}else{ind.textContent='';}
};
const toggleLogPanel = () => { AppState.isLogVisible=!AppState.isLogVisible; $('logPanel').classList.toggle('visible',AppState.isLogVisible); updateUI(); };

// --- Event Listeners ---
$('saveKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;const kI=$('apiKey').value.trim();if(kI.startsWith("sk-")){AppState.apiKey=kI;try{localStorage.setItem("TV_API_KEY",kI);}catch(e){logger.error("localStorage error (save key).",e);}logger.success("API Key Saved!");if(!AppState.videoTrack){listCameras();}updateUI();}else{logger.error("Invalid API Key format. Must start with 'sk-'.");}};
$('changeKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;$('apiKeyEntryRow').classList.remove('hidden-control');$('apiKeyDisplayRow').classList.add('hidden-control');$('apiKey').value=AppState.apiKey;$('apiKey').focus();updateUI();};
$('clearKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;logger.log("Clearing API Key.");AppState.apiKey="";try{localStorage.removeItem("TV_API_KEY");}catch(e){logger.error("localStorage error (clear key).",e);}$('apiKey').value="";if(AppState.isProcessing)$('stopBtn').click();releaseCamera();logger.success("API Key Cleared.");updateStatus("API Key cleared. Please enter a new key.", 'info');updateUI();};
$('zoomSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;const z=parseFloat(e.target.value);$('zoomOutput').textContent=z.toFixed(1);AppState.currentZoom=z;updateZoomTypeIndicator();if(AppState.videoTrack&&AppState.cameraCapabilities.zoom&&z<=AppState.cameraCapabilities.zoom.max)AppState.videoTrack.applyConstraints({advanced:[{zoom:z}]}).catch(err=>logger.error(`Hardware zoom error`,err));};
$('focusSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;if(AppState.videoTrack&&AppState.cameraCapabilities.focus){const f=parseFloat(e.target.value);$('focusOutput').textContent=f.toFixed(2);AppState.videoTrack.applyConstraints({advanced:[{focusMode:'manual',focusDistance:f}]}).catch(err=>logger.error(`Focus error`,err));}};
$('startBtn').onclick=()=>{if(AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack||!AppState.apiKey)return;AppState.isProcessing=true;logger.log("Processing started by user.");updateStatus("Starting...",'info',true);updateUI();processFrame();};
$('stopBtn').onclick=()=>{if(!AppState.isProcessing)return;AppState.isProcessing=false;clearTimeout(AppState.captureTimeout);logger.log("Processing stopped by user.");updateStatus("Stopped.",'info');updateUI();};
$('copyLogBtn').onclick=async()=>{const logTxt=$('logTextarea').value;if(!logTxt.trim()){showToast("Log is empty.",'info');return;}try{await navigator.clipboard.writeText(logTxt);logger.success("Log copied to clipboard.");}catch(err){logger.error("Failed to copy log. Select manually.",err);$('logTextarea').select();$('logTextarea').setSelectionRange(0,999999);showToast("Log selected for manual copy.",'info');}updateUI();};
$('verboseLogCheck').onchange=()=>{logger.log(`Verbose logging ${$('verboseLogCheck').checked?'enabled':'disabled'}.`);try{localStorage.setItem("TV_VERBOSE_LOG",$('verboseLogCheck').checked?'true':'false');}catch(e){logger.error("localStorage error (verbose).",e);}};
$('toggleLogBtn').onclick = toggleLogPanel;

document.addEventListener('DOMContentLoaded',()=>{
    try{AppState.apiKey=localStorage.getItem("TV_API_KEY")||"";}catch(e){logger.error("localStorage error (load key).",e);AppState.apiKey="";}
    try{$('verboseLogCheck').checked=localStorage.getItem("TV_VERBOSE_LOG")==='true';}catch(e){logger.error("localStorage error (load verbose).",e);}
    if(AppState.apiKey){
        listCameras(); // This will set initializing true and update UI
    } else {
        updateStatus("Welcome!<br>Please enter OpenAI API Key to begin.", 'info'); // Use status bar, not critical overlay
    }
    updateUI(); // Ensure correct initial UI state
});
document.addEventListener("visibilitychange",()=>{
    if(document.visibilityState==='hidden'){
        if(AppState.isProcessing){$('stopBtn').click();logger.log("App hidden, processing stopped.");}
        if(AppState.videoTrack)releaseCamera(); // Only release if active
        updateUI(); // Reflect camera off state
    }else if(document.visibilityState==='visible'){
        // Re-initialize camera if API key is present, camera was active before, and not currently initializing
        if(AppState.apiKey && !AppState.videoTrack && !AppState.isInitializingCamera){
            logger.log("App visible, attempting to re-initialize camera.");listCameras();
        }
    }
});
window.addEventListener('beforeunload',()=>{releaseCamera();});

</script>
</body>
</html>