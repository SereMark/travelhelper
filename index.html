<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e хрониc; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 16px; /* Base font size for easier scaling */
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
header { padding: 0.8rem 1rem; text-align: center; font-weight: 600; font-size: 1.1rem; border-bottom: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 20; }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
.controls-area { padding: 1rem; display: flex; flex-direction: column; gap: 0.9rem; background: var(--bg); border-bottom: 1px solid var(--trk); flex-shrink: 0; max-height: 45vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
.control-group { display: flex; flex-direction: column; gap: 0.4rem; }
.control-row { display: flex; gap: 0.8rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }

input[type="password"], select, button {
    padding: 0.8rem; border-radius: 9px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.95rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 3px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.98); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); }
label { font-size: 0.88rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; }
output { font-weight: 500; margin-left: 0.4rem; font-feature-settings: "tnum"; }

.range { appearance: none; width: 100%; height: 10px; border-radius: 5px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:28px; height:28px; border-radius:50%; background:var(--hi); border: 4px solid var(--bg); box-shadow: 0 2px 5px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:28px; height:28px; border-radius:50%; background:var(--hi); border: 4px solid var(--bg); box-shadow: 0 2px 5px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area { flex: 1; display: flex; justify-content: center; align-items: center; padding: 0.5rem; background: #0a0a0a; overflow: hidden; position: relative; }
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 10px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 15px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }
.status-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center; background: rgba(0,0,0,0.65); backdrop-filter: blur(3px); color: white; font-size: 1.05rem; text-align:center; padding:1.5rem; z-index: 10; opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
.status-overlay.visible { opacity:1; visibility: visible; }
.status-overlay p { margin-bottom: 0.8rem; }
.spinner { border: 4px solid rgba(255,255,255,0.2); border-top: 4px solid var(--hi); border-radius: 50%; width: 36px; height: 36px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.actions-bar { padding: 0.8rem 1rem; display: flex; gap: 0.8rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 20; }
.actions-bar button { flex: 1; padding: 0.9rem; font-size: 1.05rem; font-weight: 600; }

.toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.9rem 1.3rem; border-radius: 25px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.95rem; box-shadow: 0 3px 12px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none; }
.toast.show { opacity: 1; top: 30px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: 0px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>Traveler Vision · Math</header>

<div class="app-container">
    <div class="controls-area">
        <div class="control-group">
            <label for="apiKey">OpenAI API Key:</label>
            <div class="control-row">
                <input id="apiKey" type="password" placeholder="sk-...">
                <button id="saveKeyBtn">Save</button>
            </div>
        </div>

        <div id="cameraControlsGroup" class="control-group hidden-control">
            <label for="cameraSelect">Camera:</label>
            <select id="cameraSelect" disabled></select>
        </div>

        <div id="zoomControlGroup" class="control-group hidden-control">
            <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
            <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
        </div>

        <div id="focusControlGroup" class="control-group hidden-control">
            <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
            <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
        </div>
    </div>

    <div class="preview-area">
        <div class="frame">
            <video id="videoPreview" autoplay muted playsinline></video>
            <div id="statusOverlay" class="status-overlay">
                <p id="statusText">Initializing...</p>
                <div id="spinnerIcon" class="spinner" style="display:none;"></div>
            </div>
        </div>
    </div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
};

const logger = {
    log: (message) => console.log(`[INFO] ${message}`),
    error: (message, errorObj) => {
        console.error(`[ERROR] ${message}`, errorObj || '');
        showToast(message, 'error', 5000);
    },
    success: (message) => {
        console.log(`[SUCCESS] ${message}`);
        showToast(message, 'success');
    }
};

const showToast = (message, type = 'info', duration = 3000) => {
    const toastEl = $('toast');
    clearTimeout(AppState.toastTimeout);
    toastEl.textContent = message;
    toastEl.className = 'toast'; // Reset classes
    if (type === 'error') toastEl.classList.add('error');
    else if (type === 'success') toastEl.classList.add('success');

    toastEl.classList.add('show');
    AppState.toastTimeout = setTimeout(() => {
        toastEl.classList.remove('show');
        toastEl.classList.add('hide'); // For potential hide animation
    }, duration);
};

const updateStatusOverlay = (text, showSpinner = false, isError = false) => {
    const overlayEl = $('statusOverlay');
    const textEl = $('statusText');
    const spinnerEl = $('spinnerIcon');

    if (text) {
        textEl.innerHTML = text; // Use innerHTML for simple formatting like <br>
        spinnerEl.style.display = showSpinner ? 'block' : 'none';
        overlayEl.style.color = isError ? 'var(--err)' : 'white';
        overlayEl.classList.add('visible');
    } else {
        overlayEl.classList.remove('visible');
    }
};

const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKey').disabled = keyPresent || AppState.isProcessing;
    $('saveKeyBtn').textContent = keyPresent ? 'Key Saved' : 'Save';
    $('saveKeyBtn').disabled = keyPresent || AppState.isProcessing;

    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || !cameraReady);
    $('cameraSelect').disabled = !cameraReady || AppState.isProcessing || AppState.isInitializingCamera;

    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || !cameraReady);
    $('zoomSlider').disabled = !cameraReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;

    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || !cameraReady);
    $('focusSlider').disabled = !cameraReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;

    // Overlay logic
    if (AppState.isInitializingCamera) {
        updateStatusOverlay("Initializing camera...", true);
    } else if (!keyPresent) {
        updateStatusOverlay("Welcome!<br>Please enter your OpenAI API Key above.");
    } else if (!cameraReady && keyPresent) {
        updateStatusOverlay("Camera not available or permissions pending.<br>Please ensure camera access is allowed.", false, true);
    } else if (AppState.isProcessing) {
        // updateStatusOverlay is handled by processFrame
    } else if (cameraReady) {
         updateStatusOverlay("Ready! Aim at a math problem.", false);
    }
};

const setupCameraControls = () => {
    if (!AppState.videoTrack) return;
    const capabilities = AppState.videoTrack.getCapabilities();
    const settings = AppState.videoTrack.getSettings();
    AppState.cameraCapabilities.zoom = null; // Reset before check
    AppState.cameraCapabilities.focus = null;

    // Zoom
    if (capabilities.zoom) {
        AppState.cameraCapabilities.zoom = { ...capabilities.zoom };
        $('zoomSlider').min = capabilities.zoom.min || 1;
        $('zoomSlider').max = capabilities.zoom.max || 10;
        $('zoomSlider').step = capabilities.zoom.step || 0.1;
        const currentVideoZoom = settings.zoom || capabilities.zoom.min || 1;
        $('zoomSlider').value = currentVideoZoom;
        $('zoomOutput').textContent = parseFloat(currentVideoZoom).toFixed(1);
        AppState.currentZoom = parseFloat(currentVideoZoom);
        updateZoomTypeIndicator();
    }

    // Focus
    if (capabilities.focusMode?.includes("manual") && capabilities.focusDistance) {
        AppState.cameraCapabilities.focus = { ...capabilities.focusDistance };
        $('focusSlider').min = capabilities.focusDistance.min || 0;
        $('focusSlider').max = capabilities.focusDistance.max || 1;
        $('focusSlider').step = capabilities.focusDistance.step || 0.01;
        $('focusSlider').value = settings.focusDistance || capabilities.focusDistance.min || 0;
        $('focusOutput').textContent = parseFloat($('focusSlider').value).toFixed(2);
    }
    updateUI();
};

const releaseCamera = () => {
    if (AppState.mediaStream) {
        AppState.mediaStream.getTracks().forEach(track => track.stop());
        logger.log("Camera stream released.");
    }
    AppState.mediaStream = null;
    AppState.videoTrack = null;
    // Reset capabilities that depend on a track
    AppState.cameraCapabilities.zoom = null;
    AppState.cameraCapabilities.focus = null;
};

const initCamera = async (deviceId) => {
    if (AppState.isInitializingCamera) {
        logger.log("Camera initialization already in progress.");
        return;
    }
    AppState.isInitializingCamera = true;
    releaseCamera(); // Release previous before initializing new
    updateUI();

    const constraints = {
        video: {
            width: { ideal: 1920, max: 2560 },
            height: { ideal: 1080, max: 1440 },
            frameRate: { ideal: 24, max: 30 },
            facingMode: "environment"
        }
    };
    if (deviceId) {
        constraints.video.deviceId = { exact: deviceId };
        delete constraints.video.facingMode;
    }

    try {
        AppState.mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        const videoTracks = AppState.mediaStream.getVideoTracks();
        if (videoTracks.length === 0) {
            throw new Error("No video tracks found in the stream.");
        }
        AppState.videoTrack = videoTracks[0];
        $('videoPreview').srcObject = AppState.mediaStream;
        await new Promise((resolve, reject) => {
            $('videoPreview').onloadedmetadata = resolve;
            $('videoPreview').onerror = () => reject(new Error("Video element error"));
        });
        logger.success(`Camera active: ${AppState.videoTrack.label || 'N/A'}`);
        setupCameraControls();
    } catch (err) {
        logger.error(`Camera initialization failed: ${err.message}`, err);
        if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
             updateStatusOverlay("Camera permission denied.<br>Please grant access in browser settings and refresh.", false, true);
        } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
            updateStatusOverlay("No camera found or selected camera unavailable.", false, true);
        } else {
            updateStatusOverlay(`Camera error: ${err.name || 'Unknown Error'}.<br>Try a different camera or refresh.`, false, true);
        }
        AppState.videoTrack = null; // Ensure track is null on failure
    } finally {
        AppState.isInitializingCamera = false;
        updateUI();
    }
};

const listCameras = async () => {
    if (AppState.isInitializingCamera) return;
    AppState.isInitializingCamera = true; // Prevent concurrent listing/init
    updateUI();

    try {
        // Check permissions first
        try {
            // A quick check to see if we have permissions, doesn't actually start a stream for long
            const permStream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});
            permStream.getTracks().forEach(track => track.stop());
        } catch (permErr) {
            if (permErr.name === "NotAllowedError" || permErr.name === "PermissionDeniedError") {
                logger.error("Camera permission not granted.", permErr);
                updateStatusOverlay("Camera access denied.<br>Please allow camera access in your browser settings.", false, true);
                AppState.isInitializingCamera = false;
                updateUI();
                return;
            }
            // Other errors might be recoverable or indicate no devices
        }

        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const cameraSelect = $('cameraSelect');
        cameraSelect.innerHTML = ''; // Clear old options

        if (videoDevices.length === 0) {
            logger.error("No video input devices found.");
            updateStatusOverlay("No cameras found on this device.", false, true);
            AppState.cameraCapabilities.hasMultipleCameras = false;
            AppState.isInitializingCamera = false;
            updateUI();
            return;
        }

        AppState.cameraCapabilities.hasMultipleCameras = videoDevices.length > 1;
        videoDevices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${cameraSelect.options.length + 1}`;
            cameraSelect.appendChild(option);
        });

        const lastCamId = localStorage.getItem("TV_LAST_CAM");
        let selectedDeviceId = videoDevices[0].deviceId; // Default to the first

        if (lastCamId && videoDevices.some(d => d.deviceId === lastCamId)) {
            selectedDeviceId = lastCamId;
        } else {
            // Prefer back/environment-facing camera if no valid lastCamId
            const envCam = videoDevices.find(d => d.label.toLowerCase().includes('back') || d.label.toLowerCase().includes('environment'));
            if (envCam) selectedDeviceId = envCam.deviceId;
        }
        cameraSelect.value = selectedDeviceId;

        cameraSelect.onchange = () => {
            localStorage.setItem("TV_LAST_CAM", cameraSelect.value);
            initCamera(cameraSelect.value);
        };
        await initCamera(selectedDeviceId); // This will set isInitializingCamera to false in its finally block

    } catch (err) {
        logger.error(`Error listing cameras: ${err.message}`, err);
        updateStatusOverlay("Could not access camera list.<br>Please check permissions and refresh.", false, true);
        AppState.isInitializingCamera = false;
        updateUI();
    }
};

const captureImage = () => {
    const video = $('videoPreview');
    if (!video.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) {
        logger.error("Video not ready for capture.");
        return null;
    }

    const canvas = document.createElement('canvas');
    // Capture at video's intrinsic resolution for best quality before OpenAI scaling
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');

    let effectiveDigitalZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) {
        effectiveDigitalZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    } else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) {
        effectiveDigitalZoom = AppState.currentZoom;
    }

    const cropWidth = video.videoWidth / effectiveDigitalZoom;
    const cropHeight = video.videoHeight / effectiveDigitalZoom;
    const cropX = (video.videoWidth - cropWidth) / 2;
    const cropY = (video.videoHeight - cropHeight) / 2;

    ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/jpeg', 0.9); // Higher quality for OCR
};

const solveMathProblem = async (imageDataUrl) => {
    if (!AppState.apiKey) throw new Error("API Key not set.");
    const payload = {
        model: "gpt-4o-mini", // Use a capable and cost-effective model
        max_tokens: 800,
        messages: [{
            role: "user",
            content: [
                { type: "text", text: "You are a precise math problem solver. Analyze the image. Provide a step-by-step thinking process to solve the math problem. On the VERY LAST line, provide ONLY the final numeric answer, prefixed with 'Final Answer:'. For example: 'Final Answer: 42'. If no clear math problem is found, state 'No clear math problem detected.' If the image is unreadable or too blurry, state 'Image is unreadable.' Do not add any other pleasantries or extra text on the final answer line." },
                { type: "image_url", image_url: { url: imageDataUrl, detail: "high" } }
            ]
        }]
    };

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${AppState.apiKey}` },
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
        const errData = await response.json().catch(() => ({ error: { message: `HTTP ${response.status}` } }));
        const message = errData.error?.message || `HTTP ${response.status}`;
        if (response.status === 401) throw new Error("Invalid or unauthorized OpenAI API Key (401). Please check your key.");
        if (response.status === 429) {
            logger.error("OpenAI rate limit hit. Retrying in 7 seconds...", errData);
            await new Promise(r => setTimeout(r, 7000)); // Wait longer for 429
            if (!AppState.isProcessing) throw new Error("Processing stopped during retry."); // User might have stopped
            return solveMathProblem(imageDataUrl);
        }
        throw new Error(`OpenAI API Error: ${message}`);
    }
    const result = await response.json();
    const content = result.choices?.[0]?.message?.content?.trim() || "No content received from AI.";
    
    const lines = content.split('\n');
    const lastLine = lines[lines.length - 1];
    const answerMatch = lastLine.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/);
    const numericAnswer = answerMatch ? answerMatch[1] : null;

    if (content.includes("No clear math problem detected.") || content.includes("Image is unreadable.")) {
        return { fullText: content, numericAnswer: null, statusMessage: content };
    }
    
    return { fullText: content, numericAnswer, statusMessage: numericAnswer ? `Solved: ${numericAnswer}` : "Could not extract answer." };
};

const processFrame = async () => {
    if (!AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack) {
        if (AppState.isProcessing) logger.log("Process frame skipped: conditions not met.");
        return;
    }
    updateStatusOverlay("Capturing image...", true);

    const imageDataUrl = captureImage();
    if (!imageDataUrl) {
        logger.error("Failed to capture image for processing.");
        if (AppState.isProcessing) AppState.captureTimeout = setTimeout(processFrame, 3500); // Try again
        return;
    }

    try {
        updateStatusOverlay("Analyzing with AI...", true);
        const { fullText, numericAnswer, statusMessage } = await solveMathProblem(imageDataUrl);
        console.log("AI Full Response:\n", fullText);

        if (numericAnswer) {
            logger.success(`Solution: ${numericAnswer}`);
            showToast(`Answer: ${numericAnswer}`, 'success', 5000);
            try {
                const utterance = new SpeechSynthesisUtterance(numericAnswer);
                speechSynthesis.speak(utterance);
            } catch (speechErr) {
                logger.error("Speech synthesis failed.", speechErr);
            }
        } else {
            logger.log(statusMessage || "AI could not find a numeric answer.");
            showToast(statusMessage || "Could not extract answer.", 'info', 4000);
        }
    } catch (err) {
        logger.error(`Processing error: ${err.message}`, err);
        if (err.message.includes("API Key")) { // Stop processing on critical key error
            $('stopBtn').click(); // Programmatically stop
            updateStatusOverlay(`API Key Error.<br>Please verify your key.`, false, true);
        } else {
            updateStatusOverlay(`Error: ${err.message.substring(0,100)}...`, false, true);
        }
    } finally {
        if (AppState.isProcessing) {
            updateStatusOverlay("Ready. Aim at a math problem.", false); // Reset for next potential capture
            AppState.captureTimeout = setTimeout(processFrame, 3500); // Schedule next auto capture
        } else {
             updateUI(); // Ensure overlay is cleared if stopped
        }
    }
};

const updateZoomTypeIndicator = () => {
    const indicator = $('zoomType');
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) {
        indicator.textContent = '(Digital)';
        indicator.style.color = 'var(--hi)';
    } else if (AppState.cameraCapabilities.zoom) {
        indicator.textContent = '(Optical)';
        indicator.style.color = 'var(--succ)';
    } else {
        indicator.textContent = '';
    }
};


// --- Event Listeners ---
$('saveKeyBtn').onclick = () => {
    const keyInput = $('apiKey').value.trim();
    if (keyInput.startsWith("sk-")) {
        AppState.apiKey = keyInput;
        try {
            localStorage.setItem("TV_API_KEY", keyInput);
        } catch (e) { logger.error("Failed to save API key to localStorage.", e); }
        $('apiKey').value = '••••••••' + keyInput.slice(-4);
        logger.success("API Key Saved!");
        if (!AppState.videoTrack && !AppState.isInitializingCamera) { // If camera isn't up, and not trying
            listCameras();
        } else {
            updateUI(); // Just update UI if camera is already initializing or running
        }
    } else {
        logger.error("Invalid API Key format. It should start with 'sk-'.");
    }
};

$('zoomSlider').oninput = (e) => {
    const zoomValue = parseFloat(e.target.value);
    $('zoomOutput').textContent = zoomValue.toFixed(1);
    AppState.currentZoom = zoomValue;
    updateZoomTypeIndicator();

    if (AppState.videoTrack && AppState.cameraCapabilities.zoom && zoomValue <= AppState.cameraCapabilities.zoom.max) {
        AppState.videoTrack.applyConstraints({ advanced: [{ zoom: zoomValue }] })
            .catch(err => logger.error(`Hardware zoom error: ${err.message}`, err));
    }
    // Digital zoom (cropping) is applied during captureImage if zoomValue > hardware max
};

$('focusSlider').oninput = (e) => {
    if (AppState.videoTrack && AppState.cameraCapabilities.focus) {
        const focusValue = parseFloat(e.target.value);
        $('focusOutput').textContent = focusValue.toFixed(2);
        AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: focusValue }] })
            .catch(err => logger.error(`Manual focus error: ${err.message}`, err));
    }
};

$('startBtn').onclick = () => {
    if (AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack) return;
    AppState.isProcessing = true;
    logger.log("Processing started by user.");
    showToast("Vision Math Solver Started", "info");
    updateUI(); // Reflect new state
    processFrame(); // Initial frame processing
};

$('stopBtn').onclick = () => {
    if (!AppState.isProcessing) return;
    AppState.isProcessing = false;
    clearTimeout(AppState.captureTimeout);
    logger.log("Processing stopped by user.");
    showToast("Solver Stopped", "info");
    updateStatusOverlay("Stopped.", false); // Clear any processing overlay
    updateUI();
};

// --- Initialization & Global Handlers ---
document.addEventListener('DOMContentLoaded', () => {
    try {
        AppState.apiKey = localStorage.getItem("TV_API_KEY") || "";
    } catch (e) { logger.error("Failed to read API key from localStorage.", e); AppState.apiKey = ""; }

    if (AppState.apiKey) {
        $('apiKey').value = '••••••••' + AppState.apiKey.slice(-4);
        listCameras();
    } else {
        updateUI(); // Update UI to show API key prompt
    }
});

document.addEventListener("visibilitychange", () => {
    if (!AppState.videoTrack) return; // No camera, no action needed

    if (document.visibilityState === 'hidden') {
        if (AppState.isProcessing) {
            $('stopBtn').click(); // Stop processing
            logger.log("App hidden, processing stopped.");
        }
        releaseCamera(); // Release camera when app is hidden to save battery
        updateUI();
    } else if (document.visibilityState === 'visible') {
        // Re-initialize camera if API key is present and camera was released
        if (AppState.apiKey && !AppState.isInitializingCamera && !AppState.videoTrack) {
            logger.log("App visible, re-initializing camera.");
            listCameras();
        }
    }
});

window.addEventListener('beforeunload', () => {
    releaseCamera(); // Ensure camera is released when page is closed/reloaded
});

</script>
</body>
</html>