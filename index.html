<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 14px;
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.4; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.4rem 0.6rem; font-weight: 600; font-size: 0.9rem;
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .title { flex-grow: 1; text-align: center; margin-left: 35px; }
header button#toggleLogBtn {
    font-size: 0.7rem; padding: 0.2rem 0.5rem; min-width: 35px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover:not(:disabled) { background: var(--trk); }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area {
    padding: 0.5rem 0.8rem; display: flex; flex-direction: column; gap: 0.5rem;
    background: var(--bg); border-bottom: 1px solid var(--trk);
    flex-shrink: 0; max-height: 40vh;
    overflow-y: auto; -webkit-overflow-scrolling: touch;
}
.control-group { display: flex; flex-direction: column; gap: 0.15rem; }
.control-row { display: flex; gap: 0.4rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 65px; padding: 0.5rem 0.3rem; font-size: 0.75rem; }
#apiKeyDisplay { font-size: 0.75rem; color: var(--fg); background: var(--trk); padding: 0.5rem; border-radius: 5px; flex-grow: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

input[type="password"], select, button, textarea {
    padding: 0.6rem; border-radius: 5px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.8rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.75rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.05rem; }
output { font-weight: 500; margin-left: 0.2rem; font-feature-settings: "tnum"; font-size: 0.75rem; }
#zoomType { font-size: 0.65rem; opacity: 0.8; }

.range { appearance: none; width: 100%; height: 6px; border-radius: 3px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:20px; height:20px; border-radius:50%; background:var(--hi); border: 2.5px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:20px; height:20px; border-radius:50%; background:var(--hi); border: 2.5px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area {
    flex-grow: 1; display: flex; justify-content: center; align-items: center;
    padding: 0.1rem; background: #0a0a0a; overflow: hidden; position: relative;
    min-height: 150px;
}
.frame {
    width: 100%; aspect-ratio: 3 / 4; max-height: 100%; 
    max-width: calc(100vh * 0.75); margin: auto; 
    border-radius: 5px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 6px var(--shadow-color);
}
video { width: 100%; height: 100%; object-fit: cover; display: block; background: #050505; }

.video-spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.25); z-index: 5; opacity:0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s; pointer-events: none;
}
.video-spinner-overlay.visible { opacity:1; visibility: visible; }
.spinner { border: 2.5px solid rgba(255,255,255,0.2); border-top: 2.5px solid var(--hi); border-radius: 50%; width: 26px; height: 26px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.critical-message-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.7); backdrop-filter: blur(2.5px); color: white;
    font-size: 0.9rem; text-align:center; padding:1rem; z-index: 15;
    opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
}
.critical-message-overlay.visible { opacity:1; visibility: visible; }

.status-bar {
    padding: 0.25rem 0.7rem; text-align: center; font-size: 0.75rem;
    background-color: var(--bg); border-top: 1px solid var(--trk); border-bottom: 1px solid var(--trk);
    color: var(--fg); flex-shrink: 0; min-height: 2em;
    line-height: 1.3; display: flex; align-items: center; justify-content: center;
}
.status-bar.error { color: var(--err); font-weight: 500; }
.status-bar.success { color: var(--succ); font-weight: 500; }

.actions-bar { padding: 0.4rem 0.7rem; display: flex; gap: 0.4rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.65rem; font-size: 0.85rem; font-weight: 600; }

.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column;
    height: 35vh; max-height: 220px; background-color: color-mix(in srgb, var(--bg) 97%, black);
    border-top: 1px solid var(--hi); box-shadow: 0 -2.5px 10px rgba(0,0,0,0.3);
    transform: translateY(100%); transition: transform 0.3s ease-in-out;
    z-index: 100;
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.6rem; line-height: 1.2; padding: 0.2rem 0.4rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.2rem 0.4rem; gap: 0.4rem; flex-shrink: 0; }
.log-bar button { padding: 0.2rem 0.4rem; font-size: 0.65rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.2rem; font-size: 0.65rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.7rem; height: 0.7rem; accent-color: var(--hi); }

.toast {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.7rem 1.1rem; border-radius: 18px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.85rem; box-shadow: 0 2.5px 10px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none;
}
.toast.show { opacity: 1; top: 25px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: -10px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>
            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>
            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>
            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="videoSpinnerOverlay" class="video-spinner-overlay">
                    <div id="spinnerIcon" class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="criticalMessageOverlay" class="critical-message-overlay">
             <p id="criticalMessageText"></p>
        </div>
    </div>

    <div id="statusBar" class="status-bar">Initializing app...</div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
    toneStarted: false,
};

let sounds = {
    initSuccess: null,
    startAnalysis: null,
    aiResponse: null,
    error: null,
};

function initializeSounds() {
    if (typeof Tone !== 'undefined') {
        sounds.initSuccess = new Tone.PolySynth(Tone.Synth, {
            polyphony: 3, volume: -12,
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 },
            oscillator: { type: "sine" }
        }).toDestination();
        sounds.startAnalysis = new Tone.AMSynth({
            volume: -15, harmonicity: 1.2, detune: 0,
            oscillator: { type: "fmsine", modulationType: "sine", modulationIndex: 2, harmonicity: 1.01 },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.01, release: 0.1 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.05, decay: 0.01, sustain: 1, release: 0.05 }
        }).toDestination();
        sounds.aiResponse = new Tone.Synth({
            volume: -10, oscillator: { type: "triangle" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }
        }).toDestination();
        sounds.error = new Tone.NoiseSynth({
            volume: -18, noise: { type: 'brown' },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
        }).toDestination();
        console.log("[DEBUG] Tone.js sounds initialized.");
    } else {
        console.error("[DEBUG] Tone.js library not loaded. Audio feedback disabled.");
    }
}
if (typeof Tone !== 'undefined') {
    initializeSounds();
}

async function startTone() {
    if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
        try {
            await Tone.start(); AppState.toneStarted = true;
            logger.log("Audio context started.");
        } catch (e) { logger.error("Error starting audio context.", e); }
    } else if (typeof Tone !== 'undefined' && Tone.context.state === 'running') {
        AppState.toneStarted = true;
    }
}

function playSound(soundName) {
    if (AppState.toneStarted && sounds[soundName]) {
        const now = Tone.now();
        if (soundName === 'initSuccess' && sounds.initSuccess.triggerAttackRelease) {
            sounds.initSuccess.triggerAttackRelease(["C5", "E5", "G5"], "16n", now);
        } else if (soundName === 'startAnalysis' && sounds.startAnalysis.triggerAttackRelease) {
            sounds.startAnalysis.triggerAttackRelease("A4", "16n", now);
            sounds.startAnalysis.triggerAttackRelease("C5", "16n", now + 0.1);
        } else if (soundName === 'aiResponse' && sounds.aiResponse.triggerAttackRelease) {
            sounds.aiResponse.triggerAttackRelease("E5", "16n", now);
        } else if (soundName === 'error' && sounds.error.triggerAttackRelease) {
            sounds.error.triggerAttackRelease("8n", now);
        }
    } else if (!AppState.toneStarted) {
        logger.log(`Sound '${soundName}' skipped: audio context not started.`);
    }
}

const logger = {
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) =>
                    typeof value === 'bigint' ? value.toString() : value, 2);
                logTextarea.value += detailStr + "\n";
            } catch (e) { logTextarea.value += "[Details: Unserializable Object]\n"; }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => { console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); },
    error: (message, errorObj) => {
        const errMsg = errorObj instanceof Error ? errorObj.message : (errorObj ? String(errorObj) : '');
        const fullMsg = `${message}${errMsg ? (': ' + errMsg) : ''}`; console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMsg}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message } : errorObj);
        showToast(message.length > 40 ? message.substring(0,37)+'...' : message, 'error', 5000);
        playSound('error');
    },
    success: (message, details) => { console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); showToast(message, 'success');}
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
    let timer;
    const timeoutPromise = new Promise((_, reject) => { timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms); });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3000) => {
    const el = $('toast'); clearTimeout(AppState.toastTimeout); el.textContent = message;
    el.className = 'toast'; if (type === 'error') el.classList.add('error'); else if (type === 'success') el.classList.add('success');
    el.classList.add('show'); AppState.toastTimeout = setTimeout(() => { el.classList.remove('show'); }, duration);
};

const updateStatus = (message, type = 'info', showSpinnerOnVideo = false) => {
    const statusBar = $('statusBar');
    const videoSpinnerOverlay = $('videoSpinnerOverlay');
    const criticalOverlay = $('criticalMessageOverlay');
    const criticalMessageText = $('criticalMessageText');

    if (type !== 'critical') {
        criticalOverlay.classList.remove('visible');
    }

    if (message !== null) {
        statusBar.innerHTML = message;
        statusBar.className = 'status-bar'; 
        if (type === 'error') statusBar.classList.add('error');
        else if (type === 'success') statusBar.classList.add('success');
    }

    videoSpinnerOverlay.classList.toggle('visible', showSpinnerOnVideo);
    
    if (type === 'critical') {
        criticalMessageText.innerHTML = message;
        criticalOverlay.classList.add('visible');
        videoSpinnerOverlay.classList.remove('visible');
        if(statusBar) statusBar.innerHTML = ''; 
    }
};

const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) { $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`; }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;

    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;
    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;
    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Log';

    if (AppState.isInitializingCamera) {
        // Status is set by listCameras
    } else if (!keyPresent) {
        $('apiKeyEntryRow').classList.remove('hidden-control');
        $('apiKeyDisplayRow').classList.add('hidden-control');
    } else if (!AppState.videoTrack) {
        // Status like "Camera not available" set by listCameras if it fails
    } else if (AppState.isProcessing) {
        // "Capturing", "Analyzing" set by processFrame
    } else if (cameraIsActuallyReady) {
        const currentStatus = $('statusBar').textContent;
        if (currentStatus === 'Initializing app...' || currentStatus === '' || currentStatus.includes("Initializing camera") || currentStatus.includes("Stopped") || currentStatus.includes("API Key cleared") || currentStatus.includes("Welcome!")) {
            updateStatus("Ready! Aim at problem.", 'success', false);
        }
    }
};

const setupCameraControls = () => {
    if (!AppState.videoTrack) { AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null; updateUI(); return; }
    const cap=AppState.videoTrack.getCapabilities(); const set=AppState.videoTrack.getSettings(); AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null;
    if(cap.zoom){AppState.cameraCapabilities.zoom={...cap.zoom};$('zoomSlider').min=cap.zoom.min||1;$('zoomSlider').max=cap.zoom.max||10;$('zoomSlider').step=cap.zoom.step||0.1;const curZ=set.zoom||cap.zoom.min||1;$('zoomSlider').value=curZ;$('zoomOutput').textContent=parseFloat(curZ).toFixed(1);AppState.currentZoom=parseFloat(curZ);updateZoomTypeIndicator();}
    if(cap.focusMode?.includes("manual")&&cap.focusDistance){AppState.cameraCapabilities.focus={...cap.focusDistance};$('focusSlider').min=cap.focusDistance.min||0;$('focusSlider').max=cap.focusDistance.max||1;$('focusSlider').step=cap.focusDistance.step||0.01;$('focusSlider').value=set.focusDistance||cap.focusDistance.min||0;$('focusOutput').textContent=parseFloat($('focusSlider').value).toFixed(2);}
    updateUI();
};

const releaseCamera = () => {
    if(AppState.mediaStream){AppState.mediaStream.getTracks().forEach(t=>t.stop());logger.log("Camera stream released.");}
    $('videoPreview').srcObject=null;AppState.mediaStream=null;AppState.videoTrack=null;setupCameraControls();
};

const _initCameraWork = async (deviceId) => {
    releaseCamera();
    const constraints = { video: { 
        width: { ideal: 1920, max: 2560 }, 
        height: { ideal: 1080, max: 1440 }, 
        frameRate: { ideal: 24, max: 30 }, 
        facingMode: "environment", 
        aspectRatio: {ideal: 3/4},
        audio: false 
    }};
    if(deviceId){constraints.video.deviceId={exact:deviceId};delete constraints.video.facingMode;}
    logger.log(`Attempting camera: ${deviceId||'default'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia(constraints),10000,"Camera access request timed out. Please respond to any permission prompts.");
    const tracks = AppState.mediaStream.getVideoTracks(); if(tracks.length===0)throw new Error("No video tracks found in stream."); AppState.videoTrack=tracks[0];
    logger.log(`Video track acquired: ${AppState.videoTrack.label}. Settings: ${JSON.stringify(AppState.videoTrack.getSettings(), null, 2)}`);
    const vidEl=$('videoPreview'); vidEl.srcObject=AppState.mediaStream;
    await promiseWithTimeout(new Promise((res,rej)=>{const ol=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;res();};const oe=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;rej(new Error("Video element failed to load stream."));};vidEl.onloadedmetadata=ol;vidEl.onerror=oe;}),5000,"Video stream metadata loading timed out.");
    logger.success(`Camera active: ${AppState.videoTrack.label||'N/A'}`);
    playSound('initSuccess');
    setupCameraControls();
};

const listCameras = async () => {
    if(AppState.isInitializingCamera){logger.log("listCameras skipped: initialization already in progress.");return;}
    AppState.isInitializingCamera=true; updateStatus("Initializing camera...", 'info', true);
    try{
        logger.log("Verifying camera permissions...");
        try{const ps=await promiseWithTimeout(navigator.mediaDevices.getUserMedia({video:true,audio:false}),8000,"Camera permission check timed out.");ps.getTracks().forEach(t=>t.stop());logger.log("Preliminary camera permission check passed.");}
        catch(pErr){
            logger.error("Preliminary camera permission check failed.", pErr);
            let m=`Could not verify camera permissions.`;
            if(pErr.name==="NotAllowedError"||pErr.name==="PermissionDeniedError")m="Camera access denied.<br>Please allow camera access in your browser settings and refresh the page.";
            else if(pErr.message.includes("timed out"))m="Camera permission check timed out.<br>Please respond to any browser prompts, then refresh.";
            else m = `Camera permission error: ${pErr.name || pErr.message}`;
            updateStatus(m,'critical'); throw pErr;
        }
        logger.log("Enumerating video devices...");
        const devs=await navigator.mediaDevices.enumerateDevices(); const vidDevs=devs.filter(d=>d.kind==='videoinput');
        const camSel=$('cameraSelect');camSel.innerHTML='';
        if(vidDevs.length===0){logger.error("No video input devices found after enumeration.");updateStatus("No cameras found on this device.",'critical');AppState.cameraCapabilities.hasMultipleCameras=false;throw new Error("No video devices found.");}
        logger.log(`Found ${vidDevs.length} video devices.`);AppState.cameraCapabilities.hasMultipleCameras=vidDevs.length>1;
        vidDevs.forEach(d=>{const o=document.createElement('option');o.value=d.deviceId;o.text=d.label||`Camera ${camSel.options.length+1}`;camSel.appendChild(o);});
        let selDevId=vidDevs[0].deviceId; try{const lId=localStorage.getItem("TV_LAST_CAM");if(lId&&vidDevs.some(d=>d.deviceId===lId))selDevId=lId;else{const eC=vidDevs.find(d=>d.label.toLowerCase().includes('back')||d.label.toLowerCase().includes('environment'));if(eC)selDevId=eC.deviceId;}}catch(e){logger.error("localStorage error (last cam).",e);}
        camSel.value=selDevId;
        camSel.onchange=()=>{if(AppState.isInitializingCamera)return;try{localStorage.setItem("TV_LAST_CAM",camSel.value);}catch(e){logger.error("localStorage error (save cam).",e);}listCameras();};
        await _initCameraWork(selDevId);
    }catch(err){
        logger.error(`listCameras main process error: ${err.message}`,err);
        if(!AppState.videoTrack && !document.querySelector('.critical-message-overlay.visible')){
            let uMsg=`Failed to initialize camera system.`;
            if(err.name==="NotFoundError"||err.name==="DevicesNotFoundError"||err.message.includes("No video devices"))uMsg="No suitable camera found on device.";
            else if(err.name==="OverconstrainedError"||err.name==="ConstraintNotSatisfiedError")uMsg="Camera does not support requested settings (e.g. 3:4 aspect ratio). Try another camera.";
            else if(err.message.includes("timed out"))uMsg=err.message;
            else if(err.message && !(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg=`Camera error: ${err.message.substring(0,60)}`;
            else if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg = "An unknown error occurred with the camera.";
            if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError" || (err.message.includes("timed out") && document.querySelector('.critical-message-overlay.visible')))) {
                updateStatus(uMsg,'error');
            }
        }
        releaseCamera();
    }finally{AppState.isInitializingCamera=false;updateUI();}
};

const captureImage = () => {
    const videoEl = $('videoPreview');
    if (!videoEl.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) {
        logger.error("Video not ready for capture."); return null;
    }
    const videoIntrinsicWidth = videoEl.videoWidth; const videoIntrinsicHeight = videoEl.videoHeight;
    const videoIntrinsicAR = videoIntrinsicWidth / videoIntrinsicHeight;
    const targetFrameAR = 3 / 4; 
    let sx = 0, sy = 0, sWidth = 0, sHeight = 0;
    if (videoIntrinsicAR > targetFrameAR) {
        sHeight = videoIntrinsicHeight; sWidth = videoIntrinsicHeight * targetFrameAR; 
        sx = (videoIntrinsicWidth - sWidth) / 2; sy = 0;
    } else {
        sWidth = videoIntrinsicWidth; sHeight = videoIntrinsicWidth / targetFrameAR; 
        sx = 0; sy = (videoIntrinsicHeight - sHeight) / 2;
    }
    sWidth = Math.max(1, Math.floor(sWidth)); sHeight = Math.max(1, Math.floor(sHeight));
    sx = Math.max(0, Math.floor(sx)); sy = Math.max(0, Math.floor(sy));
    if (sx + sWidth > videoIntrinsicWidth) sWidth = videoIntrinsicWidth - sx;
    if (sy + sHeight > videoIntrinsicHeight) sHeight = videoIntrinsicHeight - sy;
    if (sWidth <= 0 || sHeight <= 0) { logger.error("Calculated source dimensions for capture are invalid.", {sWidth, sHeight}); return null; }
    const sourceCropCanvas = document.createElement('canvas'); sourceCropCanvas.width = sWidth; sourceCropCanvas.height = sHeight;
    const ctxS = sourceCropCanvas.getContext('2d'); ctxS.drawImage(videoEl, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
    let effDigZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) effDigZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) effDigZoom = AppState.currentZoom;
    const zoomedWidth = Math.floor(sWidth / effDigZoom); const zoomedHeight = Math.floor(sHeight / effDigZoom);
    const zoomedSx = Math.floor((sWidth - zoomedWidth) / 2); const zoomedSy = Math.floor((sHeight - zoomedHeight) / 2);
    if (zoomedWidth <= 0 || zoomedHeight <= 0) { logger.error("Calculated digital zoom dimensions are invalid.", {zoomedWidth, zoomedHeight}); return null; }
    const digitallyZoomedCanvas = document.createElement('canvas'); digitallyZoomedCanvas.width = zoomedWidth; digitallyZoomedCanvas.height = zoomedHeight;
    const ctxDZ = digitallyZoomedCanvas.getContext('2d'); ctxDZ.drawImage(sourceCropCanvas, zoomedSx, zoomedSy, zoomedWidth, zoomedHeight, 0, 0, zoomedWidth, zoomedHeight);
    const MAX_DIMENSION = 1024; let tW = digitallyZoomedCanvas.width, tH = digitallyZoomedCanvas.height;
    if (tW <= 0 || tH <= 0) { logger.error("Dimensions before downscaling are invalid.", {tW, tH}); return null; }
    if (tW > MAX_DIMENSION || tH > MAX_DIMENSION) { const currentAR = tW / tH; if (tW > tH) { tW = MAX_DIMENSION; tH = Math.round(tW / currentAR); } else { tH = MAX_DIMENSION; tW = Math.round(tH * currentAR); } }
    tW = Math.max(1, tW); tH = Math.max(1, tH);
    const finalCanvas = document.createElement('canvas'); finalCanvas.width = tW; finalCanvas.height = tH;
    const ctxF = finalCanvas.getContext('2d'); ctxF.drawImage(digitallyZoomedCanvas, 0, 0, digitallyZoomedCanvas.width, digitallyZoomedCanvas.height, 0, 0, tW, tH);
    const imageDataUrl = finalCanvas.toDataURL('image/jpeg', 0.85);
    logger.log(`Image captured (sent: ${tW}x${tH}, size: ${Math.round(imageDataUrl.length/1024)}KB).`,
               {originalStream: `${videoIntrinsicWidth}x${videoIntrinsicHeight}`, targetCropAR: targetFrameAR.toFixed(2), calculatedCrop: `${sWidth}x${sHeight}`, digitalZoomFactor: effDigZoom.toFixed(2)});
    return imageDataUrl;
};

const solveMathProblem = async (imageDataUrl) => {
  if (!AppState.apiKey) throw new Error("API Key is missing.");

  logger.log("Sending image to OpenAI (o4-mini, medium effort)…", {
    imageSizeKB: Math.round(imageDataUrl.length / 1024)
  });

  const rlQuizPrompt = `You are an AI expert in Reinforcement Learning.
Read the MCQ in the image and reply ONLY with the letter/number
of the correct option (comma-separated if multiple).
If unreadable or no MCQ, reply exactly: UNREADABLE_OR_NO_MCQ`;

  const payload = {
    model: "o4-mini",
    reasoning_effort: "medium",
    max_completion_tokens: 600,
    messages: [
      {
        role: "user",
        content: [
          { type: "text", text: rlQuizPrompt },
          { type: "image_url",
            image_url: { url: imageDataUrl, detail: "auto" } }
        ]
      }
    ]
  };

  const res = await fetch(
    "https://api.openai.com/v1/chat/completions",
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${AppState.apiKey}`
      },
      body: JSON.stringify(payload)
    }
  );

  if (!res.ok) {
    const err = await res.json().catch(() => ({
      error: { message: `HTTP ${res.status}` }
    }));
    throw new Error(`OpenAI API Error: ${err.error?.message || res.status}`);
  }

  const data = await res.json();
  logger.log("OpenAI usage:", data.usage);

  const answer = (data.choices?.[0]?.message?.content || "").trim();

  if (answer === "UNREADABLE_OR_NO_MCQ") {
    return { extractedAnswer: null, statusMessage: answer };
  }
  if (/^[A-Za-z0-9](,\s*[A-Za-z0-9])*$/.test(answer)) {
    return {
      extractedAnswer: answer.toUpperCase(),
      statusMessage: `AI Answer: ${answer.toUpperCase()}`
    };
  }
  return {
    extractedAnswer: null,
    statusMessage: "AI response format unexpected (see log)."
  };
};

const processFrame = async () => {
    if(!AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack){if(AppState.isProcessing)logger.log("Process frame skipped (conditions not met).");updateUI();return;}
    updateStatus("Capturing...", 'info', true); const imgData=captureImage();
    if(!imgData){logger.error("Image capture failed for processing.");if(AppState.isProcessing)AppState.captureTimeout=setTimeout(processFrame,10000);updateStatus("Capture failed.",'error');updateUI();return;}
    try{
        playSound('aiResponse'); 
        updateStatus("Analyzing RL Quiz (gpt-o4-mini)...", 'info', true);
        const{extractedAnswer, statusMessage}=await solveMathProblem(imgData);
        logger.log(`AI Status: ${statusMessage}`, { extractedOption: extractedAnswer });
        if(extractedAnswer){
            logger.success(`Extracted Option(s): ${extractedAnswer}`); 
            updateStatus(`Answer: ${extractedAnswer}`,'success');
            showToast(`Answer: ${extractedAnswer}`,'success',5000);
            try { 
                speechSynthesis.cancel(); 
                const mainSpokenText = `Answer is ${extractedAnswer.split('').join(', ')}`;
                const speakRepeatedly = (text, times, interval) => {
                    let count = 0;
                    function speak() {
                        if (!AppState.isProcessing || count >= times) return;
                        const utterance = new SpeechSynthesisUtterance(count === 0 ? text : `Again, ${text.replace("Answer is ","")}`);
                        speechSynthesis.speak(utterance);
                        count++;
                        if (count < times) {
                            utterance.onend = () => { if(AppState.isProcessing) setTimeout(speak, interval); };
                        }
                    }
                    speak();
                };
                speakRepeatedly(mainSpokenText, 3, 1500);
            } catch(e) { logger.error("Speech synthesis failed.", e); }
        } else { 
            logger.log(statusMessage||"AI provided no clear option."); 
            updateStatus(statusMessage.length > 60 ? statusMessage.substring(0, 57) + "..." : statusMessage,'info');
            showToast(statusMessage.length > 40 ? statusMessage.substring(0, 37) + "..." : statusMessage,'info',4000);
        }
    }catch(err){
        logger.error(`Processing error: ${err.message}`,err);
        const isAPIKeyError = err.message.includes("API Key");
        if(isAPIKeyError){if(AppState.isProcessing)$('stopBtn').click(); updateStatus(`API Key Error. Please verify your key.`, 'critical');}
        else{updateStatus(`Error: ${err.message.substring(0,60)}...`,'error');}
    }finally{
        if(AppState.isProcessing){
            if (AppState.videoTrack && !AppState.isInitializingCamera) { updateStatus("Ready for next. Aim.", 'info', false); }
            AppState.captureTimeout=setTimeout(processFrame,10000);
        }else{ updateUI(); }
    }
};

const updateZoomTypeIndicator = () => {
    const ind=$('zoomType');if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max){ind.textContent='(Digital)';ind.style.color='var(--hi)';}
    else if(AppState.cameraCapabilities.zoom){ind.textContent='(Optical)';ind.style.color='var(--succ)';}else{ind.textContent='';}
};
const toggleLogPanel = () => { AppState.isLogVisible=!AppState.isLogVisible; $('logPanel').classList.toggle('visible',AppState.isLogVisible); updateUI(); };

async function handleUserInteractionForAudio() { if (!AppState.toneStarted) { await startTone(); } }

$('saveKeyBtn').onclick= async ()=>{ await handleUserInteractionForAudio(); if(AppState.isInitializingCamera||AppState.isProcessing)return;const kI=$('apiKey').value.trim();if(kI.startsWith("sk-")){AppState.apiKey=kI;try{localStorage.setItem("TV_API_KEY",kI);}catch(e){logger.error("localStorage error (save key).",e);}logger.success("API Key Saved!");if(!AppState.videoTrack && !AppState.isInitializingCamera){listCameras();}updateUI();}else{logger.error("Invalid API Key format. Must start with 'sk-'.");}};
$('changeKeyBtn').onclick=async ()=>{ await handleUserInteractionForAudio(); if(AppState.isInitializingCamera||AppState.isProcessing)return;$('apiKeyEntryRow').classList.remove('hidden-control');$('apiKeyDisplayRow').classList.add('hidden-control');$('apiKey').value=AppState.apiKey;$('apiKey').focus();updateUI();};
$('clearKeyBtn').onclick=async ()=>{ await handleUserInteractionForAudio(); if(AppState.isInitializingCamera||AppState.isProcessing)return;logger.log("Clearing API Key.");AppState.apiKey="";try{localStorage.removeItem("TV_API_KEY");}catch(e){logger.error("localStorage error (clear key).",e);}$('apiKey').value="";if(AppState.isProcessing)$('stopBtn').click();releaseCamera();logger.success("API Key Cleared.");updateStatus("API Key cleared. Enter new key.", 'info');updateUI();};
$('zoomSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;const z=parseFloat(e.target.value);$('zoomOutput').textContent=z.toFixed(1);AppState.currentZoom=z;updateZoomTypeIndicator();if(AppState.videoTrack&&AppState.cameraCapabilities.zoom&&z<=AppState.cameraCapabilities.zoom.max)AppState.videoTrack.applyConstraints({advanced:[{zoom:z}]}).catch(err=>logger.error(`Hardware zoom error`,err));};
$('focusSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;if(AppState.videoTrack&&AppState.cameraCapabilities.focus){const f=parseFloat(e.target.value);$('focusOutput').textContent=f.toFixed(2);AppState.videoTrack.applyConstraints({advanced:[{focusMode:'manual',focusDistance:f}]}).catch(err=>logger.error(`Focus error`,err));}};
$('startBtn').onclick=async ()=>{ await handleUserInteractionForAudio(); if(AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack||!AppState.apiKey)return;AppState.isProcessing=true;logger.log("Processing started by user.");playSound('startAnalysis');updateStatus("Starting...",'info',true);updateUI();processFrame();};
$('stopBtn').onclick=async ()=>{ await handleUserInteractionForAudio(); if(!AppState.isProcessing)return;AppState.isProcessing=false;clearTimeout(AppState.captureTimeout);speechSynthesis.cancel();logger.log("Processing stopped by user.");updateStatus("Stopped.",'info');updateUI();};
$('copyLogBtn').onclick=async()=>{ await handleUserInteractionForAudio(); const logTxt=$('logTextarea').value;if(!logTxt.trim()){showToast("Log is empty.",'info');return;}try{await navigator.clipboard.writeText(logTxt);logger.success("Log copied to clipboard.");}catch(err){logger.error("Failed to copy log. Select manually.",err);$('logTextarea').select();$('logTextarea').setSelectionRange(0,999999);showToast("Log selected for manual copy.",'info');}updateUI();};
$('verboseLogCheck').onchange=()=>{logger.log(`Verbose logging ${$('verboseLogCheck').checked?'enabled':'disabled'}.`);try{localStorage.setItem("TV_VERBOSE_LOG",$('verboseLogCheck').checked?'true':'false');}catch(e){logger.error("localStorage error (verbose).",e);}};
$('toggleLogBtn').onclick = async () => { await handleUserInteractionForAudio(); toggleLogPanel(); };

document.addEventListener('DOMContentLoaded',()=>{
    updateStatus("Initializing app...", 'info');
    try{AppState.apiKey=localStorage.getItem("TV_API_KEY")||"";}catch(e){logger.error("localStorage error (load key).",e);AppState.apiKey="";}
    try{$('verboseLogCheck').checked=localStorage.getItem("TV_VERBOSE_LOG")==='true';}catch(e){logger.error("localStorage error (load verbose).",e);}
    if(AppState.apiKey){ listCameras(); } 
    else { updateStatus("Welcome!<br>Please enter OpenAI API Key to begin.", 'info'); }
    updateUI();
});
document.addEventListener("visibilitychange",()=>{
    if(document.visibilityState==='hidden'){
        if(AppState.isProcessing){$('stopBtn').click();}
        if(AppState.videoTrack)releaseCamera(); updateUI();
    }else if(document.visibilityState==='visible'){
        if(AppState.apiKey && !AppState.videoTrack && !AppState.isInitializingCamera){
            logger.log("App visible, re-initializing camera.");listCameras();
        }
    }
});
window.addEventListener('beforeunload',()=>{releaseCamera();speechSynthesis.cancel();});

</script>
</body>
</html>