<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 16px;
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
header { padding: 0.8rem 1rem; text-align: center; font-weight: 600; font-size: 1.1rem; border-bottom: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 20; }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area { padding: 1rem; display: flex; flex-direction: column; gap: 0.9rem; background: var(--bg); border-bottom: 1px solid var(--trk); flex-shrink: 0; max-height: 40vh; /* Adjusted max-height */ overflow-y: auto; -webkit-overflow-scrolling: touch; }
.control-group { display: flex; flex-direction: column; gap: 0.4rem; }
.control-row { display: flex; gap: 0.8rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 90px; /* Ensure buttons have enough width */ }


input[type="password"], select, button, textarea {
    padding: 0.8rem; border-radius: 9px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.95rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 3px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.98); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); } /* Reset transform for disabled */
label { font-size: 0.88rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; }
output { font-weight: 500; margin-left: 0.4rem; font-feature-settings: "tnum"; }

.range { appearance: none; width: 100%; height: 10px; border-radius: 5px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:28px; height:28px; border-radius:50%; background:var(--hi); border: 4px solid var(--bg); box-shadow: 0 2px 5px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:28px; height:28px; border-radius:50%; background:var(--hi); border: 4px solid var(--bg); box-shadow: 0 2px 5px var(--shadow-color); cursor:grab; transition: transform 0.1s; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area { flex: 1; display: flex; justify-content: center; align-items: center; padding: 0.5rem; background: #0a0a0a; overflow: hidden; position: relative; min-height: 200px; /* Ensure it has some visible height */ }
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 10px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 15px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }
.status-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center; background: rgba(0,0,0,0.65); backdrop-filter: blur(3px); color: white; font-size: 1.05rem; text-align:center; padding:1.5rem; z-index: 10; opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
.status-overlay.visible { opacity:1; visibility: visible; }
.status-overlay p { margin-bottom: 0.8rem; }
.spinner { border: 4px solid rgba(255,255,255,0.2); border-top: 4px solid var(--hi); border-radius: 50%; width: 36px; height: 36px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.actions-bar { padding: 0.8rem 1rem; display: flex; gap: 0.8rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.9rem; font-size: 1.05rem; font-weight: 600; }

/* Log Area */
.log-area-container { display: flex; flex-direction: column; height: 200px; /* Default height, can be adjusted */ flex-shrink: 0; border-top: 1px solid var(--trk); background-color: var(--bg); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.4; padding: 0.5rem 0.8rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); } /* Simpler focus for textarea */
.log-bar { display: flex; align-items: center; padding: 0.5rem 0.8rem; gap: 0.8rem; flex-shrink: 0; }
.log-bar button { padding: 0.5rem 0.8rem; font-size: 0.85rem; flex-grow: 0; /* Don't let copy button grow too much */ }
.log-bar label { display: flex; align-items: center; gap: 0.4rem; font-size: 0.85rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 1rem; height: 1rem; accent-color: var(--hi); }


.toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.9rem 1.3rem; border-radius: 25px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.95rem; box-shadow: 0 3px 12px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none; }
.toast.show { opacity: 1; top: 30px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: 0px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>Traveler Vision · Math</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                    <button id="clearKeyBtn" class="hidden-control">Clear</button>
                </div>
            </div>

            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>

            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>

            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="statusOverlay" class="status-overlay">
                    <p id="statusText">Initializing...</p>
                    <div id="spinnerIcon" class="spinner" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>


    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="log-area-container">
        <textarea id="logTextarea" readonly placeholder="Log messages will appear here..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy Log</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose Logging
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
};

const logger = {
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString();
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                logTextarea.value += JSON.stringify(details, null, 2) + "\n";
            } catch (e) {
                logTextarea.value += "[Details: Unserializable Object]\n";
            }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
    },
    log: (message, details) => {
        console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || '');
        logger._logToTextarea(message, details);
    },
    error: (message, errorObj) => {
        const errorMessage = errorObj instanceof Error ? errorObj.message : String(errorObj);
        const fullMessage = `${message}${errorMessage ? ': ' + errorMessage : ''}`;
        console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMessage}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message, stack: errorObj.stack } : errorObj);
        showToast(message.length > 50 ? message.substring(0,47)+'...' : message, 'error', 6000);
    },
    success: (message, details) => {
        console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || '');
        logger._logToTextarea(message, details);
        showToast(message, 'success');
    }
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
    let timer;
    const timeoutPromise = new Promise((_, reject) => {
        timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms);
    });
    return Promise.race([
        promise,
        timeoutPromise
    ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3500) => {
    const toastEl = $('toast');
    clearTimeout(AppState.toastTimeout);
    toastEl.textContent = message;
    toastEl.className = 'toast';
    if (type === 'error') toastEl.classList.add('error');
    else if (type === 'success') toastEl.classList.add('success');
    toastEl.classList.add('show');
    AppState.toastTimeout = setTimeout(() => {
        toastEl.classList.remove('show');
    }, duration);
};

const updateStatusOverlay = (text, showSpinner = false, isError = false) => {
    const overlayEl = $('statusOverlay');
    const textEl = $('statusText');
    const spinnerEl = $('spinnerIcon');
    if (text) {
        textEl.innerHTML = text;
        spinnerEl.style.display = showSpinner ? 'block' : 'none';
        overlayEl.style.color = isError ? 'var(--err)' : 'white';
        overlayEl.classList.add('visible');
    } else {
        overlayEl.classList.remove('visible');
    }
};

const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKey').disabled = keyPresent || AppState.isProcessing || AppState.isInitializingCamera;
    $('saveKeyBtn').textContent = keyPresent ? 'Key Saved' : 'Save';
    $('saveKeyBtn').disabled = keyPresent || AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').classList.toggle('hidden-control', !keyPresent || AppState.isProcessing || AppState.isInitializingCamera);


    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;

    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;

    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");


    if (AppState.isInitializingCamera) {
        updateStatusOverlay("Initializing camera...", true);
    } else if (!keyPresent) {
        updateStatusOverlay("Welcome!<br>Please enter your OpenAI API Key.");
    } else if (!AppState.videoTrack) {
        updateStatusOverlay("Camera not available.<br>Check permissions or connect a camera, then refresh or re-save key.", false, true);
    } else if (AppState.isProcessing) {
        // Processing status handled by processFrame
    } else if (cameraIsActuallyReady) {
        updateStatusOverlay("Ready! Aim at a math problem.", false);
    }
};

const setupCameraControls = () => { /* ... (same as V4, just ensure logger is used) ... */
    if (!AppState.videoTrack) {
        logger.log("setupCameraControls skipped: no video track.");
        AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;
        updateUI(); return;
    }
    const capabilities = AppState.videoTrack.getCapabilities();
    const settings = AppState.videoTrack.getSettings();
    AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;

    if (capabilities.zoom) {
        AppState.cameraCapabilities.zoom = { ...capabilities.zoom };
        $('zoomSlider').min = capabilities.zoom.min || 1; $('zoomSlider').max = capabilities.zoom.max || 10;
        $('zoomSlider').step = capabilities.zoom.step || 0.1;
        const currentVideoZoom = settings.zoom || capabilities.zoom.min || 1;
        $('zoomSlider').value = currentVideoZoom; $('zoomOutput').textContent = parseFloat(currentVideoZoom).toFixed(1);
        AppState.currentZoom = parseFloat(currentVideoZoom); updateZoomTypeIndicator();
    }
    if (capabilities.focusMode?.includes("manual") && capabilities.focusDistance) {
        AppState.cameraCapabilities.focus = { ...capabilities.focusDistance };
        $('focusSlider').min = capabilities.focusDistance.min || 0; $('focusSlider').max = capabilities.focusDistance.max || 1;
        $('focusSlider').step = capabilities.focusDistance.step || 0.01;
        $('focusSlider').value = settings.focusDistance || capabilities.focusDistance.min || 0;
        $('focusOutput').textContent = parseFloat($('focusSlider').value).toFixed(2);
    }
    updateUI();
};

const releaseCamera = () => { /* ... (same as V4) ... */
    if (AppState.mediaStream) {
        AppState.mediaStream.getTracks().forEach(track => track.stop());
        logger.log("Camera stream released.");
    }
    $('videoPreview').srcObject = null; AppState.mediaStream = null; AppState.videoTrack = null;
    setupCameraControls(); // Clears/disables controls
};

const _initCameraWork = async (deviceId) => { /* ... (same as V4, ensure logger is used) ... */
    releaseCamera();
    const constraints = { video: { width: { ideal: 1920, max: 2560 }, height: { ideal: 1080, max: 1440 }, frameRate: { ideal: 24, max: 30 }, facingMode: "environment", audio: false } };
    if (deviceId) { constraints.video.deviceId = { exact: deviceId }; delete constraints.video.facingMode; }

    logger.log(`Attempting to get camera with constraints: ${JSON.stringify(constraints.video)}`);
    AppState.mediaStream = await promiseWithTimeout( navigator.mediaDevices.getUserMedia(constraints), 10000, "Camera access request timed out. Respond to prompts." );
    logger.log("getUserMedia call successful.");
    const videoTracks = AppState.mediaStream.getVideoTracks();
    if (videoTracks.length === 0) throw new Error("No video tracks found in the acquired stream.");
    AppState.videoTrack = videoTracks[0]; logger.log(`Video track acquired: ${AppState.videoTrack.label}`);
    const videoEl = $('videoPreview'); videoEl.srcObject = AppState.mediaStream;
    await promiseWithTimeout( new Promise((resolve, reject) => {
            const currentOnLoadedMetadata = () => { videoEl.onloadedmetadata = null; videoEl.onerror = null; resolve(); };
            const currentOnError = () => { videoEl.onloadedmetadata = null; videoEl.onerror = null; reject(new Error("Video element failed to load stream.")); };
            videoEl.onloadedmetadata = currentOnLoadedMetadata; videoEl.onerror = currentOnError;
        }), 5000, "Video stream metadata loading timed out." );
    logger.success(`Camera active: ${AppState.videoTrack.label || 'N/A'}`);
    setupCameraControls();
};

const listCameras = async () => { /* ... (same as V4, ensure logger is used) ... */
    if (AppState.isInitializingCamera) { logger.log("listCameras skipped: init already in progress."); return; }
    AppState.isInitializingCamera = true; updateUI();
    try {
        logger.log("Verifying camera permissions...");
        try {
            const permStream = await promiseWithTimeout( navigator.mediaDevices.getUserMedia({video: true, audio: false}), 8000, "Perm check timed out." );
            permStream.getTracks().forEach(track => track.stop()); logger.log("Preliminary camera permission check passed.");
        } catch (permErr) {
            logger.error("Preliminary camera permission check failed.", permErr);
            let msg = `Could not verify permissions: ${permErr.name || permErr.message}.`;
            if (permErr.name === "NotAllowedError" || permErr.name === "PermissionDeniedError") msg = "Camera access denied.<br>Allow in browser settings & refresh.";
            else if (permErr.message.includes("timed out")) msg = "Perm check timed out.<br>Respond to prompts & refresh.";
            updateStatusOverlay(msg, false, true); throw permErr;
        }
        logger.log("Enumerating video devices...");
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const cameraSelect = $('cameraSelect'); cameraSelect.innerHTML = '';
        if (videoDevices.length === 0) {
            logger.error("No video input devices found."); updateStatusOverlay("No cameras found.", false, true);
            AppState.cameraCapabilities.hasMultipleCameras = false; throw new Error("No video devices found.");
        }
        logger.log(`Found ${videoDevices.length} video devices.`); AppState.cameraCapabilities.hasMultipleCameras = videoDevices.length > 1;
        videoDevices.forEach(device => { /* ... add options ... */ 
            const option = document.createElement('option'); option.value = device.deviceId;
            option.text = device.label || `Camera ${cameraSelect.options.length + 1}`; cameraSelect.appendChild(option);
        });
        let selectedDeviceId = videoDevices[0].deviceId;
        try { /* ... select last cam or environment ... */ 
            const lastCamId = localStorage.getItem("TV_LAST_CAM");
            if (lastCamId && videoDevices.some(d => d.deviceId === lastCamId)) selectedDeviceId = lastCamId;
            else { const envCam = videoDevices.find(d => d.label.toLowerCase().includes('back') || d.label.toLowerCase().includes('environment')); if (envCam) selectedDeviceId = envCam.deviceId; }
        } catch (e) { logger.error("Error with localStorage for last camera.", e); }
        cameraSelect.value = selectedDeviceId;
        cameraSelect.onchange = () => {
            if (AppState.isInitializingCamera) return;
            try { localStorage.setItem("TV_LAST_CAM", cameraSelect.value); } catch (e) { logger.error("Error saving last cam.", e); }
            listCameras(); // Re-run the whole list and init sequence
        };
        await _initCameraWork(selectedDeviceId);
    } catch (err) {
        logger.error(`Error in listCameras main process: ${err.message}`, err);
        if (!AppState.videoTrack) {
            let userMessage = `Failed to initialize camera system.`; // Default for unhandled paths
            if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") userMessage = "Camera access denied.<br>Grant access & refresh.";
            else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError" || err.message.includes("No video devices")) userMessage = "No suitable camera found.";
            else if (err.name === "OverconstrainedError" || err.name === "ConstraintNotSatisfiedError") userMessage = "Camera doesn't support settings.";
            else if (err.message.includes("timed out")) userMessage = err.message;
            else if (err.message) userMessage = `Camera error: ${err.message.substring(0,60)}`;

            updateStatusOverlay(userMessage, false, true);
        }
        releaseCamera();
    } finally {
        AppState.isInitializingCamera = false; updateUI();
    }
};

const captureImage = () => { /* ... (same as V4) ... */
    const video = $('videoPreview'); if (!video.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) { logger.error("Video not ready for capture."); return null; }
    const canvas = document.createElement('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight; const ctx = canvas.getContext('2d'); let effDigZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) effDigZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) effDigZoom = AppState.currentZoom;
    const cw = video.videoWidth/effDigZoom, ch = video.videoHeight/effDigZoom, cx = (video.videoWidth-cw)/2, cy = (video.videoHeight-ch)/2;
    ctx.drawImage(video, cx, cy, cw, ch, 0, 0, canvas.width, canvas.height); return canvas.toDataURL('image/jpeg', 0.9);
};

const solveMathProblem = async (imageDataUrl) => { /* ... (same as V4, ensure logger is used for OpenAI request start) ... */
    if (!AppState.apiKey) throw new Error("API Key not set.");
    logger.log("Sending image to OpenAI for analysis...", { imageSize: imageDataUrl.length });
    const payload = { model: "gpt-4o-mini", max_tokens: 800, messages: [{ role: "user", content: [
            { type: "text", text: "You are a precise math problem solver. Analyze the image. Provide a step-by-step thinking process to solve the math problem. On the VERY LAST line, provide ONLY the final numeric answer, prefixed with 'Final Answer:'. For example: 'Final Answer: 42'. If no clear math problem is found, state 'No clear math problem detected.' If the image is unreadable or too blurry, state 'Image is unreadable.' Do not add any other pleasantries or extra text on the final answer line." },
            { type: "image_url", image_url: { url: imageDataUrl, detail: "high" } }
    ]}]};
    const response = await fetch("https://api.openai.com/v1/chat/completions", { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${AppState.apiKey}` }, body: JSON.stringify(payload) });
    if (!response.ok) { /* ... (same error handling as V4) ... */
        const errData = await response.json().catch(() => ({ error: { message: `HTTP ${response.status}` } })); const message = errData.error?.message || `HTTP ${response.status}`;
        if (response.status === 401) throw new Error("Invalid or unauthorized OpenAI API Key (401).");
        if (response.status === 429) { logger.error("OpenAI rate limit. Retrying...", errData); await new Promise(r => setTimeout(r, 7000)); if (!AppState.isProcessing) throw new Error("Processing stopped during retry."); return solveMathProblem(imageDataUrl); }
        throw new Error(`OpenAI API Error: ${message}`);
    }
    const result = await response.json(); logger.log("OpenAI response received.", result.usage);
    const content = result.choices?.[0]?.message?.content?.trim() || "No content from AI.";
    const lines = content.split('\n'); const lastLine = lines[lines.length - 1];
    const answerMatch = lastLine.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/); const numericAnswer = answerMatch ? answerMatch[1] : null;
    if (content.includes("No clear math problem detected.") || content.includes("Image is unreadable.")) return { fullText: content, numericAnswer: null, statusMessage: content };
    return { fullText: content, numericAnswer, statusMessage: numericAnswer ? `Solved: ${numericAnswer}` : "Could not extract answer." };
};

const processFrame = async () => { /* ... (same as V4, ensure logger for full AI response) ... */
    if (!AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack) { if (AppState.isProcessing) logger.log("Process frame skipped: conditions not met."); updateUI(); return; }
    updateStatusOverlay("Capturing image...", true); const imageDataUrl = captureImage();
    if (!imageDataUrl) { logger.error("Failed to capture image for processing."); if (AppState.isProcessing) AppState.captureTimeout = setTimeout(processFrame, 3500); updateUI(); return; }
    try {
        updateStatusOverlay("Analyzing with AI...", true);
        const { fullText, numericAnswer, statusMessage } = await solveMathProblem(imageDataUrl);
        logger.log("AI Full Response (for debugging if needed, or verbose log):\n" + fullText, {isFullResponse: true}); // Log full response with a flag
        if (numericAnswer) {
            logger.success(`Solution: ${numericAnswer}`, { fullAIResponse: $('verboseLogCheck').checked ? fullText : undefined });
            showToast(`Answer: ${numericAnswer}`, 'success', 5000);
            try { speechSynthesis.speak(new SpeechSynthesisUtterance(numericAnswer)); } catch (speechErr) { logger.error("Speech synthesis failed.", speechErr); }
        } else {
            logger.log(statusMessage || "AI could not find a numeric answer.", { fullAIResponse: $('verboseLogCheck').checked ? fullText : undefined });
            showToast(statusMessage || "Could not extract answer.", 'info', 4000);
        }
    } catch (err) {
        logger.error(`Processing error: ${err.message}`, err);
        if (err.message.includes("API Key")) { if(AppState.isProcessing) $('stopBtn').click(); updateStatusOverlay(`API Key Error.<br>Verify key.`, false, true); }
        else { updateStatusOverlay(`Error: ${err.message.substring(0,100)}...`, false, true); }
    } finally {
        if (AppState.isProcessing) { updateStatusOverlay("Ready. Aim at a math problem.", false); AppState.captureTimeout = setTimeout(processFrame, 3500); }
        else { updateUI(); }
    }
};

const updateZoomTypeIndicator = () => { /* ... (same as V4) ... */
    const indicator = $('zoomType');
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) { indicator.textContent = '(Digital)'; indicator.style.color = 'var(--hi)'; }
    else if (AppState.cameraCapabilities.zoom) { indicator.textContent = '(Optical)'; indicator.style.color = 'var(--succ)'; }
    else { indicator.textContent = ''; }
};

// --- Event Listeners ---
$('saveKeyBtn').onclick = () => {
    if (AppState.isInitializingCamera || AppState.isProcessing) return;
    const keyInput = $('apiKey').value.trim();
    if (keyInput.startsWith("sk-")) {
        AppState.apiKey = keyInput;
        try { localStorage.setItem("TV_API_KEY", keyInput); } catch (e) { logger.error("Failed to save API key to localStorage.", e); }
        $('apiKey').value = '••••••••' + keyInput.slice(-4);
        logger.success("API Key Saved!");
        if (!AppState.videoTrack) { listCameras(); }
        else { updateUI(); }
    } else { logger.error("Invalid API Key format. Must start with 'sk-'."); }
};

$('clearKeyBtn').onclick = () => {
    if (AppState.isInitializingCamera || AppState.isProcessing) return;
    logger.log("Clearing API Key.");
    AppState.apiKey = "";
    try { localStorage.removeItem("TV_API_KEY"); } catch (e) { logger.error("Failed to remove API key from localStorage.", e); }
    $('apiKey').value = "";
    if (AppState.isProcessing) $('stopBtn').click(); // Stop processing if it was running
    releaseCamera(); // Release camera as key is gone
    logger.success("API Key Cleared.");
    updateUI();
};

$('zoomSlider').oninput = (e) => { /* ... (same as V4) ... */
    if (AppState.isInitializingCamera || !AppState.videoTrack) return;
    const zoomValue = parseFloat(e.target.value); $('zoomOutput').textContent = zoomValue.toFixed(1); AppState.currentZoom = zoomValue; updateZoomTypeIndicator();
    if (AppState.videoTrack && AppState.cameraCapabilities.zoom && zoomValue <= AppState.cameraCapabilities.zoom.max) {
        AppState.videoTrack.applyConstraints({ advanced: [{ zoom: zoomValue }] }).catch(err => logger.error(`Hardware zoom error`, err));
    }
};
$('focusSlider').oninput = (e) => { /* ... (same as V4) ... */
    if (AppState.isInitializingCamera || !AppState.videoTrack) return;
    if (AppState.videoTrack && AppState.cameraCapabilities.focus) {
        const focusValue = parseFloat(e.target.value); $('focusOutput').textContent = focusValue.toFixed(2);
        AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: focusValue }] }).catch(err => logger.error(`Manual focus error`, err));
    }
};
$('startBtn').onclick = () => { /* ... (same as V4) ... */
    if (AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack || !AppState.apiKey) return;
    AppState.isProcessing = true; logger.log("Processing started by user."); showToast("Vision Math Solver Started", "info");
    updateUI(); processFrame();
};
$('stopBtn').onclick = () => { /* ... (same as V4) ... */
    if (!AppState.isProcessing) return;
    AppState.isProcessing = false; clearTimeout(AppState.captureTimeout); logger.log("Processing stopped by user."); showToast("Solver Stopped", "info");
    updateStatusOverlay("Stopped.", false); updateUI();
};

$('copyLogBtn').onclick = async () => {
    const logText = $('logTextarea').value;
    if (!logText.trim()) {
        showToast("Log is empty.", "info"); return;
    }
    try {
        await navigator.clipboard.writeText(logText);
        logger.success("Log copied to clipboard.");
    } catch (err) {
        logger.error("Failed to copy log automatically. You might need to select and copy manually.", err);
        // Fallback: select text for manual copy
        $('logTextarea').select();
        $('logTextarea').setSelectionRange(0, 999999); // For mobile
        showToast("Log selected for manual copy.", "info");
    }
    updateUI(); // Update disabled state if needed
};

$('verboseLogCheck').onchange = () => {
    logger.log(`Verbose logging ${$('verboseLogCheck').checked ? 'enabled' : 'disabled'}.`);
    try { localStorage.setItem("TV_VERBOSE_LOG", $('verboseLogCheck').checked ? 'true' : 'false'); } catch(e) { logger.error("Failed to save verbose preference.",e); }
};


// --- Initialization & Global Handlers ---
document.addEventListener('DOMContentLoaded', () => {
    try { AppState.apiKey = localStorage.getItem("TV_API_KEY") || ""; } catch (e) { logger.error("Failed to read API key.", e); AppState.apiKey = ""; }
    try { $('verboseLogCheck').checked = localStorage.getItem("TV_VERBOSE_LOG") === 'true'; } catch (e) { logger.error("Failed to read verbose pref.", e); }

    if (AppState.apiKey) {
        $('apiKey').value = '••••••••' + AppState.apiKey.slice(-4); listCameras();
    }
    updateUI(); // Initial UI setup based on loaded state
});
document.addEventListener("visibilitychange", () => { /* ... (same as V4) ... */
    if (document.visibilityState === 'hidden') {
        if (AppState.isProcessing) { $('stopBtn').click(); logger.log("App hidden, processing stopped."); }
        if (AppState.videoTrack) releaseCamera(); updateUI();
    } else if (document.visibilityState === 'visible') {
        if (AppState.apiKey && !AppState.videoTrack && !AppState.isInitializingCamera) { logger.log("App visible, re-initializing camera."); listCameras(); }
    }
});
window.addEventListener('beforeunload', () => { releaseCamera(); });

</script>
</body>
</html>