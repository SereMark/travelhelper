<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Vision AI</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-user-select: none;
    user-select: none;
}

body {
    font-family: -apple-system, system-ui, sans-serif;
    background: #000;
    color: #fff;
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
}

/* Camera */
#camera {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

/* Controls */
.main-controls {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    align-items: center;
}

.toggle-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    background: #007AFF;
    border: 3px solid #fff;
    cursor: pointer;
    transition: all 0.2s;
}

.toggle-btn.active {
    background: #FF3B30;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7); }
    50% { box-shadow: 0 0 0 15px rgba(255, 59, 48, 0); }
}

.settings-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    border: none;
    font-size: 24px;
    cursor: pointer;
}

/* Zoom Slider */
.zoom-control {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 10px;
    display: none;
}

.zoom-control.show {
    display: block;
}

.zoom-slider {
    writing-mode: bt-lr;
    -webkit-appearance: slider-vertical;
    width: 40px;
    height: 200px;
    background: transparent;
    outline: none;
    cursor: pointer;
}

/* Settings Panel */
.settings {
    position: fixed;
    inset: 0;
    background: #000;
    transform: translateX(100%);
    transition: transform 0.3s ease;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

.settings.open {
    transform: translateX(0);
}

.settings-content {
    padding: 20px;
    padding-top: env(safe-area-inset-top, 20px);
    padding-bottom: env(safe-area-inset-bottom, 20px);
}

.settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
}

.settings h2 {
    font-size: 24px;
    font-weight: 600;
}

.close-btn {
    background: none;
    border: none;
    color: #fff;
    font-size: 32px;
    cursor: pointer;
    padding: 0;
    width: 40px;
    height: 40px;
}

.section {
    margin-bottom: 30px;
}

.section-title {
    font-size: 14px;
    opacity: 0.6;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 15px;
}

.input-group {
    margin-bottom: 15px;
}

.input-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    opacity: 0.8;
}

.input-group input,
.input-group select {
    width: 100%;
    padding: 12px 15px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    color: #fff;
    font-size: 16px;
    font-family: inherit;
}

.input-group select {
    cursor: pointer;
}

.input-group select option {
    background: #000;
    color: #fff;
}

.switch-group {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
}

.switch {
    position: relative;
    width: 51px;
    height: 31px;
}

.switch input {
    display: none;
}

.switch-slider {
    position: absolute;
    inset: 0;
    background: rgba(255,255,255,0.3);
    border-radius: 31px;
    cursor: pointer;
    transition: background 0.3s;
}

.switch-slider:before {
    content: "";
    position: absolute;
    width: 27px;
    height: 27px;
    left: 2px;
    top: 2px;
    background: #fff;
    border-radius: 50%;
    transition: transform 0.3s;
}

input:checked + .switch-slider {
    background: #34C759;
}

input:checked + .switch-slider:before {
    transform: translateX(20px);
}

.save-btn {
    width: 100%;
    padding: 16px;
    background: #007AFF;
    border: none;
    border-radius: 12px;
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 20px;
}

/* Logs */
.logs {
    margin-top: 40px;
    padding-top: 30px;
    border-top: 1px solid rgba(255,255,255,0.1);
}

.logs-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.logs h3 {
    font-size: 18px;
    font-weight: 600;
}

.clear-logs-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 6px;
    color: #fff;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
}

.log-container {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    padding: 15px;
    font-family: 'SF Mono', monospace;
    font-size: 11px;
    line-height: 1.5;
    max-height: 400px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

.log-entry {
    margin-bottom: 8px;
    word-break: break-all;
}

.log-time {
    opacity: 0.5;
}

.log-entry.error {
    color: #FF453A;
}

.log-entry.success {
    color: #32D74B;
}

.log-entry.info {
    color: #64D2FF;
}
</style>
</head>
<body>
<video id="camera" playsinline autoplay muted></video>

<div class="zoom-control" id="zoomControl">
    <input type="range" class="zoom-slider" id="zoomSlider" min="1" max="5" step="0.1" value="1" orient="vertical">
</div>

<div class="main-controls">
    <button class="toggle-btn" id="toggleBtn"></button>
    <button class="settings-btn" id="settingsBtn">⚙️</button>
</div>

<div class="settings" id="settings">
    <div class="settings-content">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="close-btn" id="closeBtn">×</button>
        </div>
        
        <div class="section">
            <h3 class="section-title">API Configuration</h3>
            <div class="input-group">
                <label>OpenAI API Key</label>
                <input type="password" id="openaiKey" placeholder="sk-..." autocomplete="off">
            </div>
            
            <div class="input-group">
                <label>Google AI API Key</label>
                <input type="password" id="geminiKey" placeholder="AIza..." autocomplete="off">
            </div>
        </div>
        
        <div class="section">
            <h3 class="section-title">Camera Settings</h3>
            <div class="input-group">
                <label>Camera Selection</label>
                <select id="cameraSelect">
                    <option value="">Loading cameras...</option>
                </select>
            </div>
            
            <div class="switch-group">
                <span>Scan Interval (seconds)</span>
                <input type="number" id="scanInterval" min="2" max="30" value="5" style="width: 60px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; padding: 6px; color: #fff; text-align: center;">
            </div>
        </div>
        
        <div class="section">
            <h3 class="section-title">Voice Settings</h3>
            <div class="switch-group">
                <span>Repeat Answer</span>
                <input type="number" id="repeatCount" min="1" max="5" value="2" style="width: 60px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; padding: 6px; color: #fff; text-align: center;">
            </div>
            
            <div class="switch-group">
                <span>Speech Rate</span>
                <input type="number" id="speechRate" min="0.5" max="2" step="0.1" value="0.9" style="width: 60px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; padding: 6px; color: #fff; text-align: center;">
            </div>
        </div>
        
        <button class="save-btn" id="saveBtn">Save Settings</button>
        
        <div class="logs">
            <div class="logs-header">
                <h3>Debug Logs</h3>
                <button class="clear-logs-btn" id="clearLogsBtn">Clear</button>
            </div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>
</div>

<script>
// Global State
const state = {
    stream: null,
    videoTrack: null,
    cameras: [],
    currentCamera: null,
    isScanning: false,
    scanTimer: null,
    zoomCapabilities: null,
    settings: {
        openai: localStorage.getItem('visionai_openai') || '',
        gemini: localStorage.getItem('visionai_gemini') || '',
        cameraId: localStorage.getItem('visionai_camera') || '',
        scanInterval: parseInt(localStorage.getItem('visionai_interval') || '5'),
        repeatCount: parseInt(localStorage.getItem('visionai_repeat') || '2'),
        speechRate: parseFloat(localStorage.getItem('visionai_rate') || '0.9')
    }
};

// DOM Elements
const els = {
    camera: document.getElementById('camera'),
    toggleBtn: document.getElementById('toggleBtn'),
    settingsBtn: document.getElementById('settingsBtn'),
    settings: document.getElementById('settings'),
    closeBtn: document.getElementById('closeBtn'),
    saveBtn: document.getElementById('saveBtn'),
    clearLogsBtn: document.getElementById('clearLogsBtn'),
    logContainer: document.getElementById('logContainer'),
    zoomControl: document.getElementById('zoomControl'),
    zoomSlider: document.getElementById('zoomSlider'),
    cameraSelect: document.getElementById('cameraSelect'),
    openaiKey: document.getElementById('openaiKey'),
    geminiKey: document.getElementById('geminiKey'),
    scanInterval: document.getElementById('scanInterval'),
    repeatCount: document.getElementById('repeatCount'),
    speechRate: document.getElementById('speechRate')
};

// Logging System
function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
    els.logContainer.appendChild(entry);
    els.logContainer.scrollTop = els.logContainer.scrollHeight;
    
    // Also log to console for debugging
    console.log(`[${timestamp}] ${message}`);
}

// Camera Functions
async function enumerateCameras() {
    log('Enumerating cameras...');
    try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        state.cameras = devices.filter(d => d.kind === 'videoinput');
        
        log(`Found ${state.cameras.length} camera(s)`);
        
        els.cameraSelect.innerHTML = state.cameras.map((cam, index) => {
            const label = cam.label || `Camera ${index + 1}`;
            log(`Camera ${index}: ${label} (${cam.deviceId})`);
            return `<option value="${cam.deviceId}">${label}</option>`;
        }).join('');
        
        // Select saved camera or first available
        if (state.settings.cameraId && state.cameras.find(c => c.deviceId === state.settings.cameraId)) {
            els.cameraSelect.value = state.settings.cameraId;
        } else if (state.cameras.length > 0) {
            els.cameraSelect.value = state.cameras[0].deviceId;
        }
    } catch (err) {
        log(`Camera enumeration error: ${err.message}`, 'error');
    }
}

async function startCamera(deviceId = null) {
    log(`Starting camera with deviceId: ${deviceId || 'default'}`);
    
    try {
        // Stop existing stream
        if (state.stream) {
            log('Stopping existing stream');
            state.stream.getTracks().forEach(track => {
                track.stop();
                log(`Stopped track: ${track.kind}`);
            });
        }
        
        // Camera constraints
        const constraints = {
            video: {
                width: { ideal: 1920, min: 1280 },
                height: { ideal: 1080, min: 720 },
                deviceId: deviceId ? { exact: deviceId } : undefined
            },
            audio: false
        };
        
        log(`Requesting camera with constraints: ${JSON.stringify(constraints)}`);
        state.stream = await navigator.mediaDevices.getUserMedia(constraints);
        
        state.videoTrack = state.stream.getVideoTracks()[0];
        const settings = state.videoTrack.getSettings();
        log(`Camera started: ${settings.width}x${settings.height} @ ${settings.frameRate}fps`);
        
        els.camera.srcObject = state.stream;
        await els.camera.play();
        
        // Setup zoom if supported
        setupZoom();
        
    } catch (err) {
        log(`Camera start error: ${err.name} - ${err.message}`, 'error');
    }
}

function setupZoom() {
    if (!state.videoTrack) return;
    
    const capabilities = state.videoTrack.getCapabilities();
    log(`Camera capabilities: ${JSON.stringify(capabilities)}`);
    
    if (capabilities.zoom) {
        state.zoomCapabilities = capabilities.zoom;
        els.zoomControl.classList.add('show');
        els.zoomSlider.min = capabilities.zoom.min || 1;
        els.zoomSlider.max = capabilities.zoom.max || 1;
        els.zoomSlider.value = state.videoTrack.getSettings().zoom || 1;
        
        log(`Zoom available: ${capabilities.zoom.min} - ${capabilities.zoom.max}`);
        
        els.zoomSlider.addEventListener('input', async (e) => {
            const zoom = parseFloat(e.target.value);
            try {
                await state.videoTrack.applyConstraints({ advanced: [{ zoom }] });
                log(`Zoom set to: ${zoom}`);
            } catch (err) {
                log(`Zoom error: ${err.message}`, 'error');
            }
        });
    } else {
        els.zoomControl.classList.remove('show');
        log('Zoom not supported on this camera');
    }
}

// Image Capture
function captureImage() {
    log('Capturing image...');
    try {
        const canvas = document.createElement('canvas');
        canvas.width = els.camera.videoWidth;
        canvas.height = els.camera.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(els.camera, 0, 0);
        
        const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
        log(`Image captured: ${canvas.width}x${canvas.height}, size: ${Math.round(dataUrl.length / 1024)}KB`);
        
        return dataUrl;
    } catch (err) {
        log(`Capture error: ${err.message}`, 'error');
        throw err;
    }
}

// Voice Output
function speak(text, onComplete) {
    if (!('speechSynthesis' in window)) {
        log('Speech synthesis not available', 'error');
        if (onComplete) onComplete();
        return;
    }
    
    log(`Speaking: "${text}" (${state.settings.repeatCount} times)`);
    
    let repeatIndex = 0;
    
    function sayOnce() {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = state.settings.speechRate;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        utterance.onend = () => {
            repeatIndex++;
            log(`Speech completed (${repeatIndex}/${state.settings.repeatCount})`);
            
            if (repeatIndex < state.settings.repeatCount) {
                setTimeout(sayOnce, 500); // 500ms pause between repeats
            } else if (onComplete) {
                onComplete();
            }
        };
        
        utterance.onerror = (e) => {
            log(`Speech error: ${e.error}`, 'error');
            if (onComplete) onComplete();
        };
        
        speechSynthesis.speak(utterance);
    }
    
    // Cancel any ongoing speech
    speechSynthesis.cancel();
    
    // Start speaking
    sayOnce();
}

// API Functions
async function extractQuestion(imageData) {
    log('Calling OpenAI API to extract question...');
    
    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${state.settings.openai}`
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: [{
                    role: 'user',
                    content: [
                        { 
                            type: 'text', 
                            text: 'Extract the main question from this image. Include all answer options if it\'s multiple choice. Be precise and complete.' 
                        },
                        { 
                            type: 'image_url', 
                            image_url: { url: imageData } 
                        }
                    ]
                }],
                max_tokens: 500,
                temperature: 0
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || `API returned ${response.status}`);
        }
        
        const data = await response.json();
        const question = data.choices[0].message.content.trim();
        
        log(`Extracted question: "${question.substring(0, 100)}..."`);
        return question;
        
    } catch (err) {
        log(`OpenAI API error: ${err.message}`, 'error');
        throw err;
    }
}

async function solveQuestion(question) {
    log('Calling Gemini API to solve question...');
    
    try {
        const prompt = `Answer this question with ONLY the letter choice (A, B, C, D, etc) or number if it's numerical. 
Do not include any explanation, just the letter or number.

Question: ${question}`;
        
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp:generateContent?key=${state.settings.gemini}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 50,
                    topK: 1,
                    topP: 0.1
                }
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || `API returned ${response.status}`);
        }
        
        const data = await response.json();
        const answer = data.candidates[0].content.parts[0].text.trim();
        
        // Extract just the letter/number
        const cleanAnswer = answer.match(/^[A-E]|^\d+/)?.[0] || answer;
        
        log(`Gemini answer: "${cleanAnswer}"`, 'success');
        return cleanAnswer;
        
    } catch (err) {
        log(`Gemini API error: ${err.message}`, 'error');
        throw err;
    }
}

// Scan Process
async function performScan() {
    log('Starting scan cycle...');
    
    if (!state.settings.openai || !state.settings.gemini) {
        log('Missing API keys, skipping scan', 'error');
        speak('Please configure API keys in settings');
        return;
    }
    
    try {
        // Capture
        const imageData = captureImage();
        
        // Extract
        const question = await extractQuestion(imageData);
        
        if (!question || question.length < 10) {
            log('No valid question found', 'error');
            speak('No question detected');
            return;
        }
        
        // Solve
        const answer = await solveQuestion(question);
        
        // Announce answer
        speak(`The answer is ${answer}`, () => {
            log('Answer announcement completed');
        });
        
    } catch (err) {
        log(`Scan cycle error: ${err.message}`, 'error');
        speak('Scan error occurred');
    }
}

// Toggle Scanning
function toggleScanning() {
    state.isScanning = !state.isScanning;
    els.toggleBtn.classList.toggle('active', state.isScanning);
    
    if (state.isScanning) {
        log(`Started continuous scanning (interval: ${state.settings.scanInterval}s)`);
        
        // Perform first scan immediately
        performScan();
        
        // Set up interval
        state.scanTimer = setInterval(performScan, state.settings.scanInterval * 1000);
    } else {
        log('Stopped scanning');
        
        if (state.scanTimer) {
            clearInterval(state.scanTimer);
            state.scanTimer = null;
        }
        
        // Cancel any ongoing speech
        speechSynthesis.cancel();
    }
}

// Settings
function openSettings() {
    els.settings.classList.add('open');
    
    // Populate current values
    els.openaiKey.value = state.settings.openai;
    els.geminiKey.value = state.settings.gemini;
    els.scanInterval.value = state.settings.scanInterval;
    els.repeatCount.value = state.settings.repeatCount;
    els.speechRate.value = state.settings.speechRate;
    
    log('Settings panel opened');
}

function saveSettings() {
    // Get values
    state.settings.openai = els.openaiKey.value.trim();
    state.settings.gemini = els.geminiKey.value.trim();
    state.settings.cameraId = els.cameraSelect.value;
    state.settings.scanInterval = parseInt(els.scanInterval.value);
    state.settings.repeatCount = parseInt(els.repeatCount.value);
    state.settings.speechRate = parseFloat(els.speechRate.value);
    
    // Save to localStorage
    localStorage.setItem('visionai_openai', state.settings.openai);
    localStorage.setItem('visionai_gemini', state.settings.gemini);
    localStorage.setItem('visionai_camera', state.settings.cameraId);
    localStorage.setItem('visionai_interval', state.settings.scanInterval);
    localStorage.setItem('visionai_repeat', state.settings.repeatCount);
    localStorage.setItem('visionai_rate', state.settings.speechRate);
    
    log('Settings saved', 'success');
    
    // Restart camera if changed
    if (state.currentCamera !== state.settings.cameraId) {
        state.currentCamera = state.settings.cameraId;
        startCamera(state.currentCamera);
    }
    
    // Update scan interval if scanning
    if (state.isScanning && state.scanTimer) {
        clearInterval(state.scanTimer);
        state.scanTimer = setInterval(performScan, state.settings.scanInterval * 1000);
        log(`Updated scan interval to ${state.settings.scanInterval}s`);
    }
    
    els.settings.classList.remove('open');
}

// Event Listeners
els.toggleBtn.addEventListener('click', toggleScanning);
els.settingsBtn.addEventListener('click', openSettings);
els.closeBtn.addEventListener('click', () => els.settings.classList.remove('open'));
els.saveBtn.addEventListener('click', saveSettings);
els.clearLogsBtn.addEventListener('click', () => {
    els.logContainer.innerHTML = '';
    log('Logs cleared');
});

// Prevent gestures
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());

// Initialize
async function init() {
    log('Vision AI initializing...', 'info');
    
    // Request initial camera permission
    try {
        await navigator.mediaDevices.getUserMedia({ video: true });
        log('Camera permission granted');
    } catch (err) {
        log(`Camera permission denied: ${err.message}`, 'error');
    }
    
    // Enumerate cameras
    await enumerateCameras();
    
    // Start default camera
    await startCamera(state.settings.cameraId || state.cameras[0]?.deviceId);
    
    // Log settings
    log(`Settings loaded: OpenAI key ${state.settings.openai ? 'present' : 'missing'}, Gemini key ${state.settings.gemini ? 'present' : 'missing'}`);
    
    log('Initialization complete', 'success');
}

// Start app
init();
</script>
</body>
</html>