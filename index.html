<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 15px; /* Adjusted base for mobile */
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.45; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.5rem 0.7rem; /* Compact header */
    font-weight: 600; font-size: 0.95rem;
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .title { flex-grow: 1; text-align: center; margin-left: 40px; /* Approx width of button */ }
header button#toggleLogBtn {
    font-size: 0.75rem; padding: 0.25rem 0.6rem; min-width: 40px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover:not(:disabled) { background: var(--trk); }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area {
    padding: 0.6rem 0.9rem; display: flex; flex-direction: column; gap: 0.6rem;
    background: var(--bg); border-bottom: 1px solid var(--trk);
    flex-shrink: 0; max-height: 40vh; /* Allow more space if needed, scroll kicks in */
    overflow-y: auto; -webkit-overflow-scrolling: touch;
}
.control-group { display: flex; flex-direction: column; gap: 0.2rem; }
.control-row { display: flex; gap: 0.4rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 70px; padding: 0.55rem 0.35rem; font-size: 0.8rem; }
#apiKeyDisplay { font-size: 0.8rem; color: var(--fg); background: var(--trk); padding: 0.55rem; border-radius: 6px; flex-grow: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

input[type="password"], select, button, textarea {
    padding: 0.65rem; border-radius: 6px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.85rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.78rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.05rem; }
output { font-weight: 500; margin-left: 0.2rem; font-feature-settings: "tnum"; font-size: 0.78rem; }
#zoomType { font-size: 0.7rem; opacity: 0.8; }

.range { appearance: none; width: 100%; height: 6px; border-radius: 3px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:22px; height:22px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-webkit-slider-thumb:active { transform: scale(1.1); cursor: grabbing; }
.range::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1px 3px var(--shadow-color); cursor:grab; }
.range::-moz-range-thumb:active { transform: scale(1.1); cursor: grabbing; }

.preview-area {
    flex-grow: 1; display: flex; justify-content: center; align-items: center;
    padding: 0.2rem; background: #0a0a0a; overflow: hidden; position: relative;
    min-height: 150px;
}
.frame { width: 100%; height: 100%; max-width: 100vw; max-height: 100%; border-radius: 6px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 6px var(--shadow-color); }
video { width: 100%; height: 100%; object-fit: contain; display: block; background: #050505; }

.video-spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.25); /* Very subtle overlay for spinner */
    z-index: 5; opacity:0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s; pointer-events: none;
}
.video-spinner-overlay.visible { opacity:1; visibility: visible; }
.spinner { border: 3px solid rgba(255,255,255,0.2); border-top: 3px solid var(--hi); border-radius: 50%; width: 28px; height: 28px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.critical-message-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.7); backdrop-filter: blur(2.5px); color: white;
    font-size: 0.95rem; text-align:center; padding:1.2rem; z-index: 15;
    opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
}
.critical-message-overlay.visible { opacity:1; visibility: visible; }

.status-bar {
    padding: 0.3rem 0.8rem; text-align: center; font-size: 0.8rem;
    background-color: var(--bg); border-top: 1px solid var(--trk); border-bottom: 1px solid var(--trk);
    color: var(--fg); flex-shrink: 0; min-height: 2.2em; /* Ensure space for two lines potentially */
    line-height: 1.3; display: flex; align-items: center; justify-content: center;
}
.status-bar.error { color: var(--err); font-weight: 500; }
.status-bar.success { color: var(--succ); font-weight: 500; }

.actions-bar { padding: 0.5rem 0.8rem; display: flex; gap: 0.5rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.7rem; font-size: 0.9rem; font-weight: 600; }

.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column;
    height: 35vh; max-height: 250px; background-color: color-mix(in srgb, var(--bg) 97%, black);
    border-top: 1px solid var(--hi); box-shadow: 0 -2.5px 10px rgba(0,0,0,0.3);
    transform: translateY(100%); transition: transform 0.3s ease-in-out;
    z-index: 100;
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.65rem; line-height: 1.25; padding: 0.25rem 0.5rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.25rem 0.5rem; gap: 0.5rem; flex-shrink: 0; }
.log-bar button { padding: 0.25rem 0.5rem; font-size: 0.7rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.2rem; font-size: 0.7rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.75rem; height: 0.75rem; accent-color: var(--hi); }

.toast {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: var(--hi); color: var(--btn-fg); padding: 0.8rem 1.2rem; border-radius: 20px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.9rem; box-shadow: 0 2.5px 10px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s; user-select: none;
}
.toast.show { opacity: 1; top: 25px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: -10px; transform: translateX(-50%) scale(0.9); }
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>
            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>
            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>
            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="videoSpinnerOverlay" class="video-spinner-overlay">
                    <div id="spinnerIcon" class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="criticalMessageOverlay" class="critical-message-overlay">
             <p id="criticalMessageText"></p>
        </div>
    </div>

    <div id="statusBar" class="status-bar">Initializing app...</div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
};

const logger = {
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit'});
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) =>
                    typeof value === 'bigint' ? value.toString() : value, 2);
                logTextarea.value += detailStr + "\n";
            } catch (e) { logTextarea.value += "[Details: Unserializable Object]\n"; }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => { console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); },
    error: (message, errorObj) => {
        const errMsg = errorObj instanceof Error ? errorObj.message : (errorObj ? String(errorObj) : '');
        const fullMsg = `${message}${errMsg ? (': ' + errMsg) : ''}`; console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMsg}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message } : errorObj);
        showToast(message.length > 40 ? message.substring(0,37)+'...' : message, 'error', 5000);
    },
    success: (message, details) => { console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); showToast(message, 'success');}
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
    let timer;
    const timeoutPromise = new Promise((_, reject) => { timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms); });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3000) => {
    const el = $('toast'); clearTimeout(AppState.toastTimeout); el.textContent = message;
    el.className = 'toast'; if (type === 'error') el.classList.add('error'); else if (type === 'success') el.classList.add('success');
    el.classList.add('show'); AppState.toastTimeout = setTimeout(() => { el.classList.remove('show'); }, duration);
};

const updateStatus = (message, type = 'info', showSpinnerOnVideo = false) => {
    const statusBar = $('statusBar');
    const videoSpinnerOverlay = $('videoSpinnerOverlay');
    const criticalOverlay = $('criticalMessageOverlay');
    const criticalMessageText = $('criticalMessageText');

    if (type !== 'critical') {
        criticalOverlay.classList.remove('visible');
    }

    if (message) {
        statusBar.innerHTML = message;
        statusBar.className = 'status-bar'; 
        if (type === 'error') statusBar.classList.add('error');
        else if (type === 'success') statusBar.classList.add('success');
    }

    videoSpinnerOverlay.classList.toggle('visible', showSpinnerOnVideo);
    
    if (type === 'critical') {
        criticalMessageText.innerHTML = message;
        criticalOverlay.classList.add('visible');
        videoSpinnerOverlay.classList.remove('visible');
        if(statusBar) statusBar.innerHTML = ''; 
    }
};


const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) { $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`; }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;

    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || AppState.isInitializingCamera || !AppState.videoTrack);
    $('cameraSelect').disabled = !cameraIsActuallyReady || AppState.isProcessing;
    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || AppState.isInitializingCamera || !AppState.videoTrack);
    $('zoomSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.zoom;
    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || AppState.isInitializingCamera || !AppState.videoTrack);
    $('focusSlider').disabled = !cameraIsActuallyReady || AppState.isProcessing || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Log';

    if (AppState.isInitializingCamera) {
        // Status is set by the function initiating camera initialization
    } else if (!keyPresent) {
        // Initial API key prompt is handled by DOMContentLoaded
        // Ensure API key input is visible
        $('apiKeyEntryRow').classList.remove('hidden-control');
        $('apiKeyDisplayRow').classList.add('hidden-control');
    } else if (!AppState.videoTrack) {
        // Status like "Camera not available" set by listCameras/initCamera if they fail
    } else if (AppState.isProcessing) {
        // "Capturing", "Analyzing" set by processFrame
    } else if (cameraIsActuallyReady) {
        const currentStatus = $('statusBar').textContent;
        if (currentStatus === 'Initializing app...' || currentStatus === '' || currentStatus.includes("Initializing camera") || currentStatus.includes("Stopped") || currentStatus.includes("API Key cleared")) {
            updateStatus("Ready! Aim at problem.", 'success', false);
        }
    }
};

const setupCameraControls = () => {
    if (!AppState.videoTrack) { AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null; updateUI(); return; }
    const cap=AppState.videoTrack.getCapabilities(); const set=AppState.videoTrack.getSettings(); AppState.cameraCapabilities.zoom=null; AppState.cameraCapabilities.focus=null;
    if(cap.zoom){AppState.cameraCapabilities.zoom={...cap.zoom};$('zoomSlider').min=cap.zoom.min||1;$('zoomSlider').max=cap.zoom.max||10;$('zoomSlider').step=cap.zoom.step||0.1;const curZ=set.zoom||cap.zoom.min||1;$('zoomSlider').value=curZ;$('zoomOutput').textContent=parseFloat(curZ).toFixed(1);AppState.currentZoom=parseFloat(curZ);updateZoomTypeIndicator();}
    if(cap.focusMode?.includes("manual")&&cap.focusDistance){AppState.cameraCapabilities.focus={...cap.focusDistance};$('focusSlider').min=cap.focusDistance.min||0;$('focusSlider').max=cap.focusDistance.max||1;$('focusSlider').step=cap.focusDistance.step||0.01;$('focusSlider').value=set.focusDistance||cap.focusDistance.min||0;$('focusOutput').textContent=parseFloat($('focusSlider').value).toFixed(2);}
    updateUI();
};

const releaseCamera = () => {
    if(AppState.mediaStream){AppState.mediaStream.getTracks().forEach(t=>t.stop());logger.log("Camera stream released.");}
    $('videoPreview').srcObject=null;AppState.mediaStream=null;AppState.videoTrack=null;setupCameraControls();
};

const _initCameraWork = async (deviceId) => {
    releaseCamera();
    const constraints = { video: { width: { ideal: 1920, max: 2560 }, height: { ideal: 1080, max: 1440 }, frameRate: { ideal: 24, max: 30 }, facingMode: "environment", audio: false } };
    if(deviceId){constraints.video.deviceId={exact:deviceId};delete constraints.video.facingMode;}
    logger.log(`Attempting camera: ${deviceId||'default'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia(constraints),10000,"Camera access request timed out. Please respond to any permission prompts.");
    const tracks = AppState.mediaStream.getVideoTracks(); if(tracks.length===0)throw new Error("No video tracks found in stream."); AppState.videoTrack=tracks[0];
    logger.log(`Video track acquired: ${AppState.videoTrack.label}`);
    const vidEl=$('videoPreview'); vidEl.srcObject=AppState.mediaStream;
    await promiseWithTimeout(new Promise((res,rej)=>{const ol=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;res();};const oe=()=>{vidEl.onloadedmetadata=null;vidEl.onerror=null;rej(new Error("Video element failed to load stream."));};vidEl.onloadedmetadata=ol;vidEl.onerror=oe;}),5000,"Video stream metadata loading timed out.");
    logger.success(`Camera active: ${AppState.videoTrack.label||'N/A'}`); setupCameraControls();
};

const listCameras = async () => {
    if(AppState.isInitializingCamera){logger.log("listCameras skipped: initialization already in progress.");return;}
    AppState.isInitializingCamera=true; updateStatus("Initializing camera...", 'info', true);
    try{
        logger.log("Verifying camera permissions...");
        try{const ps=await promiseWithTimeout(navigator.mediaDevices.getUserMedia({video:true,audio:false}),8000,"Camera permission check timed out.");ps.getTracks().forEach(t=>t.stop());logger.log("Preliminary camera permission check passed.");}
        catch(pErr){
            logger.error("Preliminary camera permission check failed.", pErr);
            let m=`Could not verify camera permissions.`;
            if(pErr.name==="NotAllowedError"||pErr.name==="PermissionDeniedError")m="Camera access denied.<br>Please allow camera access in your browser settings and refresh the page.";
            else if(pErr.message.includes("timed out"))m="Camera permission check timed out.<br>Please respond to any browser prompts, then refresh.";
            else m = `Camera permission error: ${pErr.name || pErr.message}`;
            updateStatus(m,'critical'); throw pErr;
        }
        logger.log("Enumerating video devices...");
        const devs=await navigator.mediaDevices.enumerateDevices(); const vidDevs=devs.filter(d=>d.kind==='videoinput');
        const camSel=$('cameraSelect');camSel.innerHTML='';
        if(vidDevs.length===0){logger.error("No video input devices found after enumeration.");updateStatus("No cameras found on this device.",'critical');AppState.cameraCapabilities.hasMultipleCameras=false;throw new Error("No video devices found.");}
        logger.log(`Found ${vidDevs.length} video devices.`);AppState.cameraCapabilities.hasMultipleCameras=vidDevs.length>1;
        vidDevs.forEach(d=>{const o=document.createElement('option');o.value=d.deviceId;o.text=d.label||`Camera ${camSel.options.length+1}`;camSel.appendChild(o);});
        let selDevId=vidDevs[0].deviceId; try{const lId=localStorage.getItem("TV_LAST_CAM");if(lId&&vidDevs.some(d=>d.deviceId===lId))selDevId=lId;else{const eC=vidDevs.find(d=>d.label.toLowerCase().includes('back')||d.label.toLowerCase().includes('environment'));if(eC)selDevId=eC.deviceId;}}catch(e){logger.error("localStorage error (last cam).",e);}
        camSel.value=selDevId;
        camSel.onchange=()=>{if(AppState.isInitializingCamera)return;try{localStorage.setItem("TV_LAST_CAM",camSel.value);}catch(e){logger.error("localStorage error (save cam).",e);}listCameras();};
        await _initCameraWork(selDevId);
    }catch(err){
        logger.error(`listCameras main process error: ${err.message}`,err);
        if(!AppState.videoTrack && !document.querySelector('.critical-message-overlay.visible')){
            let uMsg=`Failed to initialize camera system.`;
            if(err.name==="NotFoundError"||err.name==="DevicesNotFoundError"||err.message.includes("No video devices"))uMsg="No suitable camera found on device.";
            else if(err.name==="OverconstrainedError"||err.name==="ConstraintNotSatisfiedError")uMsg="Camera does not support requested settings.";
            else if(err.message.includes("timed out"))uMsg=err.message;
            else if(err.message && !(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg=`Camera error: ${err.message.substring(0,60)}`;
            else if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError")) uMsg = "An unknown error occurred with the camera.";
            if (!(err.name==="NotAllowedError"||err.name==="PermissionDeniedError" || (err.message.includes("timed out") && document.querySelector('.critical-message-overlay.visible')))) {
                updateStatus(uMsg,'error');
            }
        }
        releaseCamera();
    }finally{AppState.isInitializingCamera=false;updateUI();}
};

const captureImage = () => {
    const video = $('videoPreview');
    if (!video.videoWidth || !AppState.videoTrack || AppState.isInitializingCamera) { logger.error("Video not ready for capture."); return null; }
    const sourceCanvas = document.createElement('canvas'); sourceCanvas.width = video.videoWidth; sourceCanvas.height = video.videoHeight;
    const ctxS = sourceCanvas.getContext('2d'); let effDigZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) effDigZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) effDigZoom = AppState.currentZoom;
    const cw = video.videoWidth/effDigZoom, ch = video.videoHeight/effDigZoom, cx = (video.videoWidth-cw)/2, cy = (video.videoHeight-ch)/2;
    ctxS.drawImage(video, cx, cy, cw, ch, 0, 0, sourceCanvas.width, sourceCanvas.height);
    const MAX_DIMENSION = 1024; let tW = sourceCanvas.width, tH = sourceCanvas.height;
    if (tW > MAX_DIMENSION || tH > MAX_DIMENSION) { if (tW > tH) { tH = Math.round(tH * (MAX_DIMENSION / tW)); tW = MAX_DIMENSION; } else { tW = Math.round(tW * (MAX_DIMENSION / tH)); tH = MAX_DIMENSION; } }
    const finalCanvas = document.createElement('canvas'); finalCanvas.width = tW; finalCanvas.height = tH;
    const ctxF = finalCanvas.getContext('2d'); ctxF.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 0, 0, tW, tH);
    const imageDataUrl = finalCanvas.toDataURL('image/jpeg', 0.85);
    logger.log(`Image captured (sent: ${tW}x${tH}, size: ${Math.round(imageDataUrl.length/1024)}KB).`, {originalRes: `${video.videoWidth}x${video.videoHeight}`});
    return imageDataUrl;
};

const solveMathProblem = async (imageDataUrl) => {
    if(!AppState.apiKey)throw new Error("API Key is missing."); logger.log("Sending image to OpenAI (gpt-4o)...",{imageSizeKB:Math.round(imageDataUrl.length/1024)});
    const newPrompt = `You are an advanced AI math and logic problem solver. Analyze the image thoroughly.
Identify the core question or task. This could be:
1. A direct math problem requiring a numerical answer.
2. A word problem requiring setup and then a numerical answer.
3. A conceptual math question requiring an explanation or a true/false type answer.
4. A request to describe how to solve a problem or outline logic for a program related to a mathematical concept.
5. A logic puzzle.

Provide a clear, step-by-step explanation of your thinking process to address the identified question or task.
- If a specific numerical answer is appropriate and derivable, ensure your explanation leads to it and conclude with a separate line: 'Final Answer: [your numerical answer]'.
- If the task is conceptual or requires a descriptive answer (e.g., explaining a theorem, outlining program logic, true/false with reasoning), provide that detailed explanation as the main part of your response.
- If the image is unreadable, or no clear question/problem can be discerned that you can confidently address, state 'Image is unreadable or no clear problem detected.' as your primary response.
Be comprehensive in your explanation. Structure your response clearly.`;
    const payload={model:"gpt-4o",max_tokens:1500,messages:[{role:"user",content:[
        {type:"text",text:newPrompt},
        {type:"image_url",image_url:{url:imageDataUrl,detail:"high"}}]}]};
    const response=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${AppState.apiKey}`},body:JSON.stringify(payload)});
    if(!response.ok){const d=await response.json().catch(()=>({error:{message:`HTTP ${response.status}`}}));const m=d.error?.message||`HTTP ${response.status}`;
        if(response.status===401)throw new Error("Invalid OpenAI API Key (401).");
        if(response.status===429){logger.error("OpenAI rate limit. Retrying...",d);await new Promise(rs=>setTimeout(rs,7000));if(!AppState.isProcessing)throw new Error("Stopped during retry.");return solveMathProblem(imageDataUrl);}
        throw new Error(`OpenAI API Error: ${m}`);}
    const result=await response.json(); logger.log("OpenAI response received (gpt-4o).",result.usage);
    const fullText=result.choices?.[0]?.message?.content?.trim() || "No content received from AI.";
    let numericAnswer = null; const lines = fullText.split('\n');
    const lastLineWithAnswer = lines.find(line => line.startsWith("Final Answer:"));
    if (lastLineWithAnswer) { const answerMatch = lastLineWithAnswer.match(/Final Answer:\s*(\-?\d+(\.\d+)?)/); if (answerMatch) numericAnswer = answerMatch[1]; }
    const lowerContent = fullText.toLowerCase();
    if (lowerContent.includes("no clear problem detected")) return { fullText, numericAnswer: null, statusMessage: "AI: No clear math problem detected." };
    if (lowerContent.includes("image is unreadable")) return { fullText, numericAnswer: null, statusMessage: "AI: Image is unreadable." };
    if (numericAnswer) return { fullText, numericAnswer, statusMessage: `Solved: ${numericAnswer}` };
    return { fullText, numericAnswer: null, statusMessage: "AI response received (see log)." };
};

const processFrame = async () => {
    if(!AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack){if(AppState.isProcessing)logger.log("Process frame skipped (conditions not met).");updateUI();return;}
    updateStatus("Capturing...", 'info', true); const imgData=captureImage();
    if(!imgData){logger.error("Image capture failed for processing.");if(AppState.isProcessing)AppState.captureTimeout=setTimeout(processFrame,3500);updateStatus("Capture failed.",'error');updateUI();return;}
    try{
        updateStatus("Analyzing with AI (gpt-4o)...", 'info', true);
        const{fullText,numericAnswer,statusMessage}=await solveMathProblem(imgData);
        logger.log(`AI Response: ${statusMessage}`, { fullAIResponseForVerbose: $('verboseLogCheck').checked ? fullText : "Verbose logging off" });
        if(numericAnswer){
            logger.success(`Extracted Numeric Solution: ${numericAnswer}`); updateStatus(`Answer: ${numericAnswer}`,'success');
            showToast(`Answer: ${numericAnswer}`,'success',5000);
            try{speechSynthesis.speak(new SpeechSynthesisUtterance(numericAnswer));}catch(e){logger.error("Speech synthesis failed.",e);}
        }else{
            logger.log(statusMessage||"AI provided no numeric answer."); updateStatus(statusMessage.length > 60 ? statusMessage.substring(0, 57) + "..." : statusMessage,'info');
            showToast(statusMessage.length > 40 ? statusMessage.substring(0, 37) + "..." : statusMessage,'info',4000);
        }
    }catch(err){
        logger.error(`Processing error: ${err.message}`,err);
        const isAPIKeyError = err.message.includes("API Key");
        if(isAPIKeyError){if(AppState.isProcessing)$('stopBtn').click(); updateStatus(`API Key Error. Please verify your key.`, 'critical');}
        else{updateStatus(`Error: ${err.message.substring(0,60)}...`,'error');}
    }finally{
        if(AppState.isProcessing){
            if (AppState.videoTrack && !AppState.isInitializingCamera) { updateStatus("Ready for next. Aim.", 'info', false); }
            AppState.captureTimeout=setTimeout(processFrame,4500);
        }else{ updateUI(); }
    }
};

const updateZoomTypeIndicator = () => {
    const ind=$('zoomType');if(AppState.cameraCapabilities.zoom&&AppState.currentZoom>AppState.cameraCapabilities.zoom.max){ind.textContent='(Digital)';ind.style.color='var(--hi)';}
    else if(AppState.cameraCapabilities.zoom){ind.textContent='(Optical)';ind.style.color='var(--succ)';}else{ind.textContent='';}
};
const toggleLogPanel = () => { AppState.isLogVisible=!AppState.isLogVisible; $('logPanel').classList.toggle('visible',AppState.isLogVisible); updateUI(); };

// --- Event Listeners ---
$('saveKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;const kI=$('apiKey').value.trim();if(kI.startsWith("sk-")){AppState.apiKey=kI;try{localStorage.setItem("TV_API_KEY",kI);}catch(e){logger.error("localStorage error (save key).",e);}logger.success("API Key Saved!");if(!AppState.videoTrack && !AppState.isInitializingCamera){listCameras();}updateUI();}else{logger.error("Invalid API Key format. Must start with 'sk-'.");}};
$('changeKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;$('apiKeyEntryRow').classList.remove('hidden-control');$('apiKeyDisplayRow').classList.add('hidden-control');$('apiKey').value=AppState.apiKey;$('apiKey').focus();updateUI();};
$('clearKeyBtn').onclick=()=>{if(AppState.isInitializingCamera||AppState.isProcessing)return;logger.log("Clearing API Key.");AppState.apiKey="";try{localStorage.removeItem("TV_API_KEY");}catch(e){logger.error("localStorage error (clear key).",e);}$('apiKey').value="";if(AppState.isProcessing)$('stopBtn').click();releaseCamera();logger.success("API Key Cleared.");updateStatus("API Key cleared. Enter new key.", 'info');updateUI();};
$('zoomSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;const z=parseFloat(e.target.value);$('zoomOutput').textContent=z.toFixed(1);AppState.currentZoom=z;updateZoomTypeIndicator();if(AppState.videoTrack&&AppState.cameraCapabilities.zoom&&z<=AppState.cameraCapabilities.zoom.max)AppState.videoTrack.applyConstraints({advanced:[{zoom:z}]}).catch(err=>logger.error(`Hardware zoom error`,err));};
$('focusSlider').oninput=(e)=>{if(AppState.isInitializingCamera||!AppState.videoTrack)return;if(AppState.videoTrack&&AppState.cameraCapabilities.focus){const f=parseFloat(e.target.value);$('focusOutput').textContent=f.toFixed(2);AppState.videoTrack.applyConstraints({advanced:[{focusMode:'manual',focusDistance:f}]}).catch(err=>logger.error(`Focus error`,err));}};
$('startBtn').onclick=()=>{if(AppState.isProcessing||AppState.isInitializingCamera||!AppState.videoTrack||!AppState.apiKey)return;AppState.isProcessing=true;logger.log("Processing started by user.");updateStatus("Starting...",'info',true);updateUI();processFrame();};
$('stopBtn').onclick=()=>{if(!AppState.isProcessing)return;AppState.isProcessing=false;clearTimeout(AppState.captureTimeout);logger.log("Processing stopped by user.");updateStatus("Stopped.",'info');updateUI();};
$('copyLogBtn').onclick=async()=>{const logTxt=$('logTextarea').value;if(!logTxt.trim()){showToast("Log is empty.",'info');return;}try{await navigator.clipboard.writeText(logTxt);logger.success("Log copied to clipboard.");}catch(err){logger.error("Failed to copy log. Select manually.",err);$('logTextarea').select();$('logTextarea').setSelectionRange(0,999999);showToast("Log selected for manual copy.",'info');}updateUI();};
$('verboseLogCheck').onchange=()=>{logger.log(`Verbose logging ${$('verboseLogCheck').checked?'enabled':'disabled'}.`);try{localStorage.setItem("TV_VERBOSE_LOG",$('verboseLogCheck').checked?'true':'false');}catch(e){logger.error("localStorage error (verbose).",e);}};
$('toggleLogBtn').onclick = toggleLogPanel;

document.addEventListener('DOMContentLoaded',()=>{
    updateStatus("Initializing app...", 'info'); // Initial status
    try{AppState.apiKey=localStorage.getItem("TV_API_KEY")||"";}catch(e){logger.error("localStorage error (load key).",e);AppState.apiKey="";}
    try{$('verboseLogCheck').checked=localStorage.getItem("TV_VERBOSE_LOG")==='true';}catch(e){logger.error("localStorage error (load verbose).",e);}
    if(AppState.apiKey){
        listCameras();
    } else {
        updateStatus("Welcome!<br>Please enter OpenAI API Key to begin.", 'info'); // Use status bar, not critical overlay
    }
    updateUI();
});
document.addEventListener("visibilitychange",()=>{
    if(document.visibilityState==='hidden'){
        if(AppState.isProcessing){$('stopBtn').click();logger.log("App hidden, processing stopped.");}
        if(AppState.videoTrack)releaseCamera(); updateUI();
    }else if(document.visibilityState==='visible'){
        if(AppState.apiKey && !AppState.videoTrack && !AppState.isInitializingCamera){
            logger.log("App visible, attempting to re-initialize camera.");listCameras();
        }
    }
});
window.addEventListener('beforeunload',()=>{releaseCamera();});

</script>
</body>
</html>
