<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,maximum-scale=1">
    <meta name="theme-color" content="#1e1e1e">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="AI-powered math problem solver optimized for Samsung Galaxy S23 Ultra">
    <title>Traveler Vision Â· Math AI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js" defer></script>
    <style>
        :root {
            /* Material Design 3 Color Tokens - Dark Theme */
            --md-sys-color-primary: #7db4ff;
            --md-sys-color-on-primary: #003258;
            --md-sys-color-primary-container: #004a7c;
            --md-sys-color-on-primary-container: #c5e7ff;
            --md-sys-color-secondary: #b8c8da;
            --md-sys-color-on-secondary: #233240;
            --md-sys-color-secondary-container: #394857;
            --md-sys-color-on-secondary-container: #d4e4f6;
            --md-sys-color-tertiary: #d0bcff;
            --md-sys-color-on-tertiary: #36245c;
            --md-sys-color-surface: #101418;
            --md-sys-color-on-surface: #e1e2e8;
            --md-sys-color-surface-variant: #42474e;
            --md-sys-color-on-surface-variant: #c2c7cf;
            --md-sys-color-outline: #8c9199;
            --md-sys-color-outline-variant: #42474e;
            --md-sys-color-surface-container-lowest: #0b0e13;
            --md-sys-color-surface-container-low: #191c20;
            --md-sys-color-surface-container: #1d2024;
            --md-sys-color-surface-container-high: #272a2f;
            --md-sys-color-surface-container-highest: #32353a;
            --md-sys-color-error: #ffb4ab;
            --md-sys-color-on-error: #690005;
            --md-sys-color-error-container: #93000a;
            --md-sys-color-on-error-container: #ffdad6;
            --md-sys-color-success: #69db7c;
            --md-sys-color-on-success: #003912;

            /* Elevation and Shadows */
            --md-sys-elevation-level0: none;
            --md-sys-elevation-level1: 0 1px 2px 0 rgba(0, 0, 0, 0.3), 0 1px 3px 1px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level2: 0 1px 2px 0 rgba(0, 0, 0, 0.3), 0 2px 6px 2px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level3: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 4px 8px 3px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level4: 0 2px 3px 0 rgba(0, 0, 0, 0.3), 0 6px 10px 4px rgba(0, 0, 0, 0.15);
            --md-sys-elevation-level5: 0 4px 4px 0 rgba(0, 0, 0, 0.3), 0 8px 12px 6px rgba(0, 0, 0, 0.15);

            /* Typography Scale */
            --md-sys-typescale-display-large-font-size: 57px;
            --md-sys-typescale-display-large-line-height: 64px;
            --md-sys-typescale-headline-large-font-size: 32px;
            --md-sys-typescale-headline-large-line-height: 40px;
            --md-sys-typescale-title-large-font-size: 22px;
            --md-sys-typescale-title-large-line-height: 28px;
            --md-sys-typescale-title-medium-font-size: 16px;
            --md-sys-typescale-title-medium-line-height: 24px;
            --md-sys-typescale-body-large-font-size: 16px;
            --md-sys-typescale-body-large-line-height: 24px;
            --md-sys-typescale-body-medium-font-size: 14px;
            --md-sys-typescale-body-medium-line-height: 20px;
            --md-sys-typescale-label-large-font-size: 14px;
            --md-sys-typescale-label-large-line-height: 20px;

            /* Motion */
            --md-sys-motion-duration-short1: 50ms;
            --md-sys-motion-duration-short2: 100ms;
            --md-sys-motion-duration-short3: 150ms;
            --md-sys-motion-duration-short4: 200ms;
            --md-sys-motion-duration-medium1: 250ms;
            --md-sys-motion-duration-medium2: 300ms;
            --md-sys-motion-duration-medium3: 350ms;
            --md-sys-motion-duration-medium4: 400ms;
            --md-sys-motion-duration-long1: 450ms;
            --md-sys-motion-duration-long2: 500ms;
            --md-sys-motion-duration-long3: 550ms;
            --md-sys-motion-duration-long4: 600ms;

            --md-sys-motion-easing-standard: cubic-bezier(0.2, 0, 0, 1);
            --md-sys-motion-easing-emphasized: cubic-bezier(0.2, 0, 0, 1);
            --md-sys-motion-easing-emphasized-decelerate: cubic-bezier(0.05, 0.7, 0.1, 1);
            --md-sys-motion-easing-emphasized-accelerate: cubic-bezier(0.3, 0, 0.8, 0.15);

            /* Galaxy S23 Ultra Specific */
            --device-width: 411px;
            --device-height: 914px;
            --status-bar-height: 44px;
            --navigation-bar-height: 48px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        input, textarea, select {
            -webkit-user-select: text;
            user-select: text;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', -apple-system, system-ui, sans-serif;
            font-size: var(--md-sys-typescale-body-medium-font-size);
            line-height: var(--md-sys-typescale-body-medium-line-height);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none;
        }

        /* App Container */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            background: var(--md-sys-color-surface);
            position: relative;
            overflow: hidden;
        }

        /* Top App Bar */
        .top-app-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--md-sys-color-surface-container);
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            height: 64px;
            flex-shrink: 0;
            z-index: 100;
        }

        .app-title {
            font-size: var(--md-sys-typescale-title-large-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
            letter-spacing: 0.5px;
        }

        .top-app-bar-actions {
            display: flex;
            gap: 8px;
        }

        /* Material Design 3 Buttons */
        .md-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 40px;
            padding: 0 24px;
            border-radius: 20px;
            font-size: var(--md-sys-typescale-label-large-font-size);
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
            position: relative;
            overflow: hidden;
            min-width: 64px;
            text-transform: none;
            letter-spacing: 0.1px;
            outline: none;
        }

        .md-button:focus-visible {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 2px;
        }

        .md-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: currentColor;
            opacity: 0;
            transition: opacity var(--md-sys-motion-duration-short1) var(--md-sys-motion-easing-standard);
            border-radius: inherit;
        }

        .md-button:hover::before {
            opacity: 0.08;
        }

        .md-button:active::before {
            opacity: 0.12;
        }

        .md-button.filled {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            box-shadow: var(--md-sys-elevation-level0);
        }

        .md-button.filled:hover {
            box-shadow: var(--md-sys-elevation-level1);
        }

        .md-button.tonal {
            background: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .md-button.outlined {
            background: transparent;
            color: var(--md-sys-color-primary);
            border: 1px solid var(--md-sys-color-outline);
        }

        .md-button.text {
            background: transparent;
            color: var(--md-sys-color-primary);
            min-width: 48px;
            padding: 0 12px;
        }

        .md-button:disabled {
            background: var(--md-sys-color-on-surface);
            color: var(--md-sys-color-surface);
            opacity: 0.38;
            cursor: not-allowed;
        }

        .md-button:disabled::before {
            display: none;
        }

        /* Icon Buttons */
        .md-icon-button {
            width: 48px;
            height: 48px;
            border-radius: 24px;
            border: none;
            background: transparent;
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
            position: relative;
            overflow: hidden;
            outline: none;
        }

        .md-icon-button:focus-visible {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 2px;
        }

        .md-icon-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: currentColor;
            opacity: 0;
            transition: opacity var(--md-sys-motion-duration-short1) var(--md-sys-motion-easing-standard);
            border-radius: inherit;
        }

        .md-icon-button:hover::before {
            opacity: 0.08;
        }

        .md-icon-button:active::before {
            opacity: 0.12;
        }

        /* Camera Preview Container */
        .camera-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--md-sys-color-surface-container-lowest);
            overflow: hidden;
            position: relative;
        }

        .camera-preview {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .camera-viewport {
            width: 100%;
            height: 100%;
            max-width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            background: #000;
            border-radius: 0;
        }

        /* Overlay Elements */
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            z-index: 10;
        }

        .overlay-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 16px;
            flex-shrink: 0;
        }

        .overlay-center {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            flex-shrink: 0;
        }

        /* Viewfinder Grid */
        .viewfinder-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.3;
            pointer-events: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

        .grid-line.horizontal {
            width: 100%;
            height: 1px;
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
        }

        .grid-line:nth-child(1) { top: 33.33%; }
        .grid-line:nth-child(2) { top: 66.66%; }
        .grid-line:nth-child(3) { left: 33.33%; }
        .grid-line:nth-child(4) { left: 66.66%; }

        /* Status Indicators */
        .status-chip {
            display: inline-flex;
            align-items: center;
            padding: 6px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            background: var(--md-sys-color-surface-container-high);
            color: var(--md-sys-color-on-surface);
            box-shadow: var(--md-sys-elevation-level1);
            pointer-events: auto;
        }

        .status-chip.success {
            background: var(--md-sys-color-success);
            color: var(--md-sys-color-on-success);
        }

        .status-chip.error {
            background: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }

        .status-chip.processing {
            background: var(--md-sys-color-tertiary);
            color: var(--md-sys-color-on-tertiary);
        }

        /* Loading Indicators */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all var(--md-sys-motion-duration-medium2) var(--md-sys-motion-easing-standard);
            z-index: 20;
        }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid var(--md-sys-color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: white;
            font-size: var(--md-sys-typescale-body-large-font-size);
            font-weight: 500;
            text-align: center;
        }

        /* Floating Action Button */
        .fab {
            position: absolute;
            bottom: 32px;
            right: 50%;
            transform: translateX(50%);
            width: 96px;
            height: 96px;
            border-radius: 28px;
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--md-sys-elevation-level3);
            transition: all var(--md-sys-motion-duration-short4) var(--md-sys-motion-easing-emphasized);
            z-index: 50;
            outline: none;
        }

        .fab:focus-visible {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 4px;
        }

        .fab:hover {
            transform: translateX(50%) scale(1.05);
            box-shadow: var(--md-sys-elevation-level4);
        }

        .fab:active {
            transform: translateX(50%) scale(0.95);
        }

        .fab:disabled {
            background: var(--md-sys-color-on-surface);
            color: var(--md-sys-color-surface);
            opacity: 0.38;
            cursor: not-allowed;
            transform: translateX(50%);
        }

        /* Snackbar */
        .snackbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--md-sys-color-surface-container-high);
            color: var(--md-sys-color-on-surface);
            padding: 14px 16px;
            border-radius: 4px;
            font-size: var(--md-sys-typescale-body-medium-font-size);
            box-shadow: var(--md-sys-elevation-level3);
            z-index: 1000;
            max-width: calc(100vw - 48px);
            min-width: 344px;
            transition: transform var(--md-sys-motion-duration-medium4) var(--md-sys-motion-easing-emphasized);
        }

        .snackbar.show {
            transform: translateX(-50%) translateY(0);
        }

        .snackbar.success {
            background: var(--md-sys-color-success);
            color: var(--md-sys-color-on-success);
        }

        .snackbar.error {
            background: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }

        /* Bottom Sheet */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--md-sys-color-surface-container-high);
            border-top-left-radius: 28px;
            border-top-right-radius: 28px;
            transform: translateY(100%);
            transition: transform var(--md-sys-motion-duration-long2) var(--md-sys-motion-easing-emphasized);
            z-index: 200;
            max-height: 80vh;
            overflow: hidden;
        }

        .bottom-sheet.visible {
            transform: translateY(0);
        }

        .bottom-sheet-handle {
            width: 32px;
            height: 4px;
            background: var(--md-sys-color-outline-variant);
            border-radius: 2px;
            margin: 12px auto 20px;
        }

        .bottom-sheet-content {
            padding: 0 24px 24px;
            overflow-y: auto;
            max-height: calc(80vh - 40px);
        }

        /* Settings Panel */
        .settings-panel {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
        }

        .setting-label {
            font-size: var(--md-sys-typescale-body-large-font-size);
            color: var(--md-sys-color-on-surface);
            flex: 1;
        }

        .setting-value {
            font-size: var(--md-sys-typescale-body-medium-font-size);
            color: var(--md-sys-color-on-surface-variant);
            margin-left: 16px;
        }

        .control-label {
            font-size: var(--md-sys-typescale-title-medium-font-size);
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
            margin-bottom: 8px;
            display: block;
        }

        /* Material Design 3 Text Fields */
        .md-text-field {
            position: relative;
            margin-bottom: 16px;
        }

        .md-text-field input {
            width: 100%;
            height: 56px;
            padding: 16px;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: 4px;
            background: var(--md-sys-color-surface-container-highest);
            color: var(--md-sys-color-on-surface);
            font-size: var(--md-sys-typescale-body-large-font-size);
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
            outline: none;
        }

        .md-text-field input:focus {
            border-color: var(--md-sys-color-primary);
            border-width: 2px;
            box-shadow: 0 0 0 1px var(--md-sys-color-primary);
        }

        .md-text-field label {
            position: absolute;
            top: 16px;
            left: 16px;
            color: var(--md-sys-color-on-surface-variant);
            font-size: var(--md-sys-typescale-body-large-font-size);
            pointer-events: none;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
        }

        .md-text-field input:focus + label,
        .md-text-field input:not(:placeholder-shown) + label {
            top: -8px;
            left: 12px;
            font-size: 12px;
            background: var(--md-sys-color-surface-container-highest);
            padding: 0 4px;
            color: var(--md-sys-color-primary);
        }

        /* Drop Down Menu */
        .md-select {
            position: relative;
            width: 100%;
        }

        .md-select select {
            width: 100%;
            height: 56px;
            padding: 16px;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: 4px;
            background: var(--md-sys-color-surface-container-highest);
            color: var(--md-sys-color-on-surface);
            font-size: var(--md-sys-typescale-body-large-font-size);
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
        }

        .md-select select:focus {
            border-color: var(--md-sys-color-primary);
            border-width: 2px;
            box-shadow: 0 0 0 1px var(--md-sys-color-primary);
        }

        .md-select::after {
            content: 'â–¼';
            position: absolute;
            top: 50%;
            right: 16px;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--md-sys-color-on-surface-variant);
        }

        /* Sliders */
        .md-slider {
            position: relative;
            width: 100%;
            height: 44px;
            margin: 8px 0;
        }

        .md-slider input[type="range"] {
            width: 100%;
            height: 44px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            outline: none;
        }

        .md-slider input[type="range"]:focus {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 2px;
        }

        .md-slider input[type="range"]::-webkit-slider-track {
            height: 4px;
            border-radius: 2px;
            background: var(--md-sys-color-outline-variant);
        }

        .md-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 12px;
            background: var(--md-sys-color-primary);
            border: 2px solid var(--md-sys-color-surface);
            box-shadow: var(--md-sys-elevation-level1);
            cursor: pointer;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
        }

        .md-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: var(--md-sys-elevation-level2);
        }

        .md-slider input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
        }

        /* Switch Component */
        .md-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 32px;
        }
        
        .md-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .md-switch-track {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--md-sys-color-outline);
            border-radius: 16px;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
        }
        
        .md-switch-thumb {
            position: absolute;
            cursor: pointer;
            top: 2px;
            left: 2px;
            width: 28px;
            height: 28px;
            background-color: var(--md-sys-color-outline);
            border-radius: 14px;
            transition: all var(--md-sys-motion-duration-short2) var(--md-sys-motion-easing-standard);
            box-shadow: var(--md-sys-elevation-level1);
        }
        
        .md-switch input:checked + .md-switch-track {
            background-color: var(--md-sys-color-primary);
        }
        
        .md-switch input:checked + .md-switch-track + .md-switch-thumb {
            background-color: var(--md-sys-color-on-primary);
            transform: translateX(20px);
        }

        .md-switch input:focus-visible + .md-switch-track {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 2px;
        }

        /* Answer Display */
        .answer-display {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            padding: 16px 24px;
            border-radius: 16px;
            text-align: center;
            font-size: var(--md-sys-typescale-headline-large-font-size);
            font-weight: 600;
            letter-spacing: 2px;
            box-shadow: var(--md-sys-elevation-level2);
            border: 2px solid var(--md-sys-color-primary);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Hidden Elements */
        .hidden {
            display: none !important;
        }

        .invisible {
            opacity: 0;
            visibility: hidden;
        }

        /* Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Error State */
        .error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            padding: 24px;
            text-align: center;
        }

        .error-message {
            color: var(--md-sys-color-error);
            font-size: var(--md-sys-typescale-body-large-font-size);
            margin-bottom: 16px;
        }

        .error-details {
            color: var(--md-sys-color-on-surface-variant);
            font-size: var(--md-sys-typescale-body-medium-font-size);
            margin-bottom: 24px;
        }

        /* Responsive Design for Galaxy S23 Ultra */
        @media screen and (max-width: 428px) {
            .snackbar {
                min-width: calc(100vw - 48px);
            }
            
            .fab {
                width: 80px;
                height: 80px;
                border-radius: 24px;
            }
        }

        /* Dark Mode Optimizations for AMOLED */
        @media (prefers-color-scheme: dark) {
            .camera-preview {
                background: #000000;
            }
        }

        /* Print Styles */
        @media print {
            .app {
                display: none;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High Contrast Mode */
        @media (prefers-contrast: high) {
            :root {
                --md-sys-color-outline: #ffffff;
                --md-sys-color-outline-variant: #cccccc;
            }
        }
    </style>
</head>
<body>
    <div class="app" id="app">
        <!-- Top App Bar -->
        <header class="top-app-bar">
            <h1 class="app-title">Traveler Vision Â· Math AI</h1>
            <div class="top-app-bar-actions">
                <button class="md-icon-button" id="settingsBtn" aria-label="Open settings" tabindex="0">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.82,11.69,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Camera Container -->
        <main class="camera-container">
            <div class="camera-preview">
                <video id="cameraVideo" class="camera-viewport" autoplay muted playsinline aria-label="Camera preview"></video>
                
                <!-- Camera Overlay -->
                <div class="camera-overlay">
                    <div class="overlay-top">
                        <div class="status-chip" id="modelChip" role="status" aria-label="AI model">o3</div>
                        <div class="status-chip hidden" id="statusChip" role="status" aria-label="App status">Ready</div>
                    </div>
                    
                    <div class="overlay-center">
                        <div class="answer-display hidden" id="answerDisplay" role="alert" aria-live="polite"></div>
                    </div>
                    
                    <div class="overlay-bottom">
                        <div class="status-chip" id="cameraStatus" role="status" aria-label="Camera status">Initializing...</div>
                    </div>
                </div>

                <!-- Viewfinder Grid -->
                <div class="viewfinder-grid" id="viewfinderGrid" aria-hidden="true">
                    <div class="grid-line horizontal"></div>
                    <div class="grid-line horizontal"></div>
                    <div class="grid-line vertical"></div>
                    <div class="grid-line vertical"></div>
                </div>

                <!-- Loading Overlay -->
                <div class="loading-overlay" id="loadingOverlay" role="status" aria-live="polite">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <div class="loading-text" id="loadingText">Processing...</div>
                </div>
            </div>

            <!-- Primary Action Button -->
            <button class="fab" id="captureBtn" disabled aria-label="Capture and analyze math problem" tabindex="0">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                    <circle cx="12" cy="12" r="3.2"/>
                    <path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                </svg>
            </button>
        </main>

        <!-- Settings Bottom Sheet -->
        <div class="bottom-sheet" id="settingsSheet" role="dialog" aria-labelledby="settingsTitle" aria-modal="true">
            <div class="bottom-sheet-handle" aria-hidden="true"></div>
            <div class="bottom-sheet-content">
                <div class="settings-panel">
                    <!-- API Key Section -->
                    <div class="setting-group">
                        <h2 class="control-label" id="settingsTitle">OpenAI Configuration</h2>
                        
                        <div class="md-text-field" id="apiKeyField">
                            <input type="password" id="apiKeyInput" placeholder=" " aria-describedby="apiKeyHelp">
                            <label for="apiKeyInput">API Key (sk-...)</label>
                        </div>
                        <div id="apiKeyHelp" class="sr-only">Enter your OpenAI API key starting with sk-</div>
                        
                        <div class="setting-item">
                            <label for="modelSelect" class="setting-label">Model</label>
                            <div class="md-select">
                                <select id="modelSelect" aria-describedby="modelHelp">
                                    <option value="o3">o3 (Recommended)</option>
                                    <option value="o4-mini">o4-mini (Faster)</option>
                                </select>
                            </div>
                        </div>
                        <div id="modelHelp" class="sr-only">Choose the AI model for analyzing problems</div>
                    </div>

                    <!-- Camera Settings -->
                    <div class="setting-group" id="cameraSettings">
                        <h2 class="control-label">Camera Settings</h2>
                        
                        <div class="setting-item" id="cameraSelectItem">
                            <label for="cameraSelect" class="setting-label">Camera</label>
                            <div class="md-select">
                                <select id="cameraSelect" aria-describedby="cameraHelp"></select>
                            </div>
                        </div>
                        <div id="cameraHelp" class="sr-only">Select which camera to use</div>
                        
                        <div class="setting-item" id="zoomControl">
                            <label for="zoomSlider" class="setting-label">Zoom</label>
                            <div class="setting-value" id="zoomValue">1.0x</div>
                        </div>
                        <div class="md-slider">
                            <input type="range" id="zoomSlider" min="1" max="10" step="0.1" value="1" aria-describedby="zoomHelp">
                        </div>
                        <div id="zoomHelp" class="sr-only">Adjust camera zoom level</div>
                        
                        <div class="setting-item" id="focusControl">
                            <label for="focusSlider" class="setting-label">Focus</label>
                            <div class="setting-value" id="focusValue">Auto</div>
                        </div>
                        <div class="md-slider">
                            <input type="range" id="focusSlider" min="0" max="1" step="0.01" value="0" aria-describedby="focusHelp">
                        </div>
                        <div id="focusHelp" class="sr-only">Adjust camera focus distance</div>
                    </div>

                    <!-- App Settings -->
                    <div class="setting-group">
                        <h2 class="control-label">App Settings</h2>
                        
                        <div class="setting-item">
                            <span class="setting-label">Grid Lines</span>
                            <label class="md-switch">
                                <input type="checkbox" id="gridToggle" checked aria-describedby="gridHelp">
                                <span class="md-switch-track"></span>
                                <span class="md-switch-thumb"></span>
                            </label>
                        </div>
                        <div id="gridHelp" class="sr-only">Show camera grid lines for better composition</div>
                        
                        <div class="setting-item">
                            <span class="setting-label">Haptic Feedback</span>
                            <label class="md-switch">
                                <input type="checkbox" id="hapticToggle" checked aria-describedby="hapticHelp">
                                <span class="md-switch-track"></span>
                                <span class="md-switch-thumb"></span>
                            </label>
                        </div>
                        <div id="hapticHelp" class="sr-only">Enable vibration feedback</div>
                        
                        <div class="setting-item">
                            <span class="setting-label">Voice Feedback</span>
                            <label class="md-switch">
                                <input type="checkbox" id="voiceToggle" checked aria-describedby="voiceHelp">
                                <span class="md-switch-track"></span>
                                <span class="md-switch-thumb"></span>
                            </label>
                        </div>
                        <div id="voiceHelp" class="sr-only">Enable voice announcement of answers</div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="setting-group">
                        <button class="md-button filled" id="saveSettingsBtn">Save Settings</button>
                        <button class="md-button outlined" id="clearDataBtn">Clear All Data</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Snackbar -->
    <div class="snackbar" id="snackbar" role="alert" aria-live="polite"></div>

    <!-- Screen Reader Only Text -->
    <div class="sr-only">
        <div id="ariaLiveRegion" aria-live="polite" aria-atomic="true"></div>
    </div>

    <script>
        /**
         * Traveler Vision Math AI - Premium Samsung Galaxy S23 Ultra optimized app
         * A comprehensive, production-ready application for solving math problems using AI
         * 
         * Features:
         * - Material Design 3 UI/UX
         * - Complete camera management with orientation correction
         * - Advanced image processing and optimization
         * - Comprehensive error handling and retry logic
         * - Full accessibility support (WCAG 2.1 compliant)
         * - Samsung Galaxy S23 Ultra specific optimizations
         * - Professional audio feedback system
         * - Haptic feedback patterns
         * - Voice synthesis with repeat functionality
         * - Network status monitoring
         * - Offline capability detection
         * - Memory management and cleanup
         * - Performance optimizations
         * 
         * @author AI Assistant
         * @version 2.0.0
         * @license MIT
         */
        class TravelerVisionApp {
            /**
             * Initialize the Traveler Vision application
             * @constructor
             */
            constructor() {
                // Application state management
                this.state = {
                    apiKey: '',
                    selectedModel: 'o3',
                    isProcessing: false,
                    isInitializing: false,
                    mediaStream: null,
                    videoTrack: null,
                    cameras: [],
                    selectedCamera: null,
                    capabilities: {
                        zoom: null,
                        focus: null
                    },
                    settings: {
                        gridEnabled: true,
                        hapticEnabled: true,
                        voiceEnabled: true
                    },
                    deviceOrientation: 0,
                    retryCount: 0,
                    maxRetries: 3,
                    isOnline: navigator.onLine
                };

                // Audio and timing management
                this.audioContext = null;
                this.sounds = {};
                this.processingTimeout = null;
                this.snackbarTimeout = null;
                this.cameraRetryTimeout = null;
                this.networkRetryTimeout = null;

                // Bind event handlers to preserve context
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
                this.handleBeforeUnload = this.handleBeforeUnload.bind(this);
                this.handleOrientationChange = this.handleOrientationChange.bind(this);
                this.handleOnlineStatus = this.handleOnlineStatus.bind(this);

                // Initialize application
                this.init().catch(error => {
                    console.error('App initialization failed:', error);
                    this.showCriticalError('Failed to initialize app', error.message);
                });
            }

            /**
             * Initialize the application
             * @async
             */
            async init() {
                try {
                    console.log('ðŸš€ Initializing Traveler Vision App...');
                    
                    await this.loadSettings();
                    await this.initAudio();
                    this.bindEvents();
                    
                    if (this.validateApiKey(this.state.apiKey)) {
                        await this.initCamera();
                        await this.requestDeviceOrientationPermission();
                    }
                    
                    this.updateUI();
                    this.showSnackbar('App ready! Aim at any math problem.', 'success');
                    console.log('âœ… App initialization complete');
                    
                } catch (error) {
                    console.error('âŒ App initialization failed:', error);
                    this.showSnackbar('Initialization failed: ' + error.message, 'error');
                }
            }

            /**
             * Validates OpenAI API key format
             * @param {string} apiKey - API key to validate
             * @returns {boolean} True if valid
             */
            validateApiKey(apiKey) {
                const apiKeyPattern = /^sk-[a-zA-Z0-9]{20,}$/;
                return apiKeyPattern.test(apiKey);
            }

            /**
             * Load user settings from localStorage with validation
             * @async
             */
            async loadSettings() {
                try {
                    const settings = {
                        apiKey: localStorage.getItem('tv_api_key') || '',
                        model: localStorage.getItem('tv_model') || 'o3',
                        gridEnabled: localStorage.getItem('tv_grid') !== 'false',
                        hapticEnabled: localStorage.getItem('tv_haptic') !== 'false',
                        voiceEnabled: localStorage.getItem('tv_voice') !== 'false'
                    };

                    // Validate model selection
                    if (settings.model && !['o3', 'o4-mini'].includes(settings.model)) {
                        settings.model = 'o3';
                    }

                    // Update application state
                    this.state.apiKey = settings.apiKey;
                    this.state.selectedModel = settings.model;
                    this.state.settings = {
                        gridEnabled: settings.gridEnabled,
                        hapticEnabled: settings.hapticEnabled,
                        voiceEnabled: settings.voiceEnabled
                    };

                    // Update UI elements safely
                    this.safeUpdateElement('apiKeyInput', 'value', settings.apiKey);
                    this.safeUpdateElement('modelSelect', 'value', settings.model);
                    this.safeUpdateElement('gridToggle', 'checked', settings.gridEnabled);
                    this.safeUpdateElement('hapticToggle', 'checked', settings.hapticEnabled);
                    this.safeUpdateElement('voiceToggle', 'checked', settings.voiceEnabled);
                    this.safeUpdateElement('modelChip', 'textContent', settings.model);
                    
                    this.updateGridVisibility();
                    console.log('âš™ï¸ Settings loaded successfully');
                    
                } catch (error) {
                    console.error('Failed to load settings:', error);
                    // Use defaults if loading fails
                    this.state.settings = {
                        gridEnabled: true,
                        hapticEnabled: true,
                        voiceEnabled: true
                    };
                }
            }

            /**
             * Safely update DOM element property with error handling
             * @param {string} id - Element ID
             * @param {string} property - Property to update
             * @param {*} value - Value to set
             */
            safeUpdateElement(id, property, value) {
                try {
                    const element = document.getElementById(id);
                    if (element && property in element) {
                        element[property] = value;
                    }
                } catch (error) {
                    console.warn(`Failed to update element ${id}:`, error);
                }
            }

            /**
             * Initialize audio system with Tone.js
             * @async
             */
            async initAudio() {
                if (typeof Tone === 'undefined') {
                    console.warn('Tone.js not available - audio feedback disabled');
                    return;
                }
                
                try {
                    // Initialize high-quality audio synthesizers
                    this.sounds = {
                        capture: new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 },
                            volume: -12
                        }).toDestination(),
                        
                        success: new Tone.PolySynth(Tone.Synth, {
                            polyphony: 3,
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3 },
                            volume: -12
                        }).toDestination(),
                        
                        error: new Tone.NoiseSynth({
                            noise: { type: 'brown' },
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 },
                            volume: -18
                        }).toDestination(),
                        
                        processing: new Tone.AMSynth({
                            harmonicity: 1.2,
                            oscillator: { type: 'fmsine' },
                            envelope: { attack: 0.01, decay: 0.1, sustain: 0.01, release: 0.1 },
                            volume: -15
                        }).toDestination()
                    };
                    
                    console.log('ðŸ”Š Audio system initialized successfully');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    this.sounds = {}; // Ensure sounds object exists
                }
            }

            /**
             * Play audio feedback sound
             * @param {string} soundName - Name of sound to play
             * @async
             */
            async playSound(soundName) {
                if (!this.audioContext || !this.sounds[soundName]) return;
                
                try {
                    const now = Tone.now();
                    switch (soundName) {
                        case 'capture':
                            this.sounds.capture.triggerAttackRelease('C5', '8n', now);
                            break;
                        case 'success':
                            this.sounds.success.triggerAttackRelease(['C5', 'E5', 'G5'], '8n', now);
                            break;
                        case 'error':
                            this.sounds.error.triggerAttackRelease('8n', now);
                            break;
                        case 'processing':
                            this.sounds.processing.triggerAttackRelease('A4', '16n', now);
                            break;
                    }
                } catch (error) {
                    console.error('Sound playback failed:', error);
                }
            }

            /**
             * Bind all event listeners with comprehensive error handling
             */
            bindEvents() {
                try {
                    // Settings and capture buttons
                    this.addEventListenerSafe('settingsBtn', 'click', () => this.toggleSettings());
                    this.addEventListenerSafe('captureBtn', 'click', () => this.handleCapture());

                    // API Key input with debouncing
                    let apiKeyTimeout;
                    this.addEventListenerSafe('apiKeyInput', 'input', (e) => {
                        clearTimeout(apiKeyTimeout);
                        apiKeyTimeout = setTimeout(() => {
                            this.state.apiKey = e.target.value.trim();
                            this.updateUI();
                        }, 300);
                    });

                    // Model selection
                    this.addEventListenerSafe('modelSelect', 'change', (e) => {
                        this.state.selectedModel = e.target.value;
                        this.safeUpdateElement('modelChip', 'textContent', e.target.value);
                        this.saveToLocalStorage('tv_model', e.target.value);
                    });

                    // Camera controls
                    this.addEventListenerSafe('cameraSelect', 'change', (e) => {
                        this.switchCamera(e.target.value);
                    });

                    // Zoom slider with throttling
                    let zoomTimeout;
                    this.addEventListenerSafe('zoomSlider', 'input', (e) => {
                        clearTimeout(zoomTimeout);
                        const value = parseFloat(e.target.value);
                        this.safeUpdateElement('zoomValue', 'textContent', `${value.toFixed(1)}x`);
                        zoomTimeout = setTimeout(() => this.adjustZoom(value), 100);
                    });

                    // Focus slider with throttling
                    let focusTimeout;
                    this.addEventListenerSafe('focusSlider', 'input', (e) => {
                        clearTimeout(focusTimeout);
                        const value = parseFloat(e.target.value);
                        this.safeUpdateElement('focusValue', 'textContent', value.toFixed(2));
                        focusTimeout = setTimeout(() => this.adjustFocus(value), 100);
                    });

                    // Settings toggles
                    this.addEventListenerSafe('gridToggle', 'change', (e) => {
                        this.state.settings.gridEnabled = e.target.checked;
                        this.updateGridVisibility();
                        this.saveToLocalStorage('tv_grid', e.target.checked.toString());
                    });

                    this.addEventListenerSafe('hapticToggle', 'change', (e) => {
                        this.state.settings.hapticEnabled = e.target.checked;
                        this.saveToLocalStorage('tv_haptic', e.target.checked.toString());
                    });

                    this.addEventListenerSafe('voiceToggle', 'change', (e) => {
                        this.state.settings.voiceEnabled = e.target.checked;
                        this.saveToLocalStorage('tv_voice', e.target.checked.toString());
                    });

                    // Settings actions
                    this.addEventListenerSafe('saveSettingsBtn', 'click', () => this.saveSettings());
                    this.addEventListenerSafe('clearDataBtn', 'click', () => this.confirmClearData());

                    // Close settings when clicking outside
                    this.addEventListenerSafe('settingsSheet', 'click', (e) => {
                        if (e.target === e.currentTarget) {
                            this.closeSettings();
                        }
                    });

                    // Keyboard navigation
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            this.closeSettings();
                        } else if (e.key === ' ' || e.key === 'Enter') {
                            if (e.target === document.getElementById('captureBtn')) {
                                e.preventDefault();
                                this.handleCapture();
                            }
                        }
                    });

                    // System events
                    document.addEventListener('visibilitychange', this.handleVisibilityChange);
                    window.addEventListener('beforeunload', this.handleBeforeUnload);
                    window.addEventListener('online', this.handleOnlineStatus);
                    window.addEventListener('offline', this.handleOnlineStatus);

                    console.log('ðŸ”— Event listeners bound successfully');

                } catch (error) {
                    console.error('Failed to bind events:', error);
                    this.showCriticalError('Event binding failed', error.message);
                }
            }

            /**
             * Safely add event listener with error handling
             * @param {string} elementId - Element ID
             * @param {string} event - Event type
             * @param {Function} handler - Event handler
             */
            addEventListenerSafe(elementId, event, handler) {
                try {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`Element ${elementId} not found for event binding`);
                    }
                } catch (error) {
                    console.error(`Failed to add event listener to ${elementId}:`, error);
                }
            }

            /**
             * Safely save data to localStorage
             * @param {string} key - Storage key
             * @param {string} value - Value to store
             */
            saveToLocalStorage(key, value) {
                try {
                    localStorage.setItem(key, value);
                } catch (error) {
                    console.warn(`Failed to save to localStorage: ${key}`, error);
                }
            }

            /**
             * Initialize camera system with comprehensive error handling
             * @async
             */
            async initCamera() {
                if (this.state.isInitializing) return;
                
                this.state.isInitializing = true;
                this.updateCameraStatus('Initializing camera...');
                this.showLoading('Initializing camera...');
                this.state.retryCount = 0;

                try {
                    await this.initCameraWithRetry();
                } catch (error) {
                    console.error('âŒ Camera initialization failed:', error);
                    this.updateCameraStatus('Camera failed');
                    this.showSnackbar('Camera initialization failed: ' + this.getErrorMessage(error), 'error');
                } finally {
                    this.state.isInitializing = false;
                    this.hideLoading();
                    this.updateUI();
                }
            }

            /**
             * Initialize camera with exponential backoff retry logic
             * @async
             */
            async initCameraWithRetry() {
                try {
                    // Check camera permissions first
                    try {
                        const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                        if (permissionStatus.state === 'denied') {
                            throw new Error('Camera permission denied. Please allow camera access in browser settings.');
                        }
                    } catch (permError) {
                        console.warn('Permission API not available, proceeding with camera request');
                    }

                    // Get initial permission
                    const stream = await this.promiseWithTimeout(
                        navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: 'environment' },
                            audio: false 
                        }), 
                        10000,
                        'Camera permission request timed out'
                    );
                    
                    stream.getTracks().forEach(track => track.stop());

                    // Enumerate cameras
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.state.cameras = devices.filter(device => 
                        device.kind === 'videoinput' && device.deviceId
                    );

                    if (this.state.cameras.length === 0) {
                        throw new Error('No cameras found on this device');
                    }

                    // Populate camera select
                    this.populateCameraSelect();

                    // Select and start camera
                    const selectedCameraId = this.selectPreferredCamera();
                    await this.startCamera(selectedCameraId);
                    
                } catch (error) {
                    if (this.state.retryCount < this.state.maxRetries) {
                        this.state.retryCount++;
                        console.warn(`Camera init attempt ${this.state.retryCount} failed, retrying:`, error);
                        
                        // Exponential backoff
                        await new Promise(resolve => 
                            setTimeout(resolve, 1000 * Math.pow(2, this.state.retryCount - 1))
                        );
                        return this.initCameraWithRetry();
                    }
                    throw error;
                }
            }

            /**
             * Populate camera selection dropdown
             */
            populateCameraSelect() {
                const cameraSelect = document.getElementById('cameraSelect');
                if (!cameraSelect) return;

                cameraSelect.innerHTML = '';
                
                this.state.cameras.forEach((camera, index) => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });

                console.log(`ðŸ“¹ Found ${this.state.cameras.length} cameras`);
            }

            /**
             * Select preferred camera (back camera if available)
             * @returns {string} Selected camera device ID
             */
            selectPreferredCamera() {
                // Try to use previously saved camera
                const savedCameraId = localStorage.getItem('tv_camera');
                const savedCamera = this.state.cameras.find(c => c.deviceId === savedCameraId);
                if (savedCamera) return savedCameraId;

                // Prefer back camera
                const backCamera = this.state.cameras.find(camera => {
                    const label = camera.label.toLowerCase();
                    return label.includes('back') || 
                           label.includes('environment') || 
                           label.includes('rear') ||
                           label.includes('wide');
                });
                
                const selectedId = backCamera?.deviceId || this.state.cameras[0].deviceId;
                const cameraSelect = document.getElementById('cameraSelect');
                if (cameraSelect) cameraSelect.value = selectedId;
                
                return selectedId;
            }

            /**
             * Start camera with optimal constraints for Galaxy S23 Ultra
             * @param {string} deviceId - Camera device ID
             * @async
             */
            async startCamera(deviceId) {
                try {
                    // Stop existing stream
                    if (this.state.mediaStream) {
                        this.state.mediaStream.getTracks().forEach(track => track.stop());
                    }

                    // Optimal constraints for Galaxy S23 Ultra
                    const constraints = {
                        video: {
                            deviceId: { exact: deviceId },
                            width: { ideal: 1920, min: 1280 },
                            height: { ideal: 1440, min: 960 },
                            aspectRatio: { ideal: 4/3 },
                            frameRate: { ideal: 30, max: 60 }
                        },
                        audio: false
                    };

                    this.state.mediaStream = await this.promiseWithTimeout(
                        navigator.mediaDevices.getUserMedia(constraints),
                        8000,
                        'Camera stream request timed out'
                    );
                    
                    this.state.videoTrack = this.state.mediaStream.getVideoTracks()[0];
                    this.state.selectedCamera = deviceId;

                    // Set video source with error handling
                    const video = document.getElementById('cameraVideo');
                    if (video) {
                        video.srcObject = this.state.mediaStream;
                        
                        // Wait for video to be ready
                        await new Promise((resolve, reject) => {
                            video.onloadedmetadata = resolve;
                            video.onerror = () => reject(new Error('Video load failed'));
                            setTimeout(() => reject(new Error('Video load timeout')), 5000);
                        });
                    }

                    // Setup camera capabilities
                    await this.setupCameraCapabilities();
                    
                    this.updateCameraStatus('Camera active');
                    this.playSound('success');
                    console.log(`âœ… Camera started: ${this.state.videoTrack.label}`);
                    
                } catch (error) {
                    console.error('Failed to start camera:', error);
                    throw error;
                }
            }

            /**
             * Setup camera capabilities (zoom, focus)
             * @async
             */
            async setupCameraCapabilities() {
                if (!this.state.videoTrack) return;

                try {
                    const capabilities = this.state.videoTrack.getCapabilities();
                    const settings = this.state.videoTrack.getSettings();

                    // Setup zoom capabilities
                    if (capabilities.zoom) {
                        this.state.capabilities.zoom = capabilities.zoom;
                        const zoomSlider = document.getElementById('zoomSlider');
                        if (zoomSlider) {
                            zoomSlider.min = capabilities.zoom.min || 1;
                            zoomSlider.max = capabilities.zoom.max || 10;
                            zoomSlider.step = capabilities.zoom.step || 0.1;
                            zoomSlider.value = settings.zoom || capabilities.zoom.min || 1;
                            zoomSlider.disabled = false;
                            
                            this.safeUpdateElement('zoomValue', 'textContent', 
                                `${(settings.zoom || 1).toFixed(1)}x`);
                        }
                        console.log(`ðŸ” Zoom range: ${capabilities.zoom.min}-${capabilities.zoom.max}`);
                    }

                    // Setup focus capabilities
                    if (capabilities.focusMode?.includes('manual') && capabilities.focusDistance) {
                        this.state.capabilities.focus = capabilities.focusDistance;
                        const focusSlider = document.getElementById('focusSlider');
                        if (focusSlider) {
                            focusSlider.min = capabilities.focusDistance.min || 0;
                            focusSlider.max = capabilities.focusDistance.max || 1;
                            focusSlider.step = capabilities.focusDistance.step || 0.01;
                            focusSlider.value = settings.focusDistance || 0;
                            focusSlider.disabled = false;
                            
                            this.safeUpdateElement('focusValue', 'textContent', 
                                settings.focusDistance ? settings.focusDistance.toFixed(2) : 'Auto');
                        }
                        console.log(`ðŸŽ¯ Focus range: ${capabilities.focusDistance.min}-${capabilities.focusDistance.max}`);
                    }
                } catch (error) {
                    console.warn('Failed to setup camera capabilities:', error);
                }
            }

            /**
             * Switch to different camera
             * @param {string} deviceId - New camera device ID
             * @async
             */
            async switchCamera(deviceId) {
                if (this.state.isInitializing || this.state.isProcessing) return;
                
                try {
                    await this.startCamera(deviceId);
                    this.saveToLocalStorage('tv_camera', deviceId);
                    this.showSnackbar('Camera switched successfully', 'success');
                } catch (error) {
                    console.error('Failed to switch camera:', error);
                    this.showSnackbar('Failed to switch camera', 'error');
                }
            }

            /**
             * Adjust camera zoom with haptic feedback
             * @param {number} value - Zoom value
             * @async
             */
            async adjustZoom(value) {
                if (!this.state.videoTrack || !this.state.capabilities.zoom) return;

                try {
                    await this.state.videoTrack.applyConstraints({
                        advanced: [{ zoom: value }]
                    });
                    
                    if (this.state.settings.hapticEnabled && navigator.vibrate) {
                        navigator.vibrate(10);
                    }
                } catch (error) {
                    console.error('Failed to adjust zoom:', error);
                }
            }

            /**
             * Adjust camera focus with haptic feedback
             * @param {number} value - Focus value
             * @async
             */
            async adjustFocus(value) {
                if (!this.state.videoTrack || !this.state.capabilities.focus) return;

                try {
                    await this.state.videoTrack.applyConstraints({
                        advanced: [{ 
                            focusMode: 'manual',
                            focusDistance: value 
                        }]
                    });
                    
                    if (this.state.settings.hapticEnabled && navigator.vibrate) {
                        navigator.vibrate(10);
                    }
                } catch (error) {
                    console.error('Failed to adjust focus:', error);
                }
            }

            /**
             * Capture and process image from video stream with orientation correction
             * @returns {string} Base64 encoded JPEG image data
             * @throws {Error} If video is not ready or capture fails
             */
            captureImage() {
                const video = document.getElementById('cameraVideo');
                if (!video || !video.videoWidth || !video.videoHeight) {
                    throw new Error('Video not ready for capture');
                }

                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    if (!ctx) {
                        throw new Error('Failed to get canvas 2D context');
                    }
                    
                    // Apply orientation correction and set canvas dimensions
                    const { width, height, transformMatrix } = this.calculateOrientationTransform(
                        video.videoWidth, 
                        video.videoHeight, 
                        this.state.deviceOrientation
                    );
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Save context state
                    ctx.save();
                    
                    // Apply transformation matrix for orientation correction
                    ctx.setTransform(...transformMatrix);
                    
                    // Draw video frame with proper orientation
                    ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                    
                    // Restore context state
                    ctx.restore();
                    
                    // Optimize image size for API efficiency
                    const optimizedCanvas = this.optimizeImageSize(canvas);
                    
                    // Convert to base64 with optimal quality
                    const imageData = optimizedCanvas.toDataURL('image/jpeg', 0.88);
                    
                    console.log(`ðŸ“¸ Image captured: ${optimizedCanvas.width}x${optimizedCanvas.height}, ` +
                               `orientation: ${this.state.deviceOrientation}Â°, ` +
                               `size: ${Math.round(imageData.length / 1024)}KB`);
                    
                    return imageData;
                    
                } catch (error) {
                    console.error('Image capture failed:', error);
                    throw new Error(`Failed to capture image: ${error.message}`);
                }
            }

            /**
             * Calculate transformation matrix for device orientation correction
             * @param {number} videoWidth - Original video width
             * @param {number} videoHeight - Original video height
             * @param {number} orientation - Device orientation in degrees
             * @returns {Object} Transformation parameters
             */
            calculateOrientationTransform(videoWidth, videoHeight, orientation) {
                let width = videoWidth;
                let height = videoHeight;
                let transformMatrix = [1, 0, 0, 1, 0, 0]; // Identity matrix
                
                switch (orientation) {
                    case 90:
                        width = videoHeight;
                        height = videoWidth;
                        transformMatrix = [0, 1, -1, 0, videoHeight, 0];
                        break;
                    case -90:
                    case 270:
                        width = videoHeight;
                        height = videoWidth;
                        transformMatrix = [0, -1, 1, 0, 0, videoWidth];
                        break;
                    case 180:
                        transformMatrix = [-1, 0, 0, -1, videoWidth, videoHeight];
                        break;
                    default:
                        // No transformation needed for 0 degrees
                        break;
                }
                
                return { width, height, transformMatrix };
            }

            /**
             * Optimize image size for API processing while maintaining quality
             * @param {HTMLCanvasElement} sourceCanvas - Source canvas to optimize
             * @returns {HTMLCanvasElement} Optimized canvas
             */
            optimizeImageSize(sourceCanvas) {
                const MAX_DIMENSION = 1024;
                const { width: srcWidth, height: srcHeight } = sourceCanvas;
                
                // Return original if already within limits
                if (srcWidth <= MAX_DIMENSION && srcHeight <= MAX_DIMENSION) {
                    return sourceCanvas;
                }
                
                // Calculate optimal scaling factor
                const scale = Math.min(MAX_DIMENSION / srcWidth, MAX_DIMENSION / srcHeight);
                const newWidth = Math.round(srcWidth * scale);
                const newHeight = Math.round(srcHeight * scale);
                
                // Create optimized canvas
                const optimizedCanvas = document.createElement('canvas');
                const ctx = optimizedCanvas.getContext('2d');
                
                optimizedCanvas.width = newWidth;
                optimizedCanvas.height = newHeight;
                
                // Use high-quality scaling
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Draw scaled image
                ctx.drawImage(sourceCanvas, 0, 0, newWidth, newHeight);
                
                return optimizedCanvas;
            }

            /**
             * Process image with OpenAI API
             * @param {string} imageData - Base64 image data
             * @returns {string} AI response
             * @async
             */
            async processImage(imageData) {
                if (!this.validateApiKey(this.state.apiKey)) {
                    throw new Error('Valid API key is required (must start with sk-)');
                }

                if (!this.state.isOnline) {
                    throw new Error('Internet connection required for AI processing');
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.state.apiKey}`
                        },
                        body: JSON.stringify({
                            model: this.state.selectedModel,
                            reasoning_effort: 'high',
                            max_completion_tokens: 4000,
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are an expert in Reinforcement Learning multiple-choice quizzes. Analyze the image meticulously and provide the correct answer. Reply ONLY with the letter/number of the correct option (e.g., "A" or "B, D" for multiple answers). If the image is unreadable or contains no MCQ, reply exactly: UNREADABLE_OR_NO_MCQ'
                                },
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: 'Please solve the MCQ in this image and respond with only the answer letter(s).'
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: imageData,
                                                detail: 'high'
                                            }
                                        }
                                    ]
                                }
                            ]
                        }),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
                        
                        if (response.status === 401) {
                            throw new Error('Invalid API key. Please check your OpenAI API key.');
                        } else if (response.status === 429) {
                            throw new Error('Rate limit exceeded. Please try again later.');
                        } else if (response.status >= 500) {
                            throw new Error('OpenAI service temporarily unavailable. Please try again.');
                        }
                        
                        throw new Error(errorMessage);
                    }

                    const result = await response.json();
                    const content = result.choices?.[0]?.message?.content?.trim();
                    
                    if (!content) {
                        throw new Error('No response from AI service');
                    }

                    // Log usage information
                    if (result.usage) {
                        console.log('ðŸ¤– API Usage:', result.usage);
                    }

                    return content;

                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    if (error.name === 'AbortError') {
                        throw new Error('Request timed out. Please try again.');
                    }
                    throw error;
                }
            }

            /**
             * Handle capture button click with comprehensive processing
             * @async
             */
            async handleCapture() {
                if (this.state.isProcessing || !this.validateApiKey(this.state.apiKey) || !this.state.videoTrack) {
                    if (!this.validateApiKey(this.state.apiKey)) {
                        this.showSnackbar('Please enter a valid API key first', 'error');
                        this.openSettings();
                    }
                    return;
                }

                try {
                    await this.startToneContext();
                    
                    this.state.isProcessing = true;
                    this.updateUI();
                    
                    // Haptic feedback for capture
                    if (this.state.settings.hapticEnabled && navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]);
                    }
                    
                    // Visual and audio feedback
                    this.showLoading('Capturing image...');
                    this.playSound('capture');
                    
                    // Small delay for better UX
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Capture image
                    const imageData = this.captureImage();
                    
                    // Process with AI
                    this.showLoading('Analyzing with AI...');
                    this.playSound('processing');
                    
                    const result = await this.processImage(imageData);
                    
                    this.hideLoading();
                    
                    if (result === 'UNREADABLE_OR_NO_MCQ') {
                        this.showSnackbar('Image unreadable or no MCQ found', 'error');
                        this.playSound('error');
                        this.announceToScreenReader('Image could not be analyzed. Please try again with a clearer image.');
                    } else {
                        // Validate answer format
                        const answerPattern = /^[A-Za-z0-9]+(\s*,\s*[A-Za-z0-9]+)*$/;
                        const firstLine = result.split('\n')[0].trim();
                        
                        if (answerPattern.test(firstLine)) {
                            const answer = firstLine.toUpperCase();
                            this.displayAnswer(answer);
                            this.playSound('success');
                            
                            // Voice feedback
                            if (this.state.settings.voiceEnabled) {
                                this.speakAnswer(answer);
                            }
                            
                            // Haptic success pattern
                            if (this.state.settings.hapticEnabled && navigator.vibrate) {
                                navigator.vibrate([100, 50, 100, 50, 100]);
                            }
                            
                            this.announceToScreenReader(`Answer found: ${answer}`);
                        } else {
                            this.showSnackbar('Unexpected answer format received', 'error');
                            this.playSound('error');
                            console.warn('Unexpected AI response format:', result);
                        }
                    }
                    
                } catch (error) {
                    console.error('âŒ Processing failed:', error);
                    this.hideLoading();
                    
                    const errorMessage = this.getErrorMessage(error);
                    this.showSnackbar(errorMessage, 'error');
                    this.playSound('error');
                    this.announceToScreenReader(`Error: ${errorMessage}`);
                } finally {
                    this.state.isProcessing = false;
                    this.updateUI();
                }
            }

            /**
             * Display answer with animation and timing
             * @param {string} answer - Answer to display
             */
            displayAnswer(answer) {
                const answerDisplay = document.getElementById('answerDisplay');
                if (answerDisplay) {
                    answerDisplay.textContent = answer;
                    answerDisplay.classList.remove('hidden');
                    
                    // Hide after 8 seconds
                    setTimeout(() => {
                        answerDisplay.classList.add('hidden');
                    }, 8000);
                }
                
                this.showSnackbar(`Answer: ${answer}`, 'success', 6000);
                console.log(`âœ… Answer found: ${answer}`);
            }

            /**
             * Speak answer using text-to-speech with repetition
             * @param {string} answer - Answer to speak
             */
            speakAnswer(answer) {
                if (!this.state.settings.voiceEnabled) return;
                
                try {
                    speechSynthesis.cancel();
                    
                    const text = answer.length === 1 
                        ? `The answer is ${answer}`
                        : `The answers are ${answer.split('').join(', ')}`;
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.8;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.8;
                    utterance.lang = 'en-US';
                    
                    // Repeat the answer after a delay
                    utterance.onend = () => {
                        if (this.state.settings.voiceEnabled) {
                            setTimeout(() => {
                                const repeatUtterance = new SpeechSynthesisUtterance(
                                    `Again, ${answer.split('').join(', ')}`
                                );
                                repeatUtterance.rate = 0.8;
                                repeatUtterance.pitch = 1.0;
                                repeatUtterance.volume = 0.8;
                                repeatUtterance.lang = 'en-US';
                                speechSynthesis.speak(repeatUtterance);
                            }, 1500);
                        }
                    };
                    
                    speechSynthesis.speak(utterance);
                } catch (error) {
                    console.error('Speech synthesis failed:', error);
                }
            }

            /**
             * Start Tone.js audio context
             * @async
             */
            async startToneContext() {
                if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                    try {
                        await Tone.start();
                        this.audioContext = Tone.context;
                    } catch (error) {
                        console.error('Failed to start audio context:', error);
                    }
                }
            }

            /**
             * Request device orientation permission
             * @async
             */
            async requestDeviceOrientationPermission() {
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', this.handleOrientationChange);
                            console.log('ðŸ“± Device orientation permission granted');
                        }
                    } catch (error) {
                        console.error('Device orientation permission failed:', error);
                    }
                } else if (typeof DeviceOrientationEvent !== 'undefined') {
                    window.addEventListener('deviceorientation', this.handleOrientationChange);
                    console.log('ðŸ“± Device orientation listener added');
                }
            }

            /**
             * Handle device orientation changes
             * @param {DeviceOrientationEvent} event - Orientation event
             */
            handleOrientationChange(event) {
                const { beta, gamma } = event;
                if (beta === null || gamma === null) return;

                let newOrientation = 0;
                
                // More precise orientation detection
                const absBeta = Math.abs(beta);
                const absGamma = Math.abs(gamma);
                
                if (absGamma < 30 && absBeta > 60) {
                    newOrientation = 0; // Portrait
                } else if (absBeta < 30 && gamma > 60) {
                    newOrientation = 90; // Landscape left
                } else if (absBeta < 30 && gamma < -60) {
                    newOrientation = -90; // Landscape right
                } else if (absGamma < 30 && beta < -60) {
                    newOrientation = 180; // Portrait upside down
                }
                
                if (this.state.deviceOrientation !== newOrientation) {
                    this.state.deviceOrientation = newOrientation;
                    console.log(`ðŸ“± Device orientation: ${newOrientation}Â°`);
                }
            }

            /**
             * Handle app visibility changes
             */
            handleVisibilityChange() {
                if (document.hidden) {
                    if (this.state.isProcessing) {
                        this.stopProcessing();
                    }
                    this.pauseCamera();
                } else {
                    this.resumeCamera();
                }
            }

            /**
             * Handle page unload
             */
            handleBeforeUnload() {
                this.cleanup();
            }

            /**
             * Handle network status changes
             */
            handleOnlineStatus() {
                this.state.isOnline = navigator.onLine;
                if (this.state.isOnline) {
                    this.showSnackbar('Connection restored', 'success');
                } else {
                    this.showSnackbar('Connection lost', 'error');
                }
                this.updateUI();
            }

            /**
             * Pause camera to save resources
             */
            pauseCamera() {
                if (this.state.videoTrack) {
                    this.state.videoTrack.enabled = false;
                }
            }

            /**
             * Resume camera
             */
            resumeCamera() {
                if (this.state.videoTrack) {
                    this.state.videoTrack.enabled = true;
                } else if (this.validateApiKey(this.state.apiKey) && !this.state.isInitializing) {
                    // Reinitialize camera if needed
                    this.initCamera();
                }
            }

            /**
             * Stop processing and reset state
             */
            stopProcessing() {
                this.state.isProcessing = false;
                this.hideLoading();
                this.updateUI();
                clearTimeout(this.processingTimeout);
                speechSynthesis.cancel();
            }

            /**
             * Announce message to screen readers
             * @param {string} message - Message to announce
             */
            announceToScreenReader(message) {
                const ariaLiveRegion = document.getElementById('ariaLiveRegion');
                if (ariaLiveRegion) {
                    ariaLiveRegion.textContent = message;
                    // Clear after announcement
                    setTimeout(() => {
                        ariaLiveRegion.textContent = '';
                    }, 1000);
                }
            }

            /**
             * Toggle settings panel
             */
            toggleSettings() {
                const sheet = document.getElementById('settingsSheet');
                const isVisible = sheet?.classList.contains('visible');
                
                if (isVisible) {
                    this.closeSettings();
                } else {
                    this.openSettings();
                }
            }

            /**
             * Open settings panel with focus management
             */
            openSettings() {
                const sheet = document.getElementById('settingsSheet');
                if (sheet) {
                    sheet.classList.add('visible');
                    // Focus first input for accessibility
                    setTimeout(() => {
                        const firstInput = sheet.querySelector('input, select, button');
                        if (firstInput) firstInput.focus();
                    }, 300);
                }
            }

            /**
             * Close settings panel
             */
            closeSettings() {
                const sheet = document.getElementById('settingsSheet');
                if (sheet) {
                    sheet.classList.remove('visible');
                }
            }

            /**
             * Save settings with validation
             */
            saveSettings() {
                try {
                    // Validate API key before saving
                    const apiKey = this.state.apiKey.trim();
                    if (apiKey && !this.validateApiKey(apiKey)) {
                        this.showSnackbar('Invalid API key format. Must start with sk-', 'error');
                        return;
                    }

                    this.saveToLocalStorage('tv_api_key', apiKey);
                    this.saveToLocalStorage('tv_model', this.state.selectedModel);
                    this.saveToLocalStorage('tv_grid', this.state.settings.gridEnabled.toString());
                    this.saveToLocalStorage('tv_haptic', this.state.settings.hapticEnabled.toString());
                    this.saveToLocalStorage('tv_voice', this.state.settings.voiceEnabled.toString());
                    
                    this.showSnackbar('Settings saved successfully', 'success');
                    this.closeSettings();
                    this.updateUI();
                    
                    // Initialize camera if API key was just set
                    if (apiKey && !this.state.videoTrack) {
                        this.initCamera();
                    }
                    
                } catch (error) {
                    console.error('Failed to save settings:', error);
                    this.showSnackbar('Failed to save settings', 'error');
                }
            }

            /**
             * Confirm data clearing with user
             */
            confirmClearData() {
                if (confirm('Are you sure you want to clear all data? This will remove your API key and reset all settings.')) {
                    this.clearAllData();
                }
            }

            /**
             * Clear all application data
             */
            clearAllData() {
                try {
                    localStorage.clear();
                    
                    // Reset state
                    this.state.apiKey = '';
                    this.state.selectedModel = 'o3';
                    this.state.settings = {
                        gridEnabled: true,
                        hapticEnabled: true,
                        voiceEnabled: true
                    };
                    
                    // Update UI
                    this.safeUpdateElement('apiKeyInput', 'value', '');
                    this.safeUpdateElement('modelSelect', 'value', 'o3');
                    this.safeUpdateElement('modelChip', 'textContent', 'o3');
                    this.safeUpdateElement('gridToggle', 'checked', true);
                    this.safeUpdateElement('hapticToggle', 'checked', true);
                    this.safeUpdateElement('voiceToggle', 'checked', true);
                    
                    this.updateGridVisibility();
                    this.cleanup();
                    this.updateUI();
                    this.closeSettings();
                    
                    this.showSnackbar('All data cleared successfully', 'success');
                } catch (error) {
                    console.error('Failed to clear data:', error);
                    this.showSnackbar('Failed to clear data', 'error');
                }
            }

            /**
             * Update grid visibility based on settings
             */
            updateGridVisibility() {
                const grid = document.getElementById('viewfinderGrid');
                if (grid) {
                    grid.style.display = this.state.settings.gridEnabled ? 'block' : 'none';
                }
            }

            /**
             * Update UI state across all components
             */
            updateUI() {
                const hasValidApiKey = this.validateApiKey(this.state.apiKey);
                const hasCamera = !!this.state.videoTrack && !this.state.isInitializing;
                const canCapture = hasValidApiKey && hasCamera && !this.state.isProcessing && this.state.isOnline;
                
                // Update capture button
                const captureBtn = document.getElementById('captureBtn');
                if (captureBtn) {
                    captureBtn.disabled = !canCapture;
                    
                    let ariaLabel = 'Capture and analyze math problem';
                    if (!hasValidApiKey) ariaLabel += ' (API key required)';
                    else if (!hasCamera) ariaLabel += ' (camera not ready)';
                    else if (!this.state.isOnline) ariaLabel += ' (internet required)';
                    else if (this.state.isProcessing) ariaLabel += ' (processing...)';
                    
                    captureBtn.setAttribute('aria-label', ariaLabel);
                }
                
                // Update status chip
                const statusChip = document.getElementById('statusChip');
                if (statusChip) {
                    if (this.state.isProcessing) {
                        statusChip.textContent = 'Processing';
                        statusChip.className = 'status-chip processing';
                        statusChip.classList.remove('hidden');
                    } else if (canCapture) {
                        statusChip.textContent = 'Ready';
                        statusChip.className = 'status-chip success';
                        statusChip.classList.remove('hidden');
                    } else if (!this.state.isOnline) {
                        statusChip.textContent = 'Offline';
                        statusChip.className = 'status-chip error';
                        statusChip.classList.remove('hidden');
                    } else {
                        statusChip.classList.add('hidden');
                    }
                }
                
                // Update camera settings visibility
                this.updateCameraSettingsVisibility(hasCamera);
            }

            /**
             * Update camera settings panel visibility
             * @param {boolean} hasCamera - Whether camera is available
             */
            updateCameraSettingsVisibility(hasCamera) {
                const elements = {
                    cameraSettings: document.getElementById('cameraSettings'),
                    cameraSelectItem: document.getElementById('cameraSelectItem'),
                    zoomControl: document.getElementById('zoomControl'),
                    focusControl: document.getElementById('focusControl')
                };

                if (elements.cameraSettings) {
                    elements.cameraSettings.style.display = hasCamera ? 'block' : 'none';
                }
                
                if (elements.cameraSelectItem) {
                    elements.cameraSelectItem.style.display = 
                        (hasCamera && this.state.cameras.length > 1) ? 'flex' : 'none';
                }
                
                if (elements.zoomControl) {
                    elements.zoomControl.style.display = 
                        (hasCamera && this.state.capabilities.zoom) ? 'flex' : 'none';
                }
                
                if (elements.focusControl) {
                    elements.focusControl.style.display = 
                        (hasCamera && this.state.capabilities.focus) ? 'flex' : 'none';
                }
            }

            /**
             * Update camera status display
             * @param {string} status - Status message
             */
            updateCameraStatus(status) {
                this.safeUpdateElement('cameraStatus', 'textContent', status);
            }

            /**
             * Show loading overlay with message
             * @param {string} text - Loading message
             */
            showLoading(text) {
                const overlay = document.getElementById('loadingOverlay');
                const loadingText = document.getElementById('loadingText');
                
                if (loadingText) loadingText.textContent = text;
                if (overlay) overlay.classList.add('visible');
            }

            /**
             * Hide loading overlay
             */
            hideLoading() {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.classList.remove('visible');
            }

            /**
             * Show snackbar notification
             * @param {string} message - Message to show
             * @param {string} type - Message type (info, success, error)
             * @param {number} duration - Display duration in ms
             */
            showSnackbar(message, type = 'info', duration = 3000) {
                const snackbar = document.getElementById('snackbar');
                if (!snackbar) return;
                
                clearTimeout(this.snackbarTimeout);
                
                snackbar.textContent = message;
                snackbar.className = `snackbar ${type}`;
                snackbar.classList.add('show');
                
                this.snackbarTimeout = setTimeout(() => {
                    snackbar.classList.remove('show');
                }, duration);
            }

            /**
             * Show critical error overlay
             * @param {string} title - Error title
             * @param {string} message - Error message
             */
            showCriticalError(title, message) {
                const errorOverlay = document.createElement('div');
                errorOverlay.className = 'error-overlay';
                errorOverlay.innerHTML = `
                    <div class="error-message">${title}</div>
                    <div class="error-details">${message}</div>
                    <button class="md-button filled" onclick="location.reload()">Reload App</button>
                `;
                
                const app = document.getElementById('app');
                if (app) app.appendChild(errorOverlay);
            }

            /**
             * Get user-friendly error message
             * @param {Error} error - Error object
             * @returns {string} User-friendly error message
             */
            getErrorMessage(error) {
                if (error.message) {
                    if (error.message.includes('API key')) return 'Invalid API key';
                    if (error.message.includes('permission')) return 'Camera permission denied';
                    if (error.message.includes('timeout')) return 'Request timed out';
                    if (error.message.includes('network') || error.message.includes('fetch')) return 'Network error';
                    if (error.message.includes('quota') || error.message.includes('limit')) return 'Usage limit exceeded';
                    return error.message.length > 50 ? error.message.substring(0, 47) + '...' : error.message;
                }
                return 'An unexpected error occurred';
            }

            /**
             * Create promise with timeout
             * @param {Promise} promise - Promise to wrap
             * @param {number} ms - Timeout in milliseconds
             * @param {string} timeoutErrorMessage - Error message for timeout
             * @returns {Promise} Promise with timeout
             */
            promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
                let timeoutHandle;
                const timeoutPromise = new Promise((_, reject) => {
                    timeoutHandle = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms);
                });
                
                return Promise.race([promise, timeoutPromise]).finally(() => {
                    clearTimeout(timeoutHandle);
                });
            }

            /**
             * Comprehensive cleanup of resources
             */
            cleanup() {
                try {
                    console.log('ðŸ§¹ Cleaning up resources...');
                    
                    // Stop camera
                    if (this.state.mediaStream) {
                        this.state.mediaStream.getTracks().forEach(track => track.stop());
                        this.state.mediaStream = null;
                        this.state.videoTrack = null;
                    }
                    
                    // Cancel speech
                    if (typeof speechSynthesis !== 'undefined') {
                        speechSynthesis.cancel();
                    }
                    
                    // Clear timeouts
                    clearTimeout(this.processingTimeout);
                    clearTimeout(this.snackbarTimeout);
                    clearTimeout(this.cameraRetryTimeout);
                    clearTimeout(this.networkRetryTimeout);
                    
                    // Remove event listeners
                    document.removeEventListener('visibilitychange', this.handleVisibilityChange);
                    window.removeEventListener('beforeunload', this.handleBeforeUnload);
                    window.removeEventListener('online', this.handleOnlineStatus);
                    window.removeEventListener('offline', this.handleOnlineStatus);
                    window.removeEventListener('deviceorientation', this.handleOrientationChange);
                    
                    console.log('âœ… Cleanup complete');
                    
                } catch (error) {
                    console.error('Cleanup failed:', error);
                }
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('ðŸŒŸ Starting Traveler Vision App...');
                window.app = new TravelerVisionApp();
            } catch (error) {
                console.error('âŒ Failed to initialize app:', error);
                document.body.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 24px; text-align: center; background: #121212; color: #e0e0e0;">
                        <h1 style="color: #ff7b7b; margin-bottom: 16px;">App Failed to Load</h1>
                        <p style="margin-bottom: 24px;">${error.message || 'An unexpected error occurred'}</p>
                        <button onclick="location.reload()" style="padding: 12px 24px; background: #007aff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 16px;">Reload</button>
                    </div>
                `;
            }
        });

        // Global error handlers for production stability
        window.addEventListener('error', (e) => {
            console.error('ðŸ’¥ Global error:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('ðŸ’¥ Unhandled promise rejection:', e.reason);
        });

        console.log('ðŸš€ Traveler Vision App script loaded successfully');
    </script>
</body>
</html> 