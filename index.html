<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Traveler Vision · Math</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
:root {
    --bg: #121212; --fg: #e0e0e0; --hi: #6cbaff; --trk: #3a3a3a; --err: #ff7b7b; --succ: #7aff95;
    --btn-fg: #ffffff;
    --btn-hover-bg: #82c5ff; --btn-active-bg: #53a8e6;
    --input-focus-border: var(--hi);
    --shadow-color: rgba(0,0,0,0.4);
    font-size: 14px;
}
@media (prefers-color-scheme: light) {
    :root {
        --bg: #f7f7f7; --fg: #1f1f1f; --hi: #007aff; --trk: #d1d1d6; --err: #ff3b30; --succ: #34c759;
        --btn-fg: #ffffff;
        --btn-hover-bg: #005ec4; --btn-active-bg: #004a99;
        --shadow-color: rgba(0,0,0,0.1);
    }
}
* { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; }
body { display: flex; flex-direction: column; background: var(--bg); color: var(--fg); line-height: 1.4; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overscroll-behavior: contain; }

header {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.5rem 0.7rem; font-weight: 600; font-size: 1rem;
    border-bottom: 1px solid var(--trk); background-color: var(--bg);
    flex-shrink: 0; z-index: 20;
}
header .header-spacer { min-width: 40px; display: inline-block; }
header .title { flex-grow: 1; text-align: center; font-size: 0.95rem; }
header button#toggleLogBtn {
    font-size: 0.8rem; padding: 0.4rem 0.7rem; min-width: 40px;
    background: transparent; border: 1px solid var(--trk); color: var(--fg);
}
header button#toggleLogBtn:hover:not(:disabled) { background: var(--trk); }

.app-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; position: relative; }
.main-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

.controls-area {
    padding: 0.6rem 0.9rem; display: flex; flex-direction: column; gap: 0.6rem;
    background: var(--bg); border-bottom: 1px solid var(--trk);
    flex-shrink: 0; max-height: 45vh;
    overflow-y: auto; -webkit-overflow-scrolling: touch;
}
.control-group { display: flex; flex-direction: column; gap: 0.2rem; }
.control-row { display: flex; gap: 0.5rem; align-items: center; }
.control-row input[type="password"], .control-row select { flex-grow: 1; }
.control-row button { min-width: 70px; padding: 0.65rem 0.4rem; font-size: 0.8rem; }
#apiKeyDisplay { font-size: 0.8rem; color: var(--fg); background: var(--trk); padding: 0.6rem; border-radius: 5px; flex-grow: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

input[type="password"], select, button, textarea {
    padding: 0.7rem; border-radius: 6px; border: 1px solid var(--trk); background: var(--bg); color: var(--fg);
    font-size: 0.85rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
}
input:focus-visible, select:focus-visible, textarea:focus-visible { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 2.5px color-mix(in srgb, var(--input-focus-border) 25%, transparent); }
button { background: var(--hi); color: var(--btn-fg); border: none; cursor: pointer; font-weight: 500; transition: background-color 0.15s, opacity 0.15s, transform 0.1s; }
button:hover:not(:disabled) { background: var(--btn-hover-bg); }
button:active:not(:disabled) { background: var(--btn-active-bg); transform: scale(0.97); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--trk); transform: scale(1); }
label { font-size: 0.8rem; opacity: .9; font-weight: 500; padding-left: 0.1rem; margin-bottom: 0.1rem; }
output { font-weight: 500; margin-left: 0.25rem; font-feature-settings: "tnum"; font-size: 0.8rem; }
#zoomType { font-size: 0.7rem; opacity: 0.85; margin-left: 0.2rem; }

.range { appearance: none; width: 100%; height: 8px; border-radius: 4px; background: color-mix(in srgb, var(--trk) 70%, transparent); padding:0; cursor: pointer; transition: background-color 0.2s; margin-top: 0.1rem; margin-bottom: 0.1rem; }
.range:hover { background: var(--trk); }
.range::-webkit-slider-thumb { appearance:none; width:24px; height:24px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1.5px 4px var(--shadow-color); cursor:grab; }
.range::-webkit-slider-thumb:active { transform: scale(1.15); cursor: grabbing; }
.range::-moz-range-thumb { width:24px; height:24px; border-radius:50%; background:var(--hi); border: 3px solid var(--bg); box-shadow: 0 1.5px 4px var(--shadow-color); cursor:grab; }
.range::-moz-range-thumb:active { transform: scale(1.15); cursor: grabbing; }

.preview-area {
    flex-grow: 1; display: flex; justify-content: center; align-items: center;
    padding: 0.2rem; background: #0a0a0a; overflow: hidden; position: relative;
    min-height: 150px;
}
.frame {
    width: calc(100% - 8px); 
    aspect-ratio: 3 / 4;
    max-height: calc(100% - 8px);
    margin: auto;
    border-radius: 8px; overflow: hidden; background: #000; position: relative; box-shadow: 0 0 8px var(--shadow-color);
}
video { width: 100%; height: 100%; object-fit: cover; display: block; background: #050505; }

.video-spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.3); z-index: 5; opacity:0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s; pointer-events: none;
}
.video-spinner-overlay.visible { opacity:1; visibility: visible; }
.spinner { border: 3px solid rgba(255,255,255,0.2); border-top: 3px solid var(--hi); border-radius: 50%; width: 30px; height: 30px; animation: spin 0.8s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.critical-message-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction:column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.75); backdrop-filter: blur(3px); color: white;
    font-size: 0.95rem; text-align:center; padding:1.2rem; z-index: 15;
    opacity:0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
}
.critical-message-overlay.visible { opacity:1; visibility: visible; }

.status-bar {
    padding: 0.3rem 0.8rem; text-align: center; font-size: 0.8rem;
    background-color: var(--bg); border-top: 1px solid var(--trk); border-bottom: 1px solid var(--trk);
    color: var(--fg); flex-shrink: 0; min-height: 2.2em;
    line-height: 1.4; display: flex; align-items: center; justify-content: center;
}
.status-bar.error { color: var(--err); font-weight: 500; }
.status-bar.success { color: var(--succ); font-weight: 500; }

.actions-bar { padding: 0.5rem 0.8rem; display: flex; gap: 0.5rem; border-top: 1px solid var(--trk); background-color: var(--bg); flex-shrink: 0; z-index: 15; }
.actions-bar button { flex: 1; padding: 0.75rem; font-size: 0.9rem; font-weight: 600; }

.log-panel {
    position: absolute; bottom: 0; left: 0; right: 0; display: flex; flex-direction: column;
    height: 35vh; max-height: 240px; background-color: color-mix(in srgb, var(--bg) 97%, black);
    border-top: 1.5px solid var(--hi); box-shadow: 0 -3px 12px rgba(0,0,0,0.35);
    transform: translateY(100%); transition: transform 0.3s ease-in-out;
    z-index: 100;
}
.log-panel.visible { transform: translateY(0); }
#logTextarea { flex-grow: 1; resize: none; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.3; padding: 0.3rem 0.5rem; border: none; border-bottom: 1px solid var(--trk); }
#logTextarea:focus-visible { box-shadow: none; border-color: var(--trk); }
.log-bar { display: flex; align-items: center; padding: 0.3rem 0.5rem; gap: 0.5rem; flex-shrink: 0; }
.log-bar button { padding: 0.4rem 0.7rem; font-size: 0.75rem; flex-grow: 0; }
.log-bar label { display: flex; align-items: center; gap: 0.3rem; font-size: 0.75rem; cursor: pointer; user-select: none; }
.log-bar input[type="checkbox"] { width: 0.8rem; height: 0.8rem; accent-color: var(--hi); }

.toast {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%) scale(0.95); background-color: var(--hi); color: var(--btn-fg); padding: 0.8rem 1.2rem; border-radius: 20px; z-index: 2000; opacity: 0; visibility: hidden; font-size: 0.9rem; box-shadow: 0 3px 12px color-mix(in srgb, var(--shadow-color) 50%, transparent); transition: opacity 0.4s, top 0.4s, visibility 0.4s, transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); user-select: none; max-width: 90%; text-align: center;
}
.toast.show { opacity: 1; top: 25px; visibility: visible; transform: translateX(-50%) scale(1); }
.toast.hide { opacity: 0; top: -10px; transform: translateX(-50%) scale(0.9); } 
.toast.error { background-color: var(--err); }
.toast.success { background-color: var(--succ); }

.hidden-control { display: none !important; }
</style>
</head>
<body>

<header>
    <div class="header-spacer"></div>
    <span class="title">Traveler Vision · Math</span>
    <button id="toggleLogBtn">Log</button>
</header>

<div class="app-container">
    <div class="main-content-wrapper">
        <div class="controls-area">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key:</label>
                <div id="apiKeyEntryRow" class="control-row">
                    <input id="apiKey" type="password" placeholder="sk-...">
                    <button id="saveKeyBtn">Save</button>
                </div>
                <div id="apiKeyDisplayRow" class="control-row hidden-control">
                    <span id="apiKeyDisplay"></span>
                    <button id="changeKeyBtn">Change</button>
                    <button id="clearKeyBtn">Clear</button>
                </div>
            </div>
            <div id="modelToggleGroup" class="control-group hidden-control">
                <label>Model:</label>
                <div class="control-row">
                    <select id="modelSelect">
                        <option value="o3">o3 (GPT-4o)</option>
                        <option value="o4-mini">o4-mini</option>
                    </select>
                </div>
            </div>
            <div id="cameraControlsGroup" class="control-group hidden-control">
                <label for="cameraSelect">Camera:</label>
                <select id="cameraSelect" disabled></select>
            </div>
            <div id="zoomControlGroup" class="control-group hidden-control">
                <label for="zoomSlider">Zoom: <output id="zoomOutput">1</output>x <span id="zoomType"></span></label>
                <input id="zoomSlider" class="range" type="range" min="1" max="10" step="0.1" value="1" disabled>
            </div>
            <div id="focusControlGroup" class="control-group hidden-control">
                <label for="focusSlider">Focus: <output id="focusOutput">auto</output></label>
                <input id="focusSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" disabled>
            </div>
        </div>

        <div class="preview-area">
            <div class="frame">
                <video id="videoPreview" autoplay muted playsinline></video>
                <div id="videoSpinnerOverlay" class="video-spinner-overlay">
                    <div id="spinnerIcon" class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="criticalMessageOverlay" class="critical-message-overlay">
             <p id="criticalMessageText"></p>
        </div>
    </div>

    <div id="statusBar" class="status-bar">Initializing app...</div>

    <div class="actions-bar">
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="logPanel" class="log-panel">
        <textarea id="logTextarea" readonly placeholder="Log messages..."></textarea>
        <div class="log-bar">
            <button id="copyLogBtn">Copy</button>
            <label>
                <input type="checkbox" id="verboseLogCheck"> Verbose
            </label>
        </div>
    </div>
</div>

<div id="toast" class="toast"></div>

<script>
const $ = id => document.getElementById(id);

const AppState = {
    apiKey: "",
    mediaStream: null,
    videoTrack: null,
    isProcessing: false,
    isInitializingCamera: false,
    captureTimeout: null,
    cameraCapabilities: { zoom: null, focus: null, hasMultipleCameras: false },
    currentZoom: 1,
    toastTimeout: null,
    isLogVisible: false,
    toneStarted: false,
    deviceOrientationAngle: 0,
    selectedModel: "o3"
};

let sounds = {
    initSuccess: null, startAnalysis: null, captureSuccess: null, aiProcessingStart: null,
    aiSuccess: null, aiUnreadableOrNoMCQ: null, aiFormatError: null, error: null, toastInfo: null,
};

function initializeSounds() {
    if (typeof Tone === 'undefined') return;
    try {
        sounds.initSuccess = new Tone.PolySynth(Tone.Synth, { polyphony: 3, volume: -12, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 }, oscillator: { type: "sine" } }).toDestination();
        sounds.startAnalysis = new Tone.AMSynth({ volume: -15, harmonicity: 1.2, detune: 0, oscillator: { type: "fmsine", modulationType: "sine", modulationIndex: 2, harmonicity: 1.01 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.01, release: 0.1 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.05, decay: 0.01, sustain: 1, release: 0.05 } }).toDestination();
        sounds.captureSuccess = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.01 }, volume: -12 }).toDestination();
        sounds.aiProcessingStart = new Tone.Synth({ volume: -10, oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination();
        sounds.aiSuccess = new Tone.PolySynth(Tone.Synth, { polyphony:3, volume: -12, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3}, oscillator: {type: "triangle"} }).toDestination();
        sounds.aiUnreadableOrNoMCQ = new Tone.Synth({ volume: -18, oscillator: {type: "square", detune: 10 }, envelope: { attack: 0.01, decay: 0.4, sustain:0, release: 0.1} }).toDestination();
        sounds.aiFormatError = new Tone.Synth({ volume: -18, oscillator: {type: "sawtooth", detune: -20 }, envelope: { attack: 0.02, decay: 0.5, sustain:0, release: 0.1} }).toDestination();
        sounds.error = new Tone.NoiseSynth({ volume: -18, noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
        sounds.toastInfo = new Tone.Synth({ volume: -20, oscillator: {type: "sine"}, envelope: {attack:0.005,decay:0.1,sustain:0.01,release:0.1} }).toDestination();
    } catch (e) {
        console.error("Error initializing Tone.js sounds:", e);
    }
}
if (typeof Tone !== 'undefined') { initializeSounds(); }

async function startToneContext() {
    if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
        try {
            await Tone.start(); AppState.toneStarted = true;
            logger.log("Audio context started.");
        } catch (e) { logger.error("Error starting audio context.", e); }
    } else if (typeof Tone !== 'undefined' && Tone.context.state === 'running') {
        AppState.toneStarted = true;
    }
}

function playSound(soundName) {
    if (!AppState.toneStarted || !sounds[soundName]) {
      if (!AppState.toneStarted) logger.log(`Sound '${soundName}' skipped: audio context not started.`);
      return;
    }
    const now = Tone.now();
    try {
        if (soundName === 'initSuccess') sounds.initSuccess.triggerAttackRelease(["C5", "E5", "G5"], "16n", now);
        else if (soundName === 'startAnalysis') { sounds.startAnalysis.triggerAttackRelease("A4", "16n", now); sounds.startAnalysis.triggerAttackRelease("C5", "16n", now + 0.1); }
        else if (soundName === 'captureSuccess') sounds.captureSuccess.triggerAttack("C3", now);
        else if (soundName === 'aiProcessingStart') sounds.aiProcessingStart.triggerAttackRelease("E5", "16n", now);
        else if (soundName === 'aiSuccess') sounds.aiSuccess.triggerAttackRelease(["D5", "F#5", "A5"], "8n", now);
        else if (soundName === 'aiUnreadableOrNoMCQ') sounds.aiUnreadableOrNoMCQ.triggerAttackRelease("G3", "4n", now);
        else if (soundName === 'aiFormatError') sounds.aiFormatError.triggerAttackRelease("C#3", "4n", now);
        else if (soundName === 'error') sounds.error.triggerAttackRelease("8n", now);
        else if (soundName === 'toastInfo') sounds.toastInfo.triggerAttackRelease("C6", "32n", now);
    } catch (e) { logger.error(`Error playing sound ${soundName}`, e); }
}

const logger = {
    _logToTextarea: (message, details) => {
        const logTextarea = $('logTextarea');
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 1 });
        logTextarea.value += `[${timestamp}] ${message}\n`;
        if (details && $('verboseLogCheck').checked) {
            try {
                const detailStr = JSON.stringify(details, (key, value) => typeof value === 'bigint' ? value.toString() : value, 2);
                logTextarea.value += detailStr + "\n";
            } catch (e) { logTextarea.value += "[Details: Unserializable Object]\n"; }
        }
        logTextarea.scrollTop = logTextarea.scrollHeight;
        $('copyLogBtn').disabled = (logTextarea.value.trim() === "");
    },
    log: (message, details) => { console.log(`[INFO] ${new Date().toLocaleTimeString()} ${message}`, details || ''); logger._logToTextarea(message, details); },
    error: (message, errorObj) => {
        const errMsg = errorObj instanceof Error ? errorObj.message : (errorObj ? String(errorObj) : '');
        const fullMsg = `${message}${errMsg ? (': ' + errMsg) : ''}`; console.error(`[ERROR] ${new Date().toLocaleTimeString()} ${fullMsg}`, errorObj || '');
        logger._logToTextarea(`ERROR: ${message}`, errorObj instanceof Error ? { name: errorObj.name, message: errorObj.message, stack: errorObj.stack } : errorObj);
        showToast(message.length > 40 ? message.substring(0,37)+'...' : message, 'error', 5000);
        playSound('error');
    },
    success: (message, details) => {
        console.log(`[SUCCESS] ${new Date().toLocaleTimeString()} ${message}`, details || '');
        logger._logToTextarea(message, details);
        showToast(message, 'success');
        if (message.includes("API Key Saved") || message.includes("Log copied")) playSound('initSuccess');
        else if (message.includes("API Key Cleared")) playSound('toastInfo');
    }
};

function promiseWithTimeout(promise, ms, timeoutErrorMessage = 'Operation timed out') {
    let timer;
    const timeoutPromise = new Promise((_, reject) => { timer = setTimeout(() => reject(new Error(timeoutErrorMessage)), ms); });
    return Promise.race([ promise, timeoutPromise ]).finally(() => clearTimeout(timer));
}

const showToast = (message, type = 'info', duration = 3000) => {
    const el = $('toast'); clearTimeout(AppState.toastTimeout); el.textContent = message;
    el.className = 'toast';
    if (type === 'error') el.classList.add('error');
    else if (type === 'success') el.classList.add('success');
    
    el.classList.add('show');
    AppState.toastTimeout = setTimeout(() => { el.classList.remove('show'); }, duration);

    if (type === 'info') playSound('toastInfo');
    else if (type === 'success' && !(message.toLowerCase().includes("answer") || message.toLowerCase().includes("camera active") || message.toLowerCase().includes("api key") || message.toLowerCase().includes("log copied"))) {
        playSound('initSuccess');
    }
};

const updateStatus = (message, type = 'info', showSpinnerOnVideo = false) => {
    const statusBar = $('statusBar');
    const videoSpinnerOverlay = $('videoSpinnerOverlay');
    const criticalOverlay = $('criticalMessageOverlay');
    const criticalMessageText = $('criticalMessageText');

    if (type !== 'critical' && criticalOverlay.classList.contains('visible')) {
        criticalOverlay.classList.remove('visible');
    }

    if (message !== null) {
        statusBar.innerHTML = message;
        statusBar.className = 'status-bar';
        if (type === 'error') statusBar.classList.add('error');
        else if (type === 'success') statusBar.classList.add('success');
    }

    videoSpinnerOverlay.classList.toggle('visible', showSpinnerOnVideo);
    
    if (type === 'critical') {
        criticalMessageText.innerHTML = message;
        criticalOverlay.classList.add('visible');
        videoSpinnerOverlay.classList.remove('visible');
        if(statusBar) statusBar.innerHTML = '';
    }
};

const updateUI = () => {
    const keyPresent = !!AppState.apiKey;
    const cameraIsActuallyReady = !!AppState.videoTrack && !AppState.isInitializingCamera;

    $('apiKeyEntryRow').classList.toggle('hidden-control', keyPresent);
    $('apiKeyDisplayRow').classList.toggle('hidden-control', !keyPresent);
    if (keyPresent) { $('apiKeyDisplay').textContent = `Key: sk-••••${AppState.apiKey.slice(-4)}`; }
    $('changeKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    $('clearKeyBtn').disabled = AppState.isProcessing || AppState.isInitializingCamera;
    
    $('modelToggleGroup').classList.toggle('hidden-control', !keyPresent);
    $('modelSelect').disabled = AppState.isProcessing || AppState.isInitializingCamera;

    const controlsDisabled = AppState.isInitializingCamera || AppState.isProcessing;
    $('cameraControlsGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.hasMultipleCameras || !AppState.videoTrack || AppState.isInitializingCamera);
    $('cameraSelect').disabled = controlsDisabled || !cameraIsActuallyReady;
    
    $('zoomControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.zoom || !AppState.videoTrack || AppState.isInitializingCamera);
    $('zoomSlider').disabled = controlsDisabled || !cameraIsActuallyReady || !AppState.cameraCapabilities.zoom;
    
    $('focusControlGroup').classList.toggle('hidden-control', !AppState.cameraCapabilities.focus || !AppState.videoTrack || AppState.isInitializingCamera);
    $('focusSlider').disabled = controlsDisabled || !cameraIsActuallyReady || !AppState.cameraCapabilities.focus;

    $('startBtn').disabled = !keyPresent || !cameraIsActuallyReady || AppState.isProcessing || AppState.isInitializingCamera;
    $('stopBtn').disabled = !AppState.isProcessing;
    $('copyLogBtn').disabled = ($('logTextarea').value.trim() === "");
    $('toggleLogBtn').textContent = AppState.isLogVisible ? 'Hide Log' : 'Log';

    if (!AppState.isInitializingCamera && cameraIsActuallyReady && !AppState.isProcessing) {
        const currentStatus = $('statusBar').textContent;
        const nonOverrideStates = ['initializing app...', '', 'initializing camera', 'stopped', 'api key cleared', 'welcome!'];
        if (nonOverrideStates.some(s => currentStatus.toLowerCase().includes(s.toLowerCase()))) {
             updateStatus("Ready! Aim at the problem.", 'success', false);
        }
    }
};

const setupCameraControls = () => {
    if (!AppState.videoTrack) {
        AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;
        updateUI(); return;
    }
    const cap = AppState.videoTrack.getCapabilities();
    const settings = AppState.videoTrack.getSettings();
    AppState.cameraCapabilities.zoom = null; AppState.cameraCapabilities.focus = null;

    if (cap.zoom) {
        AppState.cameraCapabilities.zoom = { ...cap.zoom };
        $('zoomSlider').min = cap.zoom.min || 1;
        $('zoomSlider').max = cap.zoom.max || 10;
        $('zoomSlider').step = cap.zoom.step || 0.1;
        const currentZoom = settings.zoom || cap.zoom.min || 1;
        $('zoomSlider').value = currentZoom;
        $('zoomOutput').textContent = parseFloat(currentZoom).toFixed(1);
        AppState.currentZoom = parseFloat(currentZoom);
        updateZoomTypeIndicator();
    }
    if (cap.focusMode?.includes("manual") && cap.focusDistance) {
        AppState.cameraCapabilities.focus = { ...cap.focusDistance };
        $('focusSlider').min = cap.focusDistance.min || 0;
        $('focusSlider').max = cap.focusDistance.max || 1;
        $('focusSlider').step = cap.focusDistance.step || 0.01;
        $('focusSlider').value = settings.focusDistance || cap.focusDistance.min || 0;
        $('focusOutput').textContent = parseFloat($('focusSlider').value).toFixed(2);
    }
    updateUI();
};

const releaseCamera = () => {
    if (AppState.mediaStream) { AppState.mediaStream.getTracks().forEach(t => t.stop()); logger.log("Camera stream released."); }
    if ($('videoPreview')) $('videoPreview').srcObject = null;
    AppState.mediaStream = null; AppState.videoTrack = null;
    setupCameraControls();
};

const _initCameraWork = async (deviceId) => {
    releaseCamera();
    const constraints = {
        video: {
            aspectRatio: { ideal: 3 / 4 },
            height: { ideal: 1920 }, 
            facingMode: "environment",
            frameRate: { ideal: 24, max: 30 }
        },
        audio: false
    };
    if (deviceId) { constraints.video.deviceId = { exact: deviceId }; delete constraints.video.facingMode; }
    
    logger.log(`Attempting camera: ${deviceId || 'default (environment facing)'}`, constraints.video);
    AppState.mediaStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia(constraints), 10000, "Camera access request timed out. Please respond to prompts.");
    
    const tracks = AppState.mediaStream.getVideoTracks();
    if (tracks.length === 0) throw new Error("No video tracks found in stream.");
    AppState.videoTrack = tracks[0];
    logger.log(`Video track acquired: ${AppState.videoTrack.label}. Settings: ${JSON.stringify(AppState.videoTrack.getSettings())}`);
    
    const videoEl = $('videoPreview'); videoEl.srcObject = AppState.mediaStream;
    await promiseWithTimeout(new Promise((resolve, reject) => {
        videoEl.onloadedmetadata = resolve;
        videoEl.onerror = () => reject(new Error("Video element failed to load stream."));
    }), 5000, "Video stream metadata loading timed out.");
    
    logger.success(`Camera active: ${AppState.videoTrack.label || 'N/A'}`);
    playSound('initSuccess');
    setupCameraControls();
};

const listCameras = async () => {
    if (AppState.isInitializingCamera) { logger.log("listCameras skipped: initialization already in progress."); return; }
    AppState.isInitializingCamera = true; updateStatus("Initializing camera...", 'info', true); updateUI();

    try {
        logger.log("Verifying camera permissions...");
        try {
            const permStream = await promiseWithTimeout(navigator.mediaDevices.getUserMedia({ video: true, audio: false }), 8000, "Camera permission check timed out.");
            permStream.getTracks().forEach(t => t.stop());
            logger.log("Preliminary camera permission check passed.");
        } catch (pErr) {
            logger.error("Preliminary camera permission check failed.", pErr);
            let msg = `Could not verify camera permissions.`;
            if (pErr.name === "NotAllowedError" || pErr.name === "PermissionDeniedError") msg = "Camera access denied.<br>Please allow camera access in browser settings and refresh.";
            else if (pErr.message.includes("timed out")) msg = "Camera permission check timed out.<br>Please respond to prompts, then refresh.";
            else msg = `Camera permission error: ${pErr.name || pErr.message}`;
            updateStatus(msg, 'critical'); throw pErr;
        }

        logger.log("Enumerating video devices...");
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        const cameraSelectEl = $('cameraSelect'); cameraSelectEl.innerHTML = '';

        if (videoDevices.length === 0) {
            logger.error("No video input devices found after enumeration.");
            updateStatus("No cameras found on this device.", 'critical');
            AppState.cameraCapabilities.hasMultipleCameras = false; throw new Error("No video devices found.");
        }
        logger.log(`Found ${videoDevices.length} video devices.`);
        AppState.cameraCapabilities.hasMultipleCameras = videoDevices.length > 1;
        videoDevices.forEach(device => { const opt = document.createElement('option'); opt.value = device.deviceId; opt.text = device.label || `Camera ${cameraSelectEl.options.length + 1}`; cameraSelectEl.appendChild(opt); });

        let selectedDeviceId = videoDevices[0].deviceId;
        try {
            const lastCamId = localStorage.getItem("TV_LAST_CAM");
            if (lastCamId && videoDevices.some(d => d.deviceId === lastCamId)) selectedDeviceId = lastCamId;
            else { const envCam = videoDevices.find(d => d.label.toLowerCase().includes('back') || d.label.toLowerCase().includes('environment')); if (envCam) selectedDeviceId = envCam.deviceId; }
        } catch (e) { logger.error("localStorage error (last cam).", e); }
        cameraSelectEl.value = selectedDeviceId;
        
        cameraSelectEl.onchange = () => { if(AppState.isInitializingCamera || AppState.isProcessing) return; try { localStorage.setItem("TV_LAST_CAM", cameraSelectEl.value); } catch (e) { logger.error("localStorage error (save cam).",e); } listCameras(); };
        await _initCameraWork(selectedDeviceId);

    } catch (err) {
        logger.error(`listCameras main process error: ${err.message}`, err);
        if (!AppState.videoTrack && !document.querySelector('.critical-message-overlay.visible')) {
            let userMsg = `Failed to initialize camera system.`;
            if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError" || err.message.includes("No video devices")) userMsg = "No suitable camera found on device.";
            else if (err.name === "OverconstrainedError" || err.name === "ConstraintNotSatisfiedError") userMsg = "Camera doesn't support requested settings (e.g., 3:4 aspect ratio). Try another camera or check permissions.";
            else if (err.message.includes("timed out")) userMsg = err.message;
            else if (err.message && !(err.name === "NotAllowedError" || err.name === "PermissionDeniedError")) userMsg = `Camera error: ${err.message.substring(0, 70)}`;
            else if (!(err.name === "NotAllowedError" || err.name === "PermissionDeniedError")) userMsg = "An unknown error occurred with the camera.";
            
            if (!(err.name === "NotAllowedError" || err.name === "PermissionDeniedError" || (err.message.includes("timed out") && document.querySelector('.critical-message-overlay.visible')))) {
                updateStatus(userMsg, 'error');
            }
        }
        releaseCamera();
    } finally { AppState.isInitializingCamera = false; updateUI(); }
};

const captureImage = () => {
    const videoEl = $('videoPreview');
    if (!videoEl.videoWidth || !videoEl.videoHeight || !AppState.videoTrack || AppState.isInitializingCamera) {
        logger.error("Video not ready for capture."); return null;
    }

    const videoIntrinsicWidth = videoEl.videoWidth; 
    const videoIntrinsicHeight = videoEl.videoHeight;
    const videoIntrinsicAR = videoIntrinsicWidth / videoIntrinsicHeight;
    const targetFrameAR = 3 / 4; 

    let sx = 0, sy = 0, sWidth = 0, sHeight = 0;
    if (videoIntrinsicAR > targetFrameAR) {
        sHeight = videoIntrinsicHeight; sWidth = videoIntrinsicHeight * targetFrameAR;
        sx = (videoIntrinsicWidth - sWidth) / 2; sy = 0;
    } else {
        sWidth = videoIntrinsicWidth; sHeight = videoIntrinsicWidth / targetFrameAR;
        sx = 0; sy = (videoIntrinsicHeight - sHeight) / 2;
    }
    
    sWidth = Math.max(1, Math.floor(sWidth)); sHeight = Math.max(1, Math.floor(sHeight));
    sx = Math.max(0, Math.floor(sx)); sy = Math.max(0, Math.floor(sy));
    if (sx + sWidth > videoIntrinsicWidth) sWidth = videoIntrinsicWidth - sx;
    if (sy + sHeight > videoIntrinsicHeight) sHeight = videoIntrinsicHeight - sy;

    if (sWidth <= 0 || sHeight <= 0) { logger.error("Calculated source crop dimensions invalid.", {sWidth, sHeight}); return null; }
    
    const sourceCropCanvas = document.createElement('canvas'); 
    sourceCropCanvas.width = sWidth; 
    sourceCropCanvas.height = sHeight;
    sourceCropCanvas.getContext('2d').drawImage(videoEl, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

    let canvasToProcess = sourceCropCanvas;
    const angle = AppState.deviceOrientationAngle;

    if (angle === 90 || angle === -90) {
        const rotatedCanvas = document.createElement('canvas');
        const rad = angle * Math.PI / 180;
        
        rotatedCanvas.width = sourceCropCanvas.height;
        rotatedCanvas.height = sourceCropCanvas.width;
        
        const ctx = rotatedCanvas.getContext('2d');
        if (angle === 90) {
            ctx.translate(rotatedCanvas.width, 0);
        } else {
            ctx.translate(0, rotatedCanvas.height);
        }
        ctx.rotate(rad);
        ctx.drawImage(sourceCropCanvas, 0, 0, sourceCropCanvas.width, sourceCropCanvas.height);
        canvasToProcess = rotatedCanvas;
        logger.log(`Image rotated by ${angle} degrees for AI.`);
    }
    
    let effectiveDigitalZoom = 1;
    if (AppState.cameraCapabilities.zoom && AppState.currentZoom > AppState.cameraCapabilities.zoom.max) {
        effectiveDigitalZoom = AppState.currentZoom / AppState.cameraCapabilities.zoom.max;
    } else if (!AppState.cameraCapabilities.zoom && AppState.currentZoom > 1) {
        effectiveDigitalZoom = AppState.currentZoom;
    }
    
    const zoomedWidth = Math.floor(canvasToProcess.width / effectiveDigitalZoom);
    const zoomedHeight = Math.floor(canvasToProcess.height / effectiveDigitalZoom);
    if (zoomedWidth <= 0 || zoomedHeight <= 0) { logger.error("Calculated digital zoom dimensions invalid.", {zoomedWidth, zoomedHeight}); return null; }
    
    const digitallyZoomedCanvas = document.createElement('canvas');
    digitallyZoomedCanvas.width = zoomedWidth; 
    digitallyZoomedCanvas.height = zoomedHeight;
    digitallyZoomedCanvas.getContext('2d').drawImage(
        canvasToProcess, 
        Math.floor((canvasToProcess.width - zoomedWidth) / 2), 
        Math.floor((canvasToProcess.height - zoomedHeight) / 2), 
        zoomedWidth, zoomedHeight, 
        0, 0, zoomedWidth, zoomedHeight
    );
    
    const MAX_TARGET_HEIGHT = 1024; 
    let finalW = digitallyZoomedCanvas.width, finalH = digitallyZoomedCanvas.height;

    if (finalH > MAX_TARGET_HEIGHT) {
        const scale = MAX_TARGET_HEIGHT / finalH;
        finalH = MAX_TARGET_HEIGHT;
        finalW = Math.round(finalW * scale);
    }
    finalW = Math.max(1, finalW); finalH = Math.max(1, finalH);
    
    const finalCanvas = document.createElement('canvas'); 
    finalCanvas.width = finalW; 
    finalCanvas.height = finalH;
    finalCanvas.getContext('2d').drawImage(digitallyZoomedCanvas, 0, 0, digitallyZoomedCanvas.width, digitallyZoomedCanvas.height, 0, 0, finalW, finalH);
    
    const imageDataUrl = finalCanvas.toDataURL('image/jpeg', 0.85);
    playSound('captureSuccess');
    logger.log(`Image captured (sent: ${finalW}x${finalH}, aspect: ${(finalW/finalH).toFixed(2)}, size: ${Math.round(imageDataUrl.length/1024)}KB).`,
                 {originalStream: `${videoIntrinsicWidth}x${videoIntrinsicHeight}`, targetCropAR: targetFrameAR.toFixed(2), calculatedCrop: `${sWidth}x${sHeight} from ${sx},${sy}`, deviceAngle: AppState.deviceOrientationAngle, digitalZoomFactor: effectiveDigitalZoom.toFixed(2)});
    return imageDataUrl;
};

const solveMathProblem = async (imageDataUrl) => {
    if (!AppState.apiKey) throw new Error("API Key is missing.");
    logger.log(`Sending image to OpenAI (${AppState.selectedModel})...`, { imageSizeKB: Math.round(imageDataUrl.length / 1024) });

    const messages = [
        { role: "system", content: "You are an expert in Reinforcement Learning multiple-choice quizzes. Your primary goal is to determine the correct answer with the highest possible accuracy. Analyze the provided image meticulously. Consider all details, and take sufficient time to reason through the problem. After your thorough analysis, reply **on the FIRST line only** with the identifier(s) of the correct option(s) – letter or number – comma-separated if several (e.g. \"A\" or \"B, D\"). If the image is unreadable, no MCQ is found, or if you cannot determine the answer with high confidence, reply *only* with the exact phrase: UNREADABLE_OR_NO_MCQ" },
        { role: "user", content: [ { type: "text", text: "Please solve the MCQ in this image and respond as instructed above." }, { type: "image_url", image_url: { url: imageDataUrl, detail: "high" } } ] }
    ];
    const payload = { model: AppState.selectedModel, reasoning_effort: "high", max_completion_tokens: 8000, messages };

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${AppState.apiKey}` },
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
        const errData = await response.json().catch(() => ({ error: { message: `HTTP ${response.status} ${response.statusText}` } }));
        logger.error("OpenAI API Error", errData.error ? errData.error : {message: response.statusText, status: response.status});
        throw new Error(`OpenAI API Error: ${errData.error?.message || response.statusText}`);
    }

    const data = await response.json();
    if (data.usage) logger.log("OpenAI usage:", data.usage);
    else logger.log("OpenAI response received, no usage data.", data);

    const raw = (data.choices?.[0]?.message?.content || "").trim();
    if (raw === "UNREADABLE_OR_NO_MCQ") { playSound('aiUnreadableOrNoMCQ'); return { extractedAnswer: null, statusMessage: "AI: Image unreadable or no MCQ found." }; }
    if (/^[A-Za-z0-9]+(\s*,\s*[A-Za-z0-9]+)*$/u.test(raw.split('\n')[0].trim())) {
        const answer = raw.split('\n')[0].trim().replace(/\s+/g, "").toUpperCase();
        playSound('aiSuccess'); return { extractedAnswer: answer, statusMessage: `AI Answer: ${answer}` };
    }
    
    playSound('aiFormatError');
    logger.log("AI response not in expected option format.", { rawResponse: raw });
    return { extractedAnswer: null, statusMessage: "AI response format unexpected (see log)." };
};

const processFrame = async () => {
    if (!AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack) {
        if(AppState.isProcessing) logger.log("Process frame skipped (conditions not met).");
        updateUI(); return;
    }
    updateStatus("Capturing...", 'info', true); const imgData = captureImage();
    if (!imgData) {
        logger.error("Image capture failed for processing.");
        if(AppState.isProcessing) AppState.captureTimeout = setTimeout(processFrame, 10000);
        updateStatus("Capture failed. Retrying soon.",'error'); updateUI(); return;
    }
    try {
        playSound('aiProcessingStart');
        updateStatus(`Analyzing RL Quiz (${AppState.selectedModel})...`, 'info', true);
        const { extractedAnswer, statusMessage } = await promiseWithTimeout(solveMathProblem(imgData), 120000, "AI analysis timed out after 120s.");
        
        logger.log(`AI Status: ${statusMessage}`, { extractedOption: extractedAnswer });
        if (extractedAnswer) {
            logger.success(`Extracted Option(s): ${extractedAnswer}`);
            updateStatus(`Answer: ${extractedAnswer}`, 'success');
            showToast(`Answer: ${extractedAnswer}`, 'success', 5000);
            try { 
                speechSynthesis.cancel();
                const mainSpokenText = `Answer is ${extractedAnswer.split('').join(', ')}`;
                const speakRepeatedly = (text, times, interval) => {
                    let count = 0;
                    function speak() {
                        if (!AppState.isProcessing || count >= times) return;
                        const utterance = new SpeechSynthesisUtterance(count === 0 ? text : `Again, ${text.replace("Answer is ","")}`);
                        speechSynthesis.speak(utterance);
                        count++;
                        if (count < times && AppState.isProcessing) {
                            utterance.onend = () => { if(AppState.isProcessing) setTimeout(speak, interval); };
                        }
                    }
                    speak();
                };
                speakRepeatedly(mainSpokenText, 3, 1500);
            } catch(e) { logger.error("Speech synthesis failed.", e); }
        } else {
            logger.log(statusMessage || "AI provided no clear option.");
            updateStatus(statusMessage.length > 60 ? statusMessage.substring(0, 57) + "..." : statusMessage, 'info');
            showToast(statusMessage.length > 40 ? statusMessage.substring(0, 37) + "..." : statusMessage, 'info', 4000);
        }
    } catch (err) {
        logger.error(`Processing error: ${err.message}`, err);
        const isAPIKeyError = err.message.includes("API Key") || err.message.includes("401") || err.message.includes("authentication");
        if (isAPIKeyError) { if (AppState.isProcessing) $('stopBtn').click(); updateStatus(`API Key Error. Please verify your key.`, 'critical'); }
        else if (err.message.includes("timed out")) { updateStatus(`AI analysis timed out. Try again.`, 'error'); }
        else { updateStatus(`Error: ${err.message.substring(0,70)}...`, 'error'); }
    } finally {
        if (AppState.isProcessing) {
            if (AppState.videoTrack && !AppState.isInitializingCamera) { updateStatus("Ready for next. Aim at problem.", 'info', false); }
            AppState.captureTimeout = setTimeout(processFrame, 10000);
        }
        updateUI();
    }
};

const updateZoomTypeIndicator = () => {
    const indicator = $('zoomType');
    if (!AppState.cameraCapabilities.zoom || !indicator) { if(indicator) indicator.textContent = ''; return; }
    if (AppState.currentZoom > AppState.cameraCapabilities.zoom.max) {
        indicator.textContent = '(Digital)'; indicator.style.color = 'var(--hi)';
    } else {
        indicator.textContent = '(Optical)'; indicator.style.color = 'var(--succ)';
    }
};
const toggleLogPanel = () => { AppState.isLogVisible = !AppState.isLogVisible; $('logPanel').classList.toggle('visible', AppState.isLogVisible); updateUI(); };

async function handleUserInteractionForAudio() { if (!AppState.toneStarted) { await startToneContext(); } }

function handleOrientation(event) {
    const beta = event.beta; 
    const gamma = event.gamma; 

    if (beta === null || gamma === null) { return; }

    const portraitMaxGamma = 25; 
    const landscapeMinAbsGamma = 45; 
    const landscapeMaxBeta = 25; 
    
    let newAngle = AppState.deviceOrientationAngle;

    if (Math.abs(gamma) < portraitMaxGamma && Math.abs(beta) > landscapeMinAbsGamma) {
        newAngle = 0; 
    } else if (Math.abs(beta) < landscapeMaxBeta && Math.abs(gamma) > landscapeMinAbsGamma) {
        if (gamma > landscapeMinAbsGamma) {
            newAngle = 90; 
        } else if (gamma < -landscapeMinAbsGamma) {
            newAngle = -90; 
        }
    }
    
    if (AppState.deviceOrientationAngle !== newAngle) {
        AppState.deviceOrientationAngle = newAngle;
         logger.log(`Device orientation angle: ${AppState.deviceOrientationAngle}°`);
    }
}

async function requestDeviceOrientationPermission() {
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const permissionState = await DeviceOrientationEvent.requestPermission();
      if (permissionState === 'granted') {
        window.addEventListener('deviceorientation', handleOrientation);
        logger.log("Device orientation permission granted.");
      } else {
        logger.log("Device orientation permission not granted.");
      }
    } catch (error) {
      logger.error("Error requesting device orientation permission (iOS). May need user gesture.", error);
      window.addEventListener('deviceorientation', handleOrientation);
    }
  } else if (typeof DeviceOrientationEvent !== 'undefined'){
    window.addEventListener('deviceorientation', handleOrientation);
    logger.log("Standard device orientation listener added (non-iOS or no permission API).");
  } else {
    logger.log("DeviceOrientationEvent not supported by this browser.");
  }
}


$('saveKeyBtn').onclick = async () => {
    await handleUserInteractionForAudio(); if(AppState.isInitializingCamera || AppState.isProcessing) return;
    const apiKeyInput = $('apiKey').value.trim();
    if (apiKeyInput.startsWith("sk-")) {
        AppState.apiKey = apiKeyInput; try { localStorage.setItem("TV_API_KEY", apiKeyInput); } catch (e) { logger.error("localStorage error (save key).",e); }
        logger.success("API Key Saved!");
        if (!AppState.videoTrack && !AppState.isInitializingCamera) { listCameras(); } else { updateUI(); }
        requestDeviceOrientationPermission(); 
    } else { logger.error("Invalid API Key format. Must start with 'sk-'."); }
};
$('changeKeyBtn').onclick = async () => {
    await handleUserInteractionForAudio(); if(AppState.isInitializingCamera || AppState.isProcessing) return;
    $('apiKeyEntryRow').classList.remove('hidden-control'); $('apiKeyDisplayRow').classList.add('hidden-control');
    $('apiKey').value = AppState.apiKey; $('apiKey').focus(); updateUI();
};
$('clearKeyBtn').onclick = async () => {
    await handleUserInteractionForAudio(); if(AppState.isInitializingCamera || AppState.isProcessing) return;
    logger.log("Clearing API Key."); AppState.apiKey = ""; try { localStorage.removeItem("TV_API_KEY"); } catch (e) { logger.error("localStorage error (clear key).",e); }
    $('apiKey').value = ""; if (AppState.isProcessing) $('stopBtn').click();
    releaseCamera(); logger.success("API Key Cleared."); updateStatus("API Key cleared. Enter new key.", 'info'); updateUI();
};
$('zoomSlider').oninput = (e) => {
    if(AppState.isInitializingCamera || !AppState.videoTrack || !AppState.cameraCapabilities.zoom) return;
    const zoomValue = parseFloat(e.target.value);
    $('zoomOutput').textContent = zoomValue.toFixed(1); AppState.currentZoom = zoomValue; updateZoomTypeIndicator();
    if (zoomValue <= AppState.cameraCapabilities.zoom.max) {
        AppState.videoTrack.applyConstraints({ advanced: [{ zoom: zoomValue }] }).catch(err => logger.error(`Hardware zoom error`, err));
    }
};
$('focusSlider').oninput = (e) => {
    if(AppState.isInitializingCamera || !AppState.videoTrack || !AppState.cameraCapabilities.focus) return;
    const focusValue = parseFloat(e.target.value);
    $('focusOutput').textContent = focusValue.toFixed(2);
    AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: focusValue }] }).catch(err => logger.error(`Focus error`, err));
};
$('startBtn').onclick = async () => {
    await handleUserInteractionForAudio(); if(AppState.isProcessing || AppState.isInitializingCamera || !AppState.videoTrack || !AppState.apiKey) return;
    requestDeviceOrientationPermission();
    AppState.isProcessing = true; logger.log("Processing started by user."); playSound('startAnalysis');
    updateStatus("Starting...", 'info', true); updateUI(); processFrame();
};
$('stopBtn').onclick = async () => {
    await handleUserInteractionForAudio(); if(!AppState.isProcessing) return;
    AppState.isProcessing = false; clearTimeout(AppState.captureTimeout); speechSynthesis.cancel();
    logger.log("Processing stopped by user."); playSound('toastInfo'); updateStatus("Stopped.", 'info'); updateUI();
};
$('copyLogBtn').onclick = async () => {
    await handleUserInteractionForAudio(); const logText = $('logTextarea').value;
    if(!logText.trim()){ showToast("Log is empty.",'info'); return; }
    try { await navigator.clipboard.writeText(logText); logger.success("Log copied to clipboard."); }
    catch (err) { logger.error("Failed to copy log. Select manually.",err); $('logTextarea').select(); $('logTextarea').setSelectionRange(0,999999); showToast("Log selected for manual copy.",'info'); }
};
$('verboseLogCheck').onchange = () => {
    logger.log(`Verbose logging ${$('verboseLogCheck').checked ? 'enabled' : 'disabled'}.`);
    try { localStorage.setItem("TV_VERBOSE_LOG", $('verboseLogCheck').checked ? 'true' : 'false'); } catch (e) { logger.error("localStorage error (verbose).", e); }
};
$('toggleLogBtn').onclick = async () => { await handleUserInteractionForAudio(); toggleLogPanel(); };

$('modelSelect').onchange = async () => {
    await handleUserInteractionForAudio(); 
    if(AppState.isInitializingCamera || AppState.isProcessing) return;
    AppState.selectedModel = $('modelSelect').value;
    try { localStorage.setItem("TV_MODEL", AppState.selectedModel); } catch (e) { logger.error("localStorage error (save model).",e); }
    logger.success(`Model changed to ${AppState.selectedModel}`);
    showToast(`Model: ${AppState.selectedModel}`, 'info');
};

document.addEventListener('DOMContentLoaded', () => {
    updateStatus("Initializing app...", 'info');
    try { AppState.apiKey = localStorage.getItem("TV_API_KEY") || ""; } catch (e) { logger.error("localStorage error (load key).",e); AppState.apiKey = ""; }
    try { $('verboseLogCheck').checked = localStorage.getItem("TV_VERBOSE_LOG") === 'true'; } catch (e) { logger.error("localStorage error (load verbose).",e); }
    try { 
        const savedModel = localStorage.getItem("TV_MODEL");
        if (savedModel && (savedModel === "o3" || savedModel === "o4-mini")) {
            AppState.selectedModel = savedModel;
            $('modelSelect').value = savedModel;
        }
    } catch (e) { logger.error("localStorage error (load model).",e); }
    
    if (AppState.apiKey) { 
        listCameras(); 
        requestDeviceOrientationPermission(); 
    }
    else { updateStatus("Welcome!<br>Please enter OpenAI API Key to begin.", 'info'); }
    updateUI();
});
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === 'hidden') {
        if (AppState.isProcessing) { $('stopBtn').click(); }
        if (AppState.videoTrack) { releaseCamera(); logger.log("App hidden, camera released."); updateUI(); }
    } else if (document.visibilityState === 'visible') {
        if (AppState.apiKey && !AppState.videoTrack && !AppState.isInitializingCamera && !AppState.isProcessing) {
            logger.log("App visible, re-initializing camera."); listCameras();
        }
    }
});
window.addEventListener('beforeunload', () => { releaseCamera(); speechSynthesis.cancel(); });

</script>
</body>
</html>